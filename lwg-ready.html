<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2018-06-06 at 21:10:37 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="2183" href="#2183">2183</a><sup><a href="https://cplusplus.github.io/LWG/issue2183">(i)</a></sup>. Muddled allocator requirements for <tt>match_results</tt> constructors</h3>
<p><b>Section:</b> 31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a>, 31.10.6 <a href="https://wg21.link/re.results.all">[re.results.all]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2018-06-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a> p1 says:
</p>
<blockquote><p>
In all <tt>match_results</tt> constructors, a copy of the <tt>Allocator</tt> argument shall be used for any memory 
allocation performed by the constructor or member functions during the lifetime of the object.
</p></blockquote>
<p>
There are three constructors:
</p>
<blockquote><pre>
match_results(const Allocator&amp; = Allocator());
match_results(const match_results&amp; m);
match_results(match_results&amp;&amp; m) noexcept;
</pre></blockquote>
<p>
The second and third constructors do no have an <tt>Allocator</tt> argument, so despite the "all <tt>match_results</tt> 
constructors", it is not possible to use "the <tt>Allocator</tt> argument" for the second and third constructors.
<p/>
The requirements for those two constructors also does not give any guidance. The second constructor has no language 
about allocators, and the third states that the stored <tt>Allocator</tt> value is move constructed from 
<tt>m.get_allocator()</tt>, but doesn't require using that allocator to allocate memory.
<p/>
The same basic problem recurs in 31.10.6 <a href="https://wg21.link/re.results.all">[re.results.all]</a>, which gives the required return value for 
<tt>get_allocator()</tt>:
</p>
<blockquote><p>
<i>Returns</i>: A copy of the <tt>Allocator</tt> that was passed to the object's constructor or, if that allocator 
has been replaced, a copy of the most recent replacement.
</p></blockquote>
<p>
Again, the second and third constructors do not take an <tt>Allocator</tt>, so there is nothing that meets this 
requirement when those constructors are used.
</p>

<p><i>[2018-06-02, Daniel comments and provides wording]</i></p>

<p>
The introductory wording of <tt>match_results</tt> says in 31.10 <a href="https://wg21.link/re.results">[re.results]</a> p2:
</p>
<blockquote><p>
The class template <tt>match_results</tt> satisfies the requirements of an allocator-aware container and of a sequence
container (26.2.1, 26.2.3) except that only operations defined for const-qualified sequence containers are
supported and that the semantics of comparison functions are different from those required for a container.
</p></blockquote>
<p>
This wording essentially brings us to 26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a> which describes in p8 in general the
usage of allocators:
</p>
<blockquote><p>
[&hellip;] Copy constructors for these container types obtain an allocator by calling <tt>allocator_traits&lt;allocator_
type&gt;::select_on_container_copy_construction</tt> on the allocator belonging to the container being copied.
Move constructors obtain an allocator by move construction from the allocator belonging to the container being moved.
[&hellip;]
</p></blockquote>
<p>
The constructors referred to in the issue discussion are the copy constructor and move constructor of <tt>match_results</tt>,
so we know already what the required effects are supposed to be.
<p/>
26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a> p8 also says more to this allocator topic a bit latter:
</p>
<blockquote><p>
[&hellip;] All other constructors for these container types take a <tt>const allocator_type&amp;</tt> argument. 
[<i>Note:</i> If an invocation of a constructor uses the default value of an optional allocator argument, then the 
Allocator type must support value-initialization. &mdash; <i>end note</i>] A copy of this allocator is used for any 
memory allocation and element construction performed, by these constructors and by all member functions, during the 
lifetime of each container object or until the allocator is replaced.
[&hellip;]
</p></blockquote>
<p>
Further requirements imposed on two of the three <tt>match_results</tt> constructors can be derived from Table 80 &mdash; 
"Allocator-aware container requirements" via the specified expressions
</p>
<blockquote><pre>
X()
X(m)
X(rv)
</pre></blockquote>
<p>
In other words: The existing wording does already say <em>everything</em> that it said by 31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a> p1 (end 
even more), except for possibly the tiny problem that
</p>
<blockquote><pre>
match_results(const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
uses "<tt>const Allocator&amp;</tt>" instead of "<tt>const allocator_type&amp;</tt>" in the signature, albeit even 
that deviation shouldn't change the intended outcome, which is IMO crystal-clear when looking at sub-clauses 
26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a> and 26.2.3 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a> as a whole.
<p/>
That directly makes two mutually exclusive solutions feasible:
</p>
<ul>
<li><p>Either strike 31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a> p1 completely; or</p></li>
<li><p>Replace 31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a> p1 by referring to the specification of allocators in
26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a> and 26.2.3 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a>.</p></li>
</ul>
<p>
My suggestion is to favour for the first option, because attempting to provide extra wording that refers to allocators
and the three constructors may lead to the false impression that no further allocator-related
requirements hold for type <tt>match_results</tt> which are not explicitly repeated here again.
</p>

<p><i>[2018-06, Rapperswil]</i></p>

<p>
The group agrees with the provided resolution. Move to Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Edit 31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a> as indicated:</p>
<blockquote>
<p>
<del>-1- In all <tt>match_results</tt> constructors, a copy of the <tt>Allocator</tt> argument shall be used for any memory allocation
performed by the constructor or member functions during the lifetime of the object.</del>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2184" href="#2184">2184</a><sup><a href="https://cplusplus.github.io/LWG/issue2184">(i)</a></sup>. Muddled allocator requirements for <tt>match_results</tt> assignments</h3>
<p><b>Section:</b> 31.10.1 <a href="https://wg21.link/re.results.const">[re.results.const]</a>, 31.10.6 <a href="https://wg21.link/re.results.all">[re.results.all]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2018-06-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The effects of the two assignment operators are specified in Table 141. Table 141 makes no mention of allocators, 
so, presumably, they don't touch the target object's allocator. That's okay, but it leaves the question: 
<tt>match_results::get_allocator()</tt> is supposed to return "A copy of the Allocator that was passed to the 
object's constructor or, if that allocator has been replaced, a copy of the most recent replacement"; if assignment 
doesn't replace the allocator, how can the allocator be replaced?
</p>

<p><i>[2018-06-04, Daniel comments and provides wording]</i></p>

<p>
Similar to the reasoning provided in the 2018-06-02 comment in LWG <a href="lwg-active.html#2183">2183</a>, it is possible to refer to 
the introductory wording of <tt>match_results</tt> which says in 31.10 <a href="https://wg21.link/re.results">[re.results]</a> p2:
</p>
<blockquote><p>
The class template <tt>match_results</tt> satisfies the requirements of an allocator-aware container and 
of a sequence container (26.2.1, 26.2.3) except that only operations defined for const-qualified sequence 
containers are supported and that the semantics of comparison functions are different from those required 
for a container.
</p></blockquote>
<p>
Again, similar to LWG <a href="lwg-active.html#2183">2183</a>, this allows us to deduce the required effects of the copy/move
assignment operators discussed here, because 26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a> p8 also says:
</p>
<blockquote><p>
[&hellip;] The allocator may be replaced only via assignment or <tt>swap()</tt>. Allocator replacement is 
performed by copy assignment, move assignment, or swapping of the allocator only if 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</tt>,
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt>, or 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is <tt>true</tt> 
within the implementation of the corresponding container operation. In all container types defined in 
this Clause, the member <tt>get_allocator()</tt> returns a copy of the allocator used to construct the 
container or, if that allocator has been replaced, a copy of the most recent replacement. [&hellip;]
</p></blockquote>
<p>
So this wording already specifies everything we need, <em>except</em> for the problem that
31.10 <a href="https://wg21.link/re.results">[re.results]</a> p2 quoted above restricts to operations supported by a const-qualified sequence 
container, which of-course would exclude the copy assignment and the move assignment operators.
But given that these mutable definitions are defined for <tt>match_results</tt>, it seems that the only fix 
needed is to adjust 31.10 <a href="https://wg21.link/re.results">[re.results]</a> p2 a bit to ensure that both assignment operators are 
covered (again) by the general allocator-aware container wording. 
</p>

<p><i>[2018-06, Rapperswil]</i></p>

<p>
The group generally likes the suggested direction, but would prefer the changed wording to say effectively
"except that only copy assignment, move assignment, and operations defined...". Once applied, move to ready.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Edit 31.10 <a href="https://wg21.link/re.results">[re.results]</a> as indicated:</p>
<blockquote>
<p>
-2- The class template <tt>match_results</tt> satisfies the requirements of an allocator-aware container 
and of a sequence container (26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a>, 26.2.3 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a>) 
except that <ins>besides copy assignment and move assignment</ins> only operations defined for 
const-qualified sequence containers are supported and that the semantics of comparison functions are 
different from those required for a container.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-06-06, Daniel updates wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Edit 31.10 <a href="https://wg21.link/re.results">[re.results]</a> as indicated:</p>
<blockquote>
<p>
-2- The class template <tt>match_results</tt> satisfies the requirements of an allocator-aware container 
and of a sequence container (26.2.1 <a href="https://wg21.link/container.requirements.general">[container.requirements.general]</a>, 26.2.3 <a href="https://wg21.link/sequence.reqmts">[sequence.reqmts]</a>) 
except that only <ins>copy assignment, move assignment, and</ins> operations defined for 
const-qualified sequence containers are supported and that the semantics of comparison functions are 
different from those required for a container.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2996" href="#2996">2996</a><sup><a href="https://cplusplus.github.io/LWG/issue2996">(i)</a></sup>. Missing rvalue overloads for <tt>shared_ptr</tt> operations</h3>
<p><b>Section:</b> 23.11.3 <a href="https://wg21.link/util.smartptr.shared">[util.smartptr.shared]</a>, 23.11.3.9 <a href="https://wg21.link/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2017-07-07 <b>Last modified:</b> 2018-06-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>shared_ptr</tt> aliasing constructor and the <tt>shared_ptr</tt> casts are specified to take a <tt>shared_ptr</tt> 
by <tt>const</tt> reference and construct a new <tt>shared_ptr</tt> that shares ownership with it, and yet they have no 
corresponding rvalue reference overloads. That results in an unnecessary refcount increment/decrement when those operations 
are given an rvalue. Rvalue overloads can't be added as a conforming extension because they observably change semantics 
(but mostly only for code that does unreasonable things like pass an argument by move and then rely on the fact that it's 
unchanged), and [res.on.arguments]/p1.3 doesn't help because it only applies to rvalue reference parameters.
<p/>
This issue is related to <a href="https://wg21.link/p0390r0">P0390R0</a>.
</p>

<p><i>[2017-07 Toronto Tuesday PM issue prioritization]</i></p>

<p>Status LEWG</p>

<p><i>[2018-06 Rapperswil Monday AM]</i></p>

<p>Move to Ready; choosing the PR in the issue as opposed to <a href="https://wg21.link/P0390R0">P0390R0</a>
and rebase wording to most recent working draft</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li><p>Edit 23.10.2 <a href="https://wg21.link/memory.syn">[memory.syn]</a>, header <tt>&lt;memory&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>// 23.11.3.9 <a href="https://wg21.link/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a>,</i> shared_ptr <i>casts</i>
template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
shared_ptr&lt;T&gt; reinterpret_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Edit 23.11.3 <a href="https://wg21.link/util.smartptr.shared">[util.smartptr.shared]</a>, class template <tt>shared_ptr</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; class shared_ptr {
public:
  [&hellip;]
  <i>// 23.11.3.1 <a href="https://wg21.link/util.smartptr.shared.const">[util.smartptr.shared.const]</a>, constructors</i>
  [&hellip;]
  template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
  template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, element_type* p) noexcept;
  <ins>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r, element_type* p) noexcept;</ins>
  shared_ptr(const shared_ptr&amp; r) noexcept;
  [&hellip;]
};
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Edit 23.11.3.1 <a href="https://wg21.link/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> the <tt>use_count()</tt> postcondition can safely be deleted because it is redundant with 
the "shares ownership" wording in the <i>Effects</i>. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, element_type* p) noexcept;
<ins>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r, element_type* p) noexcept;</ins>
</pre>
<blockquote>
<p>
-14- <i>Effects:</i> Constructs a <tt>shared_ptr</tt> instance that stores <tt>p</tt> and shares ownership with 
<ins>the initial value of</ins> <tt>r</tt>.
<p/>
-15- <i>Postconditions:</i> <tt>get() == p <del>&amp;&amp; use_count() == r.use_count()</del></tt>. <ins>For the 
second overload, <tt>r</tt> is empty and <tt>r.get() == nullptr</tt>.</ins>
<p/>
-16- [<i>Note:</i> To avoid the possibility of a dangling pointer, the user of this constructor must ensure that <tt>p</tt>
remains valid at least until the ownership group of <tt>r</tt> is destroyed. &mdash; <i>end note</i>]
<p/>
-17- [<i>Note:</i> This constructor allows creation of an empty <tt>shared_ptr</tt> instance with a non-null stored pointer.
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 23.11.3.9 <a href="https://wg21.link/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> The expression <tt>static_cast&lt;T*&gt;((U*)nullptr)</tt> shall be well-formed.
<p/>
-2- <i>Returns:</i> 
<blockquote>
<tt>shared_ptr&lt;T&gt;(<del>r</del><ins><i>R</i></ins>, static_cast&lt;typename 
  shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))</tt>
</blockquote>
<ins>, where <tt><i>R</i></tt> 
is <tt>r</tt> for the first overload, and <tt>std::move(r)</tt> for the second.</ins>
<p/>
-3- [<i>Note:</i> The seemingly equivalent expression <tt>shared_ptr&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))</tt> 
will eventually result in undefined behavior, attempting to delete the same object twice. &mdash; <i>end note</i>]
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> The expression <tt>dynamic_cast&lt;T*&gt;((U*)nullptr)</tt> shall be well-formed. The 
expression <tt>dynamic_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get())</tt> shall be well formed 
and shall have well-defined behavior.
<p/>
-5- <i>Returns:</i>
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; When <tt>dynamic_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get())</tt> returns 
a non-null value <tt>p</tt>, <tt>shared_ptr&lt;T&gt;(<del>r</del><ins><i>R</i></ins>, p)</tt><ins>, where 
<tt><i>R</i></tt> is <tt>r</tt> for the first overload, and <tt>std::move(r)</tt> for the second</ins>.</p></li>
<li><p>(5.2) &mdash; Otherwise, <tt>shared_ptr&lt;T&gt;()</tt>.</p></li>
</ol>
<p>
-6- [<i>Note:</i> The seemingly equivalent expression <tt>shared_ptr&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))</tt> 
will eventually result in undefined behavior, attempting to delete the same object twice. &mdash; <i>end note</i>]
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
</pre>
<blockquote>
<p>
-7- <i>Requires:</i> The expression <tt>const_cast&lt;T*&gt;((U*)nullptr)</tt> shall be well-formed.
<p/>
-8- <i>Returns:</i> 
<blockquote>
<tt>shared_ptr&lt;T&gt;(<del>r</del><ins><i>R</i></ins>, const_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))</tt>
</blockquote>
<ins>, where <tt><i>R</i></tt> is <tt>r</tt> for the first overload, and <tt>std::move(r)</tt> 
for the second.</ins>
<p/>
-9- [<i>Note:</i> The seemingly equivalent expression <tt>shared_ptr&lt;T&gt;(const_cast&lt;T*&gt;(r.get()))</tt> 
will eventually result in undefined behavior, attempting to delete the same object twice. &mdash; <i>end note</i>]
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
<ins>template&lt;class T, class U&gt;
  shared_ptr&lt;T&gt; reinterpret_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;</ins>
</pre>
<blockquote>
<p>
-10- <i>Requires:</i> The expression <tt>reinterpret_cast&lt;T*&gt;((U*)nullptr)</tt> shall be well-formed.
<p/>
-11- <i>Returns:</i> 
<blockquote>
<tt>shared_ptr&lt;T&gt;(<del>r</del><ins><i>R</i></ins>, reinterpret_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))</tt>
</blockquote>
<ins>, where <tt><i>R</i></tt> is <tt>r</tt> for the first overload, and <tt>std::move(r)</tt> 
for the second.</ins>
<p/>
-12- [<i>Note:</i> The seemingly equivalent expression <tt>shared_ptr&lt;T&gt;(reinterpret_cast&lt;T*&gt;(r.get()))</tt> 
will eventually result in undefined behavior, attempting to delete the same object twice. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>




</body>
</html>
