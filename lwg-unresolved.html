<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2016-08-04 at 21:08:51 UTC</p>
</p><h2>Unresolved Issues</h2>
<hr>
<h3><a name="1173" href="#1173">1173.</a> "Equivalence" wishy-washiness</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-07-14 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue: The <tt>CopyConstructible</tt> requirements are wishy-washy.  It requires
that the copy is "equivalent" to the original, but "equivalent" is never
defined.
</p>
<p>
I believe this to be an example of a more general lack of rigor around
copy and assignment, although I haven't done the research to dig up all
the instances.
</p>
<p>
It's a problem because if you don't know what <tt>CopyConstructible</tt> means,
you also don't know what it means to copy a pair of <tt>CopyConstructible</tt>
types.  It doesn't prevent us from writing code, but it is a hole in our
ability to understand the meaning of copy.
</p>
<p>
Furthermore, I'm pretty sure that vector's copy constructor doesn't
require the elements to be <tt>EqualityComparable</tt>, so that table is actually
referring to some ill-defined notion of equivalence when it uses ==.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to "Open". Dave is right that this is a big issue. Paper D2987
("Defining Move Special Member Functions", Bjarne Stroustrup and
Lawrence Crowl) touches on this but does not solve it. This issue is
discussed in Elements of Programming.
</p></blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This issue is quite vague, so it is difficult to know if and when it has been resolved.
John Lakos wrote a paper covering this area a while back, and there is a real interest 
in providing some sort of clean-up in the future. We need a more clearly draughted 
issues with an addressable set of concerns, ideally with a paper proposing a resolution, 
but for a future revision of the standard. Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1175" href="#1175">1175.</a> <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</p></blockquote>

<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <tt>DefaultConstructible</tt>
requirements of the value type I disagree: The function argument <tt>n</tt> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <tt>EmplaceConstructible</tt>
into <tt>*this</tt>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <tt>X a(n);</tt>
has a complexity of <tt>n</tt> bucket allocations, but this part of the work is omitted for
<tt>X a(i, j, n);</tt>, even though it is considerable larger (in the average case) for 
<tt>n &#8811; distance(i, j)</tt>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The proposed wording looks good.  Move to Review.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Fix up some presentation issues with the wording, combining the big-O expressions into single
expressions rather than the sum of two separate big-Os.
</p>
<p>
Strike "constant or linear", prefer "linear in the number of buckets".
This allows for number of buckets being larger than requested <tt>n</tt> as well.
</p>
<p>
Default <tt>n</tt> to "unspecified" rather than "implementation-defined".  It seems an un-necessary
burden asking vendors to document a quantity that is easily determined through the public API of
these classes.
</p>
<p>
Replace <tt>distance(f,l)</tt> with "number of elements in the range <tt>[f,l)</tt>"
</p>
<p>
Retain in Review with the updated wording
</p>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
The wording still does not call out Pablo's original concern, that the element constructor is called
no more than <tt>N</tt> times, and that the <tt>N</tt> squared term applies to moves during rehash.
</p>

<p>
Inconsistent use of O(n)+O(N) vs. O(n+N), with a preference for the former.
</p>

<p>
AJM to update wording with a reference to "no more than <tt>N</tt> element constructor calls".
</p>

<p>
Matt concerned that calling out the O(n) requirements is noise, and dangerous noise in suggesting a precision
we do not mean.  The cost of constructing a bucket is very different to constructing an element of user-supplied
type.
</p>

<p>
AJM notes that if there are multiple rehashes, the 'n' complexity is probably not linear.
</p>

<p>
Matt suggests back to Open, Pablo suggests potentially NAD if we keep revisitting without achieving a resolution.
</p>

<p>
Matt suggests complexity we are concerned with is the number of operations, such as constructing elements, moving
nodes, and comparing/hashing keys.  We are less concerned with constructing buckets, which are generally noise in
this bigger picture.
</p>

<p><i>[2015-01-29 Telecon]</i></p>

<p>
AM: essentially correct, but do we want to complicate the spec?
<p/>
HH: Pablo has given us permission to NAD it
<p/>
JM: when I look at the first change in the P/R I find it mildly disturbing that the existing wording says you have a 
constant time constructor with a single element even if your <tt>n</tt> is 10^6, so I think adding this change makes people 
aware there might be a large cost in initializing the hash table, even though it doesn't show up in user-visible constructions.
<p/>
HH: one way to avoid that problem is make the default ctor <tt>noexcept</tt>. Then the container isn't allowed to create 
an arbitrarily large hash table
<p/>
AM: but this is the constructor where the user provides <tt>n</tt>
<p/>
MC: happy with the changes, except I agree with the editorial recommendation to keep the two &#x1d4aa;s separate.
<p/>
JW: yes, the constant '<tt>k</tt>' is different in &#x1d4aa;(n) and &#x1d4aa;(N)
<p/>
GR: do we want to talk about buckets at all
<p/>
JM: yes, good to highlight that bucket construction might be a significant cost
<p/>
HH: suggest we take the suggestion to split &#x1d4aa;(n+N) to &#x1d4aa;(n)+&#x1d4aa;(N) and move to Tentatively Ready
<p/>
GR: 23.2.1p2 says all complexity requirements are stated solely in terms of the number of operations on the contained 
object, so we shouldn't be stating complexity in terms of the hash table initialization
<p/>
HH: channeling Pete, there's an implicit "unless otherwise specified" everywhere.
<p/>
VV: seem to be requesting modifications that render this not Tentatively Ready
<p/>
GR: I think it can't be T/R
<p/>
AM: make the editorial recommendation, consider fixing 23.2.1/3 to give us permission to state complexity in terms 
of bucket initialization
<p/>
HH: only set it to Review after we get new wording to review 
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Update wording, revisit later.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <tt>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</tt> to
<tt>&#x1d4aa;(n + <em>N</em>)</tt>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)</tt><br/>
<tt>X a(i, j, n, hf, eq)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)</tt><br/>
<tt>X a(i, j, n, hf)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case &#x1d4aa;(<tt><i><ins>n + </ins>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n)</tt><br/>
<tt>X a(i, j, n)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case &#x1d4aa;(<tt><i><ins>n + </ins>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 23.5.4.2 [unord.map.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.5.2 [unord.multimap.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.2 [unord.set.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.7.2 [unord.multiset.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1213" href="#1213">1213.</a> Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="lwg-defects.html#208">208</a> (including further updates by <a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.10.10 [specialized.algorithms]/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <tt>ForwardIterator</tt> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In 99 [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p>
Consider to await the paper.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2035" href="#2035">2035.</a> Output iterator requirements are broken</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="lwg-active.html#2038">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> could be defined in a more
general way not restricted to iterators (similar to the concepts <tt>HasDereference</tt> and 
<tt>HasPreincrement</tt> from working draft N2914). But on the other hand, all current usages of 
<tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
24.2.1 [iterator.requirements.general] and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <tt>reference</tt>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<tt>reference</tt>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="lwg-defects.html#2042">2042</a>: <tt>forward_list&lt;&gt;::before_begin()</tt> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <tt>++r</tt> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <tt>--r</tt> of bidirectional iterators.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus this is the correct direction, but there are (potentially) missing <i>incrementable</i>
preconditions on some table rows, and the Remarks on when an output iterator becomes dereferencable
are probably better handled outside the table, in a manner similar to the way we word for input
iterators.
</p>

<p>
There was some concern about redundant pre-conditions when the operational semantic is defined in
terms of operations that have preconditions, and a similar level of concern over dropping such
redundancies vs. applying a consistent level of redundant specification in all the iterator tables.
Wording clean-up in either direction would be welcome.
</p>

<p><i>[2011-08-18: Daniel adapts the proposed resolution to honor the Bloomington request]</i></p>


<p>
There is only a small number of further changes suggested to get rid of superfluous 
requirements and essentially non-normative assertions. Operations should not have extra 
pre-conditions, if defined by "in-terms-of" semantics, see e.g. <tt>a != b</tt> or <tt>a-&gt;m</tt> 
for Table 107. Further, some remarks, that do not impose anything or say nothing new have been removed, 
because I could not find anything helpful they provide.
E.g. consider the remarks for Table 108 for the operations dereference-assignment and
preincrement: They don't provide additional information say nothing surprising. With the
new pre-conditions <em>and</em> post-conditions it is implied what the remarks intend to say.
</p>

<p><i>[
2011-11-03: Some observations from Alexander Stepanov via c++std-lib-31405
]</i></p>


<p>
The following sentence is dropped from the standard section on OutputIterators:
<p/>
"In particular, the following two conditions should hold: first, any
iterator value should be assigned through before it is incremented
(this is, for an output iterator <tt>i, i++; i++;</tt> is not a valid code
sequence); second, any value of an output iterator may have at most
one active copy at any given time (for example, <tt>i = j; *++i = a; *j = b;</tt> 
is not a valid code sequence)."
</p>

<p><i>[
2011-11-04: Daniel comments and improves the wording
]</i></p>


<p>
In regard to the first part of the comment, the intention of the newly proposed wording 
was to make clear that for the expression
</p>
<blockquote><pre>
*r = o
</pre></blockquote>
<p>
we have the precondition dereferenceable and the post-condition
incrementable. And for the expression
</p>
<blockquote><pre>
++r
</pre></blockquote>
<p>
we have the precondition incrementable and the post-condition dereferenceable 
or past-the-end. This <em>should not</em>  allow for a sequence like <tt>i++; i++;</tt> 
but I agree that it doesn't exactly say that.
<p/>
In regard to the second point: To make this point clearer, I suggest to
add a similar additional wording as we already have for input iterator to the 
"Assertion&#47;note" column of the expression <tt>++r</tt>:
<p/>
"Post: any copies of the previous value of <tt>r</tt> are no longer 
required to be dereferenceable or incrementable."
<p/>
The proposed has been updated to honor the observations of Alexander Stepanov.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
The matter is complicated, Daniel volunteers to write a paper.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 24.2.1 [iterator.requirements.general] to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 23.2.5 [unord.req] on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>17.6.3.2 [swappable.requirements] p5:</p>

<blockquote><p>
-5- A type <tt>X</tt> satisfying any of the iterator requirements (24.2) is <tt><i>ValueSwappable</i></tt> if, 
for any dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> object <tt>x</tt> of type 
<tt>X</tt>, <tt>*x</tt> is swappable.
</p></blockquote>
</li>

<li><p>17.6.3.5 [allocator.requirements], Table 27 &mdash; &quot;Descriptive variable definitions&quot;, 
row with the expression <tt>c</tt>:</p>

<blockquote><p>
a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> pointer of type <tt>C*</tt>
</p></blockquote>

</li>

<li><p>20.10.3.2 [pointer.traits.functions]:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
pointer to <tt>r</tt> obtained by calling <tt>Ptr::pointer_to(r)</tt>;  [&hellip;]
</p></blockquote>
</li>

<li><p>21.3.1.3 [string.iterators] p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote>
</li>

<li><p>22.4.5.1.2 [locale.time.get.virtuals] p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <tt>t</tt> shall be dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote></blockquote>
</li>

<li><p>23.2.1 [container.requirements.general] p. 6:</p>

<blockquote><p>
[&hellip;]  <tt>end()</tt> returns an iterator which is the past-the-end <ins>(24.2.1 [iterator.requirements.general])</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.3 [sequence.reqmts] p. 3:</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.4 [associative.reqmts] p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.5 [unord.req] p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> and <tt>q1</tt> are valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterators to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 24.2.1 [iterator.requirements.general] p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
-5- Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <tt>i</tt> for which the
expression <tt>*i</tt> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <tt>i</tt> for which the
expression <tt>++i</tt> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
24.2.2 [iterator.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r</tt></td>
<td><tt>reference</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is dereferenceable.</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
24.2.3 [input.iterators], as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*a</tt> and <tt>++r</tt>, and 
to specify the semantics of the remaining ones. This approach seems to be in agreement with the 
original <a href="http://www.sgi.com/tech/stl/InputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>a != b</tt></td>
<td>contextually<br/>
convertible to <tt>bool</tt></td>
<td><tt>!(a == b)</tt></td>
<td><del>pre: <tt>(a, b)</tt> is in the domain<br/>
of <tt>==</tt>.</del>
</td>
</tr>

<tr>
<td><tt>*a</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.<br/>
The expression<br/>
<tt>(void)*a, *a</tt> is equivalent<br/>
to <tt>*a</tt>.<br/>
If <tt>a == b</tt> and <tt>(a,b)</tt> is in<br/>
the domain of <tt>==</tt> then <tt>*a</tt> is<br/>
equivalent to <tt>*b</tt>.
</td>
</tr>

<tr>
<td><tt>a-&gt;m</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>(*a).m</tt></td>
<td><del>pre: <tt>a</tt> is dereferenceable.</del></td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <tt>r</tt> is dereferenceable or<br/>
<tt>r</tt> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <tt>r</tt> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>(void)r++</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins><tt>(void)++r</tt></ins></td>
<td><del>equivalent to <tt>(void)++r</tt></del></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</tt></td>
<td><tt>&nbsp;</tt></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
24.2.4 [output.iterators], as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*r = o</tt> and <tt>++r</tt>,
and to specify the semantics of the remaining ones. This approach seems to be in agreement with
the original <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r = o</tt></td>
<td>result is not used</td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is incrementable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins><br/>
<tt>&amp;r == &amp;++r</tt>.<br/>
<del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/></del>
<ins><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
incrementable and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is <ins>dereferenceable<br/>
or <tt>r</tt> is past-the-end</ins><del>incrementable</del>.<br/>
</td>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>*r++ = o</tt></td>
<td>result is not used</td>
<td><ins><tt>{ *r = o; ++r; }</tt></ins></td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
24.2.5 [forward.iterators], as indicated [<i>Rationale</i>: Since the return type of the
expression <tt>*r++</tt> is now guaranteed to be type <tt>reference</tt>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
24.2.6 [bidirectional.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>--r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: there exists <tt>s</tt> such that<br/>
<tt>r == ++s</tt>.<br/>
post: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<tt>--(++r) == r</tt>.<br/>
<tt>--r == --s</tt> implies <tt>r == s</tt>.<br/>
<tt>&amp;r == &amp;--r</tt>.
</td>
</tr>

<tr>
<td><tt>r--</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r--</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2038" href="#2038">2038.</a> Missing definition for <tt>incrementable</tt> iterator</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 17.6.3.2 [swappable.requirements] there is a mention of "dereferenceable object"; in 
17.6.3.5 [allocator.requirements] the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 20.10.3.2 [pointer.traits.functions] refers to a 
"dereferenceable pointer"; in 22.4.5.1.2 [locale.time.get.virtuals]&#47;11 (<tt>do_get</tt>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="lwg-active.html#2035">2035</a> solves this
issue as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Agree with Daniel, this will be handled by the resolution of <a href="lwg-active.html#2035">2035</a>.
</p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2070" href="#2070">2070.</a> <tt>allocate_shared</tt> should use <tt>allocator_traits&lt;A&gt;::construct</tt></h3>
<p><b>Section:</b> 20.11.2.2.6 [util.smartptr.shared.create] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-07-11 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.create">active issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.2.2.6 [util.smartptr.shared.create] says:
</p>
<blockquote><p>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in that memory
via the placement new expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template
<tt>allocate_shared</tt> uses a copy of a to allocate memory. If an exception is thrown, the functions have
no effect.
</p></blockquote>
<p>
This explicitly requires placement new rather than using
<tt>allocator_traits&lt;A&gt;::construct(a, (T*)pv, std::forward&lt;Args&gt;(args)...)</tt>
In most cases that would result in the same placement new expression,
but would allow more control over how the object is constructed e.g.
using <tt>scoped_allocator_adaptor</tt> to do uses-allocator construction, or
using an allocator declared as a friend to construct objects with no
public constructors.
</p>

<p><i>[2011-08-16 Bloomington:]</i></p>

<p>
Agreed to fix in principle, but believe that <tt>make_shared</tt> and
<tt>allocate_shared</tt> have now diverged enough that their descriptions
should be separated.  Pablo and Stefanus to provide revised wording.
</p>

<p><strong>Daniel's (old) proposed resolution:</strong></p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 20.11.2.2.6 [util.smartptr.shared.create] as indicated (The suggested
removal of the last sentence of p1 is not strictly required to resolve this issue, but is still recommended,
because it does not say anything new but may give the impression that it says something new):
</p><blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre><blockquote>
<p>
-1- <i>Requires</i>: <ins>For the template <tt>make_shared</tt>, t</ins><del>T</del>he expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <ins>For the template <tt>allocate_shared</tt>, the expression 
<tt>allocator_traits&lt;A&gt;::construct(a, pt, std::forward&lt;Args&gt;(args)...)</tt>,
where <tt>pt</tt> has type <tt>T*</tt> and points to storage suitable to hold an object
of type <tt>T</tt>, shall be well formed.</ins> <tt>A</tt> shall be an allocator ([allocator.requirements]). 
<del>The copy constructor and destructor of  <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in 
that memory<ins>. The template <tt>make_shared</tt> constructs the object</ins> via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory<ins> and constructs the object by calling <tt>allocator_traits&lt;A&gt;::construct(a, pt,
std::forward&lt;Args&gt;(args)...)</tt></ins>. If an exception is thrown, the functions have no effect.
<p/>
-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.
<p/>
-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-5- <i>Throws</i>: <tt>bad_alloc</tt>, or<ins>, for the template <tt>make_shared</tt>, an exception thrown from
the constructor of <tt>T</tt>, or, for the template <tt>allocate_shared</tt>,</ins> an exception thrown from 
<tt>A::allocate</tt> or <ins>from <tt>allocator_traits&lt;A&gt;::construct</tt></ins><del>from the constructor of 
<tt>T</tt></del>.
<p/>
-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [ <i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i> ]
<p/>
-7- [ <i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i> ]
</p>
</blockquote></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2011-12-04: Jonathan and Daniel improve wording]</i></p>


<p>See also c++std-lib-31796</p>




<p><i>[2013-10-13, Ville]</i></p>

<p>
This issue is related to <a href="lwg-active.html#2089">2089</a>.
</p>


<p><i>[2014-02-15 post-Issaquah session : move to Tentatively NAD]</i></p>

<p>STL: This takes an allocator, but then ignores its construct. That's squirrely.</p>
<p>Alisdair: The convention is when you take an allocator, you use its construct.</p>
<p>STL: 23.2.1 [container.requirements.general]/3, argh! This fills me with despair, but I understand it now.</p>
<p>STL: Ok, this is some cleanup.</p>
<p>STL: You're requiring <tt>b</tt> to be of type <tt>A</tt> and not being rebound, is that an overspecification?</p>
<p>Pablo: Good point. Hmm, that's only a requirement on what must be well-formed.</p>
<p>STL: If it's just a well-formed requirement, then why not just use a directly?</p>
<p>Pablo: Yeah, the well-formed requirement is overly complex. It's not a real call, we could just use a directly. It makes it harder to read.</p>
<p>Alisdair: <tt>b</tt> should be an allocator in the same family as <tt>a</tt>.</p>
<p>Pablo: This is a well-formed requirement, I wonder if it's the capital A that's the problem here. It doesn't matter here, this is way too much wording.</p>
<p>Alisdair: It's trying to tie the constructor arguments into the allocator requirements.</p>
<p>Pablo: <tt>b</tt> could be struck, that's a runtime quality. The construct will work with anything that's in the family of <tt>A</tt>.</p>
<p>Alisdair: The important part is the <tt>forward</tt> of <tt>Args</tt>.</p>
<p>Pablo: <tt>A</tt> must be an allocator, and <tt>forward</tt> <tt>Args</tt> must work with that.</p>
<p>Alisdair: First let's nail down <tt>A</tt>.</p>
<p>Pablo: Then replace <tt>b</tt> with <tt>a</tt>, and strike the rest.</p>
<p>STL: You need <tt>pt</tt>'s type, at least.</p>
<p>Pablo: There's nothing to be said about runtime constraints here, this function doesn't even take a <tt>pt</tt>.</p>
<p>STL: Looking at the Effects, I believe <tt>b</tt> is similarly messed up, we can use <tt>a2</tt> to construct an object.</p>
<p>Alisdair: Or any allocator in the family of <tt>a</tt>.</p>
<p>STL: We say this stuff for the deallocate too, it should be lifted up.</p>
<p>STL: "owns the address" is weird.</p>
<p>Alisdair: shared_ptr owns pointers, although it does sound funky.</p>
<p>Walter: "to destruct" is ungrammatical.</p>
<p>STL: "When ownership is given up" is not what we usually say.</p>
<p>Alisdair: I think the Returns clause is the right place to say this.</p>
<p>STL: The right place to say this is <tt>shared_ptr</tt>'s dtor, we don't want to use Core's "come from" convention.</p>
<p>Alisdair: I'm on the hook to draft cleaner wording.</p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>
AM: I was going to clean up the wording, but haven't done it yet.<br/>
Defer until we have new wording.<br/>
</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>
Alisdair: we need to figure out whether we should call construct or not; major implementation divergence<br/>
STL: this does not grant friendship, does it?<br/>
Jonathan: some people want it.<br/>
Thomas: scoped allocator adapter should be supported, so placement new doesn't work<br/>
Alisdair: this makes the make_ functions impossible<br/>
Thomas: you don't want to use those though.<br/>
Alisdair: but people use that today, at Bloomberg<br/>
Alisdair: and what do we do about fancy pointers?<br/>
Jonathan: we constrain it to only non-fancy pointers.<br/>
STL: shared_ptr has never attempted to support fancy pointers; seems like a paper is needed.<br/>
Poll: call construct:6 operator new: 0 don't care: 4<br/>
Poll: should we support fancy pointers? Yes: 1 No: 4 don't care: 4<br/>
STL: 20.8.2.2.6p2: 'and pv->~T()' is bogus for void<br/>
STL: 20.8.2.2.6p4: is this true even if we're going to allocate a bit more?<br/>
Alisdair: yes<br/>
Alisdair: coming up with new wording<br/>
</p>

<p><i>[2016-08, Chicago Monday PM]</i></p>

<p>Alisdair to provide new wording this week</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 20.11.2.2.6 [util.smartptr.shared.create] as indicated:
</p>
<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
<del>template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);</del>
</pre></blockquote>
<p>
<del>-1- <i>Requires</i>: The expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <tt>A</tt> shall be an allocator (17.6.3.5 [allocator.requirements]). The copy constructor 
and destructor of <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: <ins>Equivalent to</ins>
</p>
<blockquote><pre> 
<ins>return allocate_shared&lt;T&gt;(allocator&lt;T&gt;(), std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<del>Allocates memory suitable for an object of type <tt>T</tt> 
and constructs an object in that memory via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory. If an exception is thrown, the functions have no effect.</del>
<p/>
<ins>-?- <i>Remarks</i>: An implementation may meet the effects (and the implied guarantees) without 
creating the allocator object [<i>Note</i>: That is, user-provided specializations of <tt>std::allocator</tt>
may not be instantiated, the expressions <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt> and 
<tt>pv-&gt;~T()</tt> may be evaluated directly &mdash; <i>end note</i>].</ins>
<p/>
<del>-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.</del>
<p/>
<del>-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt></del>
<p/>
<del>-5- <i>Throws</i>: <tt>bad_alloc</tt>, or an exception thrown from <tt>A::allocate</tt> or from the 
constructor of <tt>T</tt>.</del>
<p/>
<del>-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i>]</del>
<p/>
<del>-7- [<i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow 
for internal bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]</del>
</p>
</li>
<li><p>
Add the following set of <ins>new paragraphs</ins> immediately following the previous paragraph 7 of
20.11.2.2.6 [util.smartptr.shared.create]:
</p>
<blockquote><pre>
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre></blockquote>
<p>
-?- <i>Requires</i>: The expressions 
<tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt> and
<tt>allocator_traits&lt;A&gt;::destroy(b, pt)</tt> shall be well-formed and well-defined, 
where <tt>b</tt> has type <tt>A</tt> and is a copy of <tt>a</tt> and where <tt>pt</tt> 
has type <tt>T*</tt> and points to storage suitable to hold an object of type <tt>T</tt>. 
<tt>A</tt> shall meet the allocator requirements (17.6.3.5 [allocator.requirements]). 
<p/>
-?- <i>Effects</i>: Uses an object <tt>a2</tt> 
of type <tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to allocate memory suitable for an object of type <tt>T</tt>. 
Uses a copy <tt>b</tt> of type <tt>A</tt> from <tt>a</tt> to construct an object of type <tt>T</tt> in 
that memory by calling <tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt>. 
If an exception is thrown, the function has no effect.
<p/>
-?- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>. When ownership is given up, the effects are as follows: Uses a copy <tt>b2</tt> 
of type <tt>A</tt> from <tt>a</tt> to destruct an object of type <tt>T</tt> by calling 
<tt>allocator_traits&lt;A&gt;::destroy(b2, pt2)</tt> where <tt>pt2</tt> has type <tt>T*</tt> 
and refers to the newly constructed object. Then uses an object of type
<tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to deallocate the allocated memory.
<p/>
-?- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-?- <i>Throws</i>: Nothing unless memory allocation or <tt>allocator_traits&lt;A&gt;::construct</tt> 
throws an exception.
<p/>
-?- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory 
allocation. [<i>Note</i>: Such an implementation provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
<p/>
-?- [<i>Note</i>: This function will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2077" href="#2077">2077.</a> Further incomplete constraints for type traits</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The currently agreed on proposed wording for <a href="lwg-defects.html#2015">2015</a> using 
<tt>remove_all_extents&lt;T&gt;::type</tt> instead of the "an array of 
unknown bound" terminology in the precondition should be extended to 
some further entries especially in Table 49, notably the 
<tt>is_*constructible</tt>, <tt>is_*assignable</tt>, and 
<tt>is_*destructible</tt> entries. To prevent ODR violations, incomplete
element types of arrays must be excluded for value-initialization and
destruction for example. Construction and assignment has to be honored, 
when we have array-to-pointer conversions or pointer conversions of
incomplete pointees in effect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
The issue is that in three type traits, we are accidentally saying that in certain
circumstances the type must give a specified answer when given an incomplete type.
(Specifically: an array of unknown bound of incomplete type.)  The issue asserts
that there's an ODR violation, since the trait returns false in that case but might
return a different version when the trait is completed.
</p>
<p>
Howard argues: no, there is no risk of an ODR violation.
<tt>is_constructible&lt;A[]></tt> must return <tt>false</tt> regardless of whether
<tt>A</tt> is complete, so there's no reason to forbid an array of unknown bound of
incomplete types. Same argument applies to <tt>is_assignable</tt>. General agreement
with Howard's reasoning.
</p>
<p>
There may be a real issue for <tt>is_destructible</tt>. None of us are sure what
<tt>is_destructible</tt> is supposed to mean for an array of unknown bound
(regardless of whether its type is complete), and the standard doesn't make it clear.
The middle column doesn't say what it's supposed to do for incomplete types.
</p>
<p>
In at least one implementation, <tt>is_destructible&lt;A[]></tt> does return <tt>true</tt>
if <tt>A</tt> is complete, which would result in ODR violation unless we forbid it for
incomplete types.
</p>
<p>
Move to open. We believe there is no issue for <tt>is_constructible</tt> or
<tt>is_assignable</tt>, but that there is a real issue for <tt>is_destructible</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2088" href="#2088">2088.</a> <tt>std::terminate</tt> problem</h3>
<p><b>Section:</b> 18.8.4 [exception.terminate] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-09-25 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Andrzej Krzemienski reported the following on comp.std.c++:
</p>
<blockquote>
<p>
In N3290, which is to become the official standard, in 18.8.4.4 [terminate],
paragraph 1 reads
</p>
<blockquote><p>
<i>Remarks</i>: Called by the implementation when exception handling must
be abandoned for any of several reasons (15.5.1), in effect immediately after 
evaluating the <em>throw-expression</em> (18.8.3.1). May also be called directly by the 
program.
</p></blockquote>
<p>It is not clear what is "in effect". It was clear in previous drafts where paragraphs 
1 and 2 read:
</p>
<blockquote><p>
Called by the implementation when exception handling must be
abandoned for any of several reasons (15.5.1). May also be called directly
by the program.
<p/>
<i>Effects</i>: Calls the <tt>terminate_handler</tt> function in effect
immediately after evaluating the <em>throw-expression</em> (18.8.3.1), if called by the
implementation, or calls the current <tt>terminate_handler</tt> function,
if called by the program.
</p>
</blockquote>
<p>
It was changed by N3189. The same applies to function unexpected (D. 11.4, paragraph 1).
<p/>
Assuming the previous wording is still intended, the wording can be read
"unless <tt>std::terminate</tt> is called by the program, we will use the handler
that was in effect immediately after evaluating the throw-expression".
<p/>
  This assumes that there is some throw-expression connected to every
  situation that triggers the call to <tt>std::terminate</tt>. But this is not
  the case:
</p>
<ul>
<li>
  In case <tt>std::thread</tt> is assigned to or destroyed while being joinable
  there is no throw-expression involved.
</li>
<li>
  In case <tt>std::unexpected</tt> is called by the program, <tt>std::terminate</tt> is
  triggered by the implementation - no throw-expression involved.
</li>
<li>
  In case a destructor throws during stack unwinding we have two throw-expressions 
  involved.
 </li>
 </ul>
<p>
Which one is referred to?
<p/>
In case <tt>std::nested_exception::rethrow_nested</tt> is called for an object that has 
captured no exception, there is no throw-expression involved directly (and may no throw 
be involved even indirectly).
<p/>
Next, 18.8.4.1 [terminate.handler], paragraph 2 says 
</p>
<blockquote><p>
<i>Required behavior</i>: A <tt>terminate_handler</tt> shall terminate execution
of the program without returning to the caller.
</p></blockquote>
<p>
This seems to allow that the function may exit by throwing an
exception (because word "return" implies a normal return).
<p/>
One could argue that words "terminate execution of the program" are sufficient,
but then why "without returning to the caller" would be mentioned. In
case such handler throws, noexcept specification in function <tt>std::terminate</tt> 
is violated, and <tt>std::terminate</tt> would be called recursively - should 
<tt>std::abort</tt> not be called in case of recursive <tt>std::terminate</tt> 
call? On the other hand some controlled recursion could be useful, like in the 
<a href="http://cplusplus.co.il/2010/03/21/catching-uncaught-exceptions-within-terminate/">following technique</a>.
</p>
</blockquote>

<p>
The here mentioned wording changes by N3189 in regard to 18.8.4.4 [terminate] p1 
were done for a better separation of effects (Effects element) and additional normative 
wording explanations (Remarks element), there was no meaning change intended. Further,
there was already a defect existing in the previous wording, which was not updated when 
further situations where defined, when <tt>std::terminate</tt> where supposed to be 
called by the implementation. 
<p/>
The part
<p/>
"in effect immediately after evaluating the throw-expression"
<p/>
should be removed and the quoted reference to 18.8.4.1 [terminate.handler] 
need to be part of the effects element where it refers to the current <tt>terminate_handler</tt> 
function, so should be moved just after
<p/>
"Effects: Calls the current <tt>terminate_handler</tt> function."
<p/>
It seems ok to allow a termination handler to exit via an exception, but the 
suggested idiom should better be replaced by a more simpler one based on
evaluating the current exception pointer in the terminate handler, e.g.
</p>
<blockquote><pre>
void our_terminate (void) {
  std::exception_ptr p = std::current_exception();
  if (p) {
    ... // OK to rethrow and to determine it's nature
  } else {
    ... // Do something else
  }
}
</pre></blockquote>

<p><i>[2011-12-09: Daniel comments]</i></p>


<p>
A related issue is <a href="lwg-defects.html#2111">2111</a>.
</p>


<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
There is an interaction with Core issues in this area that Jens is already supplying wording
for.  Review this issue again once Jens wording is available.
</p>
<p>
Alisdair to review clause 15.5 (per Jens suggestion) and recommend any changes, then integrate
Jens wording into this issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2089" href="#2089">2089.</a> <tt>std::allocator::construct</tt> should use uniform initialization</h3>
<p><b>Section:</b> 20.10.9.1 [allocator.members] <b>Status:</b> <a href="lwg-active.html#EWG">EWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2011-10-07 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
When the <tt>EmplaceConstructible</tt> (23.2.1 [container.requirements.general]&#47;13) requirement is used 
to initialize an object, direct-initialization occurs. Initializing an aggregate or using a <tt>std::initializer_list</tt> 
constructor with emplace requires naming the initialized type and moving a temporary. This is a result of 
<tt>std::allocator::construct</tt> using direct-initialization, not list-initialization (sometimes called "uniform 
initialization") syntax.
<p/>
Altering <tt>std::allocator&lt;T&gt;::construct</tt> to use list-initialization would, among other things, give 
preference to <tt>std::initializer_list</tt> constructor overloads, breaking valid code in an unintuitive and 
unfixable way &mdash; there would be no way for <tt>emplace_back</tt> to access a constructor preempted by 
<tt>std::initializer_list</tt> without essentially reimplementing <tt>push_back</tt>.
</p>
<blockquote><pre>
std::vector&lt;std::vector&lt;int&gt;&gt; v;
v.emplace_back(3, 4); // v[0] == {4, 4, 4}, not {3, 4} as in list-initialization
</pre></blockquote>
<p>
The proposed compromise is to use SFINAE with <tt>std::is_constructible</tt>, which tests whether direct-initialization 
is well formed. If <tt>is_constructible</tt> is false, then an alternative <tt>std::allocator::construct</tt> overload 
is chosen which uses list-initialization. Since list-initialization always falls back on direct-initialization, the 
user will see diagnostic messages as if list-initialization (uniform-initialization) were always being used, because 
the direct-initialization overload cannot fail.
<p/>
I can see two corner cases that expose gaps in this scheme. One occurs when arguments intended for 
<tt>std::initializer_list</tt> satisfy a constructor, such as trying to emplace-insert a value of <tt>{3, 4}</tt> in 
the above example. The workaround is to explicitly specify the <tt>std::initializer_list</tt> type, as in 
<tt>v.emplace_back(std::initializer_list&lt;int&gt;(3, 4))</tt>. Since this matches the semantics as if 
<tt>std::initializer_list</tt> were deduced, there seems to be no real problem here.
<p/>
The other case is when arguments intended for aggregate initialization satisfy a constructor. Since aggregates cannot 
have user-defined constructors, this requires that the first nonstatic data member of the aggregate be implicitly 
convertible from the aggregate type, and that the initializer list have one element. The workaround is to supply an 
initializer for the second member. It remains impossible to in-place construct an aggregate with only one nonstatic 
data member by conversion from a type convertible to the aggregate's own type. This seems like an acceptably small 
hole.
<p/>
The change is quite small because <tt>EmplaceConstructible</tt> is defined in terms of whatever allocator is specified, 
and there is no need to explicitly mention SFINAE in the normative text.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
There appears to be a real concern with initializing aggregates, that can be performed only
using brace-initialization.  There is little interest in the rest of the issue, given the existence
of 'emplace' methods in C++11.
</p>
<p>
Move to Open, to find an acceptable solution for intializing aggregates.  There is the potential
that EWG may have an interest in this area of language consistency as well.
</p>

<p><i>[2013-10-13, Ville]</i></p>

<p>
This issue is related to <a href="lwg-active.html#2070">2070</a>.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Move to EWG, Ville to write a paper. 
</p>

<p><i>[2015-09, Telecom]</i></p>

<p>
Ville: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a> reviewed in Lenexa. EWG discussion to continue in Kona.<br/>
</p>
<p><i>[08-16 - Chicago]</i></p>

<p>See <a href="http://wg21.link/N4462">N4462</a></p>
<p>The notes in Lenexa say that Marshall & Jonathan volunteered to write a paper on this</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 20.10.9.1 [allocator.members] p12 as indicated:</p>

<blockquote><pre>
template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</pre><blockquote>
<p>
12 <i>Effects</i>: <tt>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</tt> <ins>if <tt>is_constructible&lt;U, Args...&gt;::value</tt> 
is <tt>true</tt>, else <tt>::new((void *)p) U{std::forward&lt;Args&gt;(args)...}</tt></ins>
</p>
</blockquote></blockquote>






<hr>
<h3><a name="2095" href="#2095">2095.</a> <tt>promise</tt> and <tt>packaged_task</tt> missing constructors needed for uses-allocator construction</h3>
<p><b>Section:</b> 30.6.5 [futures.promise], 30.6.9 [futures.task] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-01 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This example is ill-formed according to C++11 because <tt>uses_allocator&lt;promise&lt;R&gt;, A&gt;::value</tt> is true, but
<tt>is_constructible&lt;promise&lt;R&gt;, A, promise&lt;R&gt;&amp;&amp;&gt;::value</tt> is false. Similarly for <tt>packaged_task</tt>.
</p>
<blockquote><pre>
#include &lt;future&gt;
#include &lt;memory&gt;
#include &lt;tuple&gt;

using namespace std;

typedef packaged_task&lt;void()&gt; task;
typedef promise&lt;void&gt; prom;
allocator&lt;task&gt; a;

tuple&lt;task, prom&gt; t1{ allocator_arg, a };
tuple&lt;task, prom&gt; t2{ allocator_arg, a, task{}, prom{} };
</pre></blockquote>

<p><i>[2012, Portland]</i></p>

<p>
This is an allocator issue, and should be dealt with directly by LWG.
</p>

<p><i>[2013-03-06]</i></p>


<p>
Jonathan suggests to make the new constructors non-explicit and makes some representational improvements.
</p>


<p><i>[2013-09 Chicago]</i></p>

<p>
Move to deferred.
</p>
<p>
This issue has much in common with similar problems with <tt>std::function</tt> that are being addressed
by the polymorphic allocators proposal currently under evaluation in LEWG.  Defer further discussion on
this topic until the final outcome of that paper and its proposed resolution is known.
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>




<p><b>Proposed resolution:</b></p>
<p><i>[This wording is relative to the FDIS.]</i></p>


<ol>
<li><p>Add to 30.6.5 [futures.promise], class template <tt>promise</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class promise {
  public:
    promise();
    template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a);
    <ins>template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
    promise(promise&amp;&amp; rhs) noexcept;
    promise(const promise&amp; rhs) = delete;
    ~promise();	
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 30.6.5 [futures.promise] as indicated:</p>

<blockquote><pre>
promise(promise&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>promise</tt> object and transfers ownership of 
the shared state of <tt>rhs</tt> (if any) to the newly-constructed object.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>

<li><p>Add to 30.6.9 [futures.task], class template <tt>packaged_task</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class&gt; class packaged_task; // <i>undefined</i>

  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    // construction and destruction
    packaged_task() noexcept;
    <ins>template &lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
    template &lt;class F&gt;
      explicit packaged_task(F&amp;&amp; f);
    template &lt;class F, class Allocator&gt;
      explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
    ~packaged_task();
	
    // no copy
    packaged_task(const packaged_task&amp;) = delete;
    <ins>template&lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, const packaged_task&amp;) = delete;</ins>
    packaged_task&amp; operator=(const packaged_task&amp;) = delete;
    
    // move support
    packaged_task(packaged_task&amp;&amp; rhs) noexcept;
    <ins>template &lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
    packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
    void swap(packaged_task&amp; other) noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 30.6.9.1 [futures.task.members] as indicated:</p>

<blockquote><pre>
packaged_task() noexcept;
<ins>template &lt;class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
</pre><blockquote>
<p>
-1- <i>Effects</i>: constructs a <tt>packaged_task</tt> object with no shared state and no stored task.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>
<p>[&hellip;]</p>
<blockquote><pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>packaged_task</tt> object and transfers ownership of <tt>rhs</tt>'s 
shared state to <tt>*this</tt>, leaving <tt>rhs</tt> with no shared state. Moves the stored task from <tt>rhs</tt> 
to <tt>*this</tt>.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>
</ol>

<blockquote><pre>
</pre><blockquote>
<p>
</p></blockquote></blockquote>






<hr>
<h3><a name="2114" href="#2114">2114.</a> Incorrect "<em>contextually</em> convertible to <tt>bool</tt>" requirements</h3>
<p><b>Section:</b> 17.6.3.3 [nullablepointer.requirements], 24.2.3 [input.iterators], 24.2.7 [random.access.iterators], 25.1 [algorithms.general], 25.5 [alg.sorting], 30.2.1 [thread.req.paramname] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2016-02-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
As of 17.6.3.1 [utility.arg.requirements] Table 17&#47;18, the return types of the expressions
</p>
<blockquote><pre>
a == b
</pre></blockquote>
<p>
or
</p>
<blockquote><pre>
a &lt; b
</pre></blockquote>
<p>
for types satisfying the <tt>EqualityComparable</tt> or <tt>LessThanComparable</tt>
types, respectively, are required to be "convertible to <tt>bool</tt>" which corresponds to
a copy-initialization context. But several newer parts of the library that refer to 
such contexts have lowered the requirements taking  advantage of the new terminology of 
"<em>contextually</em> convertible to <tt>bool</tt>" instead, which corresponds to a 
direct-initialization context (In addition to "normal" direct-initialization constructions, 
operands of logical operations as well as <tt>if</tt> or <tt>switch</tt> conditions also 
belong to this special context).
<p/>
One example for these new requirements are input iterators which satisfy <tt>EqualityComparable</tt> 
but also specify that the expression
</p>
<blockquote><pre>
a != b
</pre></blockquote>
<p>
shall be just "<strong>contextually</strong> convertible to <tt>bool</tt>". The same discrepancy 
exists for requirement set <tt>NullablePointer</tt> in regard to several equality-related expressions.
<p/>
For random access iterators we have
</p>
<blockquote><p>
<tt>a &lt; b</tt>      contextually convertible to <tt>bool</tt>
</p></blockquote>
<p>
as well as for all derived comparison functions, so strictly speaking we could have a random access 
iterator that does not satisfy the <tt>LessThanComparable</tt> requirements, which looks like an
artifact to me.
<p/>
Even if we keep with the existing requirements based on <tt>LessThanComparable</tt> or
<tt>EqualityComparable</tt> we still would have the problem that some current specifications 
are actually  based on the assumption of implicit convertibility instead of "explicit convertibility", e.g. 
20.11.1.5 [unique.ptr.special] p3:
</p>
<blockquote><pre>
template &lt;class T1, class D1, class T2, class D2&gt;
bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <tt>x.get() != y.get()</tt>.
</p>
</blockquote></blockquote>
<p>
Similar examples exist in 20.11.1.2.2 [unique.ptr.single.dtor] p2, 20.11.1.2.3 [unique.ptr.single.asgn] p9,
20.11.1.2.4 [unique.ptr.single.observers] p1+3+8, etc.
<p/>
In all these places the expressions involving comparison functions (but <em>not</em> those of the conversion 
of a <tt>NullablePointer</tt> to <tt>bool</tt>!) assume to be "convertible to <tt>bool</tt>". I think this
is a very natural assumption and all delegations of the comparison functions of some type <tt>X</tt> to some
other API type <tt>Y</tt> in third-party code does so assuming that copy-initialization semantics will
just work.
<p/>
The actual reason for using the newer terminology can be rooted back to LWG <a href="lwg-defects.html#556">556</a>. My hypotheses 
is that the resolution of that issue also needs a slight correction. Why so?
<p/>
The reason for opening that issue were worries based on the previous "convertible to <tt>bool</tt>"
wording. An expressions like "<tt>!pred(a, b)</tt>" might not be well-formed in those situations, because
<tt>operator!</tt> might not be accessible or might have an unusual semantics (and similarly for other logical
operations). This can indeed happen with unusual proxy return types, so the idea was that the evaluation of 
<tt>Predicate</tt>, <tt>BinaryPredicate</tt> (25.1 [algorithms.general] p8+9), and <tt>Compare</tt> 
(25.5 [alg.sorting] p2) should be defined based on contextual conversion to <tt>bool</tt>. 
Unfortunately this <em>alone</em> is not sufficient: In addition, I think, we <em>also</em> want the predicates 
to be (implicitly) convertible to <tt>bool</tt>! Without this wording, several conditions are plain wrong, 
e.g. 25.3.5 [alg.find] p2, which talks about "<tt>pred(*i) != false</tt>" (<tt>find_if</tt>) and 
"<tt>pred(*i) == false</tt>" (<tt>find_if_not</tt>). These expressions are not within a boolean context! 
<p/>
While we could simply fix all these places by proper wording to be considered in a "contextual conversion to
<tt>bool</tt>", I think that this is not the correct solution: Many third-party libraries already refer to
the previous C++03 <tt>Predicate</tt> definition &mdash; it actually predates C++98 and is as old as the 
<a href="http://www.sgi.com/tech/stl/Predicate.html">SGI specification</a>. It seems to be a high price to
pay to switch to direct initialization here instead of fixing a completely different specification problem.
<p/>
A final observation is that we have another definition for a <tt>Predicate</tt> in 30.2.1 [thread.req.paramname] p2:
</p>
<blockquote><p>
If a parameter is <tt>Predicate</tt>, <tt>operator()</tt> applied to the actual template argument shall return a value that
is convertible to <tt>bool</tt>.
</p></blockquote>
<p>
The problem here is not that we have two different definitions of <tt>Predicate</tt> in the standard &mdash; this 
is confusing, but this fact alone is not a defect. The first (minor) problem is that this definition does not properly 
apply to function objects that are function pointers, because <tt>operator()</tt> is not defined in a strict sense. 
But the actually worse second problem is that this wording has the very <tt>same</tt> problem that has originally lead to
LWG <a href="lwg-defects.html#556">556</a>! We only need to look at 30.5.1 [thread.condition.condvar] p15 to recognice this:
</p>
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
<p>
The negation expression here looks very familiar to the example provided in LWG <a href="lwg-defects.html#556">556</a> and is sensitive
to the same "unusual proxy" problem. Changing the 30.2.1 [thread.req.paramname] wording to a corresponding
"contextual conversion to <tt>bool</tt>" wouldn't work either, because existing specifications rely on "convertible
to <tt>bool</tt>", e.g. 30.5.1 [thread.condition.condvar] p32+33+42 or 30.5.2 [thread.condition.condvarany] 
p25+26+32+33.
<p/>
To summarize: I believe that LWG <a href="lwg-defects.html#556">556</a> was not completely resolved. A pessimistic interpretation is,
that even with the current wording based on "contextually convertible to <tt>bool</tt>" the actual problem of that 
issue has <em>not</em> been fixed. What actually needs to be required here is some normative wording that basically
expresses something along the lines of:
</p>
<blockquote><p>
The semantics of <em>any</em> contextual conversion to <tt>bool</tt> shall be equivalent to the semantics of 
any implicit conversion to <tt>bool</tt>.
</p></blockquote>
<p>
This is still not complete without having concepts, but it seems to be a better approximation. Another way of solving
this issue would be to define a minimum requirements table with equivalent semantics. The proposed wording is a bit
simpler but attempts to express the same thing.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Agree with Daniel that we potentially broke some C++03 user code, accept the changes striking
"contextually" from tables.  Stefan to provide revised wording for section 25, and figure out
changes to section 30.
</p>
<p>
Move to open, and then to Review when updated wording from Stefan is available.
</p>

<p><i>[2012-10-12, STL comments]</i></p>


<ol>
<li>
<p>
The current proposed resolution still isn't completely satisfying. It would certainly be possible for the Standard to 
require these various expressions to be implicitly and contextually convertible to <tt>bool</tt>, but that would have 
a subtle consequence (which, I will argue, is undesirable - regardless of the fact that it dates all the way back to 
C++98/03). It would allow users to provide really wacky types to the Standard Library, with one of two effects:
</p>
<ol style="list-style-type:upper-alpha">
<li>
<p>Standard Library implementations would have to go to great lengths to respect such wacky types, essentially using 
<tt>static_cast&lt;bool&gt;</tt> when invoking any predicates or comparators.
</p>
</li>

<li>
<p>
Otherwise, such wacky types would be de facto nonportable, because they would make Standard Library implementations 
explode.
</p>
</li>
</ol>

<p>
Effect B is the status quo we're living with today. What Standard Library implementations want to do with <tt>pred(args)</tt> 
goes beyond "<tt>if (pred(args))</tt>" (C++03), contextually converting <tt>pred(args)</tt> to <tt>bool</tt> (C++11), or 
implicitly and contextually converting <tt>pred(args)</tt> to <tt>bool</tt> (the current proposed resolution). 
Implementations want to say things like:
</p>

<blockquote><pre>
if (pred(args))
if (!pred(args))
if (cond &amp;&amp; pred(args))
if (cond &amp;&amp; !pred(args))
</pre></blockquote>

<p>
These are real examples taken from Dinkumware's implementation. There are others that would be realistic 
("<tt>pred(args) &amp;&amp; cond</tt>", "<tt>cond || pred(args)</tt>", etc.)
<p/>
Although negation was mentioned in this issue's Discussion section, and in LWG <a href="lwg-defects.html#556">556</a>'s, the current proposed 
resolution doesn't fix this problem. Requiring <tt>pred(args)</tt> to be implicitly and contextually convertible to <tt>bool</tt> 
doesn't prevent <tt>operator!()</tt> from being overloaded and returning <tt>std::string</tt> (as a wacky example). More 
ominously, it doesn't prevent <tt>operator&amp;&amp;()</tt> and <tt>operator||()</tt> from being overloaded and destroying 
short-circuiting.
</p>

</li>

<li>
<p>
I would like LWG input before working on Standardese for a new proposed resolution. Here's an outline of what I'd like to 
do:
</p>
<ol style="list-style-type:upper-alpha">
<li>
<p>
Introduce a new "concept" in 17.6.3 [utility.requirements], which I would call <tt>BooleanTestable</tt> in the 
absence of better ideas.
</p>
</li>

<li>
<p>
Centralize things and reduce verbosity by having everything simply refer to <tt>BooleanTestable</tt> when necessary. 
I believe that the tables could say "Return type: <tt>BooleanTestable</tt>", while Predicate/BinaryPredicate/Compare 
would need the incantation "shall satisfy the requirements of BooleanTestable".
</p>
</li>

<li>
<p>
Resolve the tug-of-war between users (who occasionally want to do weird things) and implementers (who don't want to have 
to contort their code) by requiring that:
</p>
<ol style="list-style-type:upper-roman">
<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>x</tt> is both implicitly and contextually convertible to <tt>bool</tt>.
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>!x</tt> is <tt>BooleanTestable</tt>. (This is intentionally "recursive".)
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>bool t = x, t2(x), f = !x;</tt> has the postcondition <tt>t == t2 &amp;&amp; t != f</tt>.
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt> and a <tt>BooleanTestable y</tt> of possibly different types, "<tt>x &amp;&amp; y</tt>" 
and "<tt>x || y</tt>" invoke the built-in <tt>operator&amp;&amp;()</tt> and <tt>operator||()</tt>, triggering short-circuiting.
</p>
</li>

<li>
<p>
<tt>bool</tt> is <tt>BooleanTestable</tt>.
</p>
</li>
</ol>

</li>

</ol>

<p>
 I believe that this simultaneously gives users great latitude to use types other than <tt>bool</tt>, while allowing 
 implementers to write reasonable code in order to get their jobs done. (If I'm forgetting anything that implementers 
 would want to say, please let me know.)
</p>

</li>

<li>
<p>
About requirement (I): As Daniel patiently explained to me, we need to talk about both implicit conversions and 
contextual conversions, because it's possible for a devious type to have both "<tt>explicit operator bool()</tt>" 
and "<tt>operator int()</tt>", which might behave differently (or be deleted, etc.).
</p>
</li>

<li>
<p>
About requirement (IV): This is kind of tricky. What we'd like to say is, "<tt>BooleanTestable</tt> can't ever trigger 
an overloaded logical operator". However, given a perfectly reasonable type <tt>Nice</tt> - perhaps even <tt>bool</tt> itself! - 
other code (perhaps a third-party library) could overload <tt>operator&amp;&amp;(Nice, Evil)</tt>. Therefore, I believe 
that the requirement should be "no first use" - the Standard Library will ask for various <tt>BooleanTestable</tt> types 
from users (for example, the result of "<tt>first != last</tt>" and the result of "<tt>pred(args)</tt>"), and as long 
as they don't trigger overloaded logical operators with each other, everything is awesome.
</p>
</li>


<li>
<p>
About requirement (V): This is possibly redundant, but it's trivial to specify, makes it easier for users to understand 
what they need to do ("oh, I can always achieve this with <tt>bool</tt>"), and provides a "base case" for requirement 
(IV) that may or may not be necessary.  Since <tt>bool</tt> is <tt>BooleanTestable</tt>, overloading 
<tt>operator&amp;&amp;(bool, Other)</tt> (etc.) clearly makes the <tt>Other</tt> type non-<tt>BooleanTestable</tt>.
</p>
</li>
</ol>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<p/>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change Table 25 &mdash; "<tt>NullablePointer</tt> requirements" in 17.6.3.3 [nullablepointer.requirements]
as indicated:</p>

<table border="1">
<caption>Table 25 &mdash; <tt>NullablePointer</tt> requirements</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr> 

<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == b)</tt>
</td>
</tr>

<tr>
<td>
<tt>a == np<br/>
np == a</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>a == P()</tt>
</td>
</tr>

<tr>
<td>
<tt>a != np<br/>
np != a</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == np)</tt>
</td>
</tr>

</table>
 
</li>

<li><p>Change Table 107 &mdash; "Input iterator requirements" in 24.2.3 [input.iterators]
as indicated:</p>

<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == b)</tt>
</td>
<td>
pre: <tt>(a, b)</tt> is in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

</table>
 
</li>

<li><p>Change Table 111 &mdash; "Random access iterator requirements" in 24.2.7 [random.access.iterators]
as indicated:</p>

<table border="1">
<caption>Table 111 &mdash; Random access iterator requirements (in addition to bidirectional iterator)</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>b - a &gt; 0</tt>
</td>
<td>
<tt>&lt;</tt> is a total ordering relation
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>b &lt; a</tt>
</td>
<td>
<tt>&gt;</tt> is a total ordering relation opposite to <tt>&lt;</tt>.
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a &lt; b)</tt>
</td>
<td>
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a &gt; b)</tt>
</td>
<td>
</td>
</tr>

</table>
 
</li>

<li><p>Change 25.1 [algorithms.general] p8+9 as indicated:</p>

<blockquote>
<p>
-8- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object 
(20.14 [function.objects]) that, when applied to the result of dereferencing the corresponding iterator, 
returns a value testable as <tt>true</tt>. In other words, if an algorithm takes <tt>Predicate pred</tt> 
as its argument and first as its iterator argument, it should work correctly in the construct 
<tt>pred(*first)</tt> <ins>implicitly or</ins> contextually converted to <tt>bool</tt> (Clause 4 [conv]). 
The function object <tt>pred</tt> shall not apply any non-constant function through the dereferenced iterator.
<p/>
-9- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function object that when applied
to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
<tt>T</tt> when <tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>. In other words, if an algorithm takes
<tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt> as its iterator arguments, it should
work correctly in the construct <tt>binary_pred(*first1, *first2)</tt> <ins>implicitly or</ins> contextually converted to 
<tt>bool</tt> (Clause 4 [conv]).
<tt>BinaryPredicate</tt> always takes the first iterator's <tt>value_type</tt> as its first argument, that is, in those cases
when <tt>T</tt> value is part of the signature, it should work correctly in the construct <tt>binary_pred(*first1, value)</tt> 
<ins>implicitly or</ins> contextually converted to <tt>bool</tt> (Clause 4 [conv]). <tt>binary_pred</tt> shall 
not apply any non-constant function through the dereferenced iterators.
</p>
</blockquote>
</li>

<li><p>Change 25.5 [alg.sorting] p2 as indicated:</p>

<blockquote>
<p>
-2- <tt>Compare</tt> is a function object type (20.14 [function.objects]). The return value of the function 
call operation applied to an object of type <tt>Compare</tt>, when <ins>implicitly or</ins> contextually converted 
to <tt>bool</tt> (4 [conv]), yields <tt>true</tt> if the first argument of the call is less than the second, and 
<tt>false</tt> otherwise. <tt>Compare comp</tt> is used throughout for algorithms assuming an ordering relation. It is assumed 
that <tt>comp</tt> will not apply any non-constant function through the dereferenced iterator.
</p>
</blockquote>
</li>

<li><p>Change 30.2.1 [thread.req.paramname] p2 as indicated:</p>

<blockquote>
<p>
-2- <del>If a parameter is <tt>Predicate</tt>, operator() applied to the actual template argument shall return a value that
is convertible to <tt>bool</tt></del><ins><tt>Predicate</tt> is a function object type (20.14 [function.objects]).
The return value of the function call operation applied to an object of type <tt>Predicate</tt>, when implicitly or 
contextually converted to <tt>bool</tt> (4 [conv]), yields <tt>true</tt> if the corresponding test condition is
satisfied, and <tt>false</tt> otherwise</ins>.
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2014-05-20, Daniel suggests concrete wording based on STL's proposal]</i></p>

<p>
The presented wording follows relatively closely STL's outline with the following notable exceptions:
</p>
<ol style="list-style-type:upper-alpha">
<li><p>
A reference to <tt>BooleanTestable</tt> in table "Return Type" specifications seemed very unusual to me and
I found no "prior art" for this in the Standard. Instead I decided to follow the usual style to add a symbol
with a specific meaning to a specific paragraph that specifies symbols and their meanings.
</p></li>
<li><p>
STL's requirement IV suggested to directly refer to built-in operators <tt>&amp;&amp;</tt> and <tt>||</tt>. In my
opinion this concrete requirement isn't needed if we simply require that two <tt>BooleanTestable</tt> operands behave 
equivalently to two those operands after conversion to <tt>bool</tt> (each of them).
</p></li>
<li><p>
I couldn't find a good reason to require normatively that type <tt>bool</tt> meets the requirements of <tt>BooleanTestable</tt>: My
assertion is that after having defined them, the result simply falls out of this. But to make this a bit clearer, I added
also a non-normative note to these effects.
</p></li>
</ol>

<p><i>[2014-06-10, STL comments]</i></p>

<p>
In the current wording I would like to see changed the suggested changes described by bullet #6:
</p>
<ol style="list-style-type:upper-alpha">
<li><p>In 23.2.1 [container.requirements.general] p4 undo the suggested change</p></li>
<li><p>Then change the 7 occurrences of "convertible to <tt>bool</tt>" in the denoted tables to "<tt>bool</tt>".</p></li>
</ol>

<p><i>[2015-05-05 Lenexa]</i></p>

<p>STL: Alisdair wanted to do something here, but Daniel gave us updated wording.</p>

<p><i>[2015-07 Telecom]</i></p>
<p>
Alisdair: Should specify we don't break short circuiting.<br/>
Ville: Looks already specified because that's the way it works for bool. <br/>
Geoffrey: Maybe add a note about the short circuiting.<br/>
B2/P2 is somewhat ambiguous. It implies that B has to be both implicitly convertible to bool and contextually convertible to bool.<br/>
We like this, just have nits.<br/>
Status stays Open.<br/>
Marshall to ping Daniel with feedback.<br/>
</p>

<p><i>[2016-02-27, Daniel updates wording]</i></p>

<ol>
<li>
<p>
The revised wording has been updated from N3936 to N4567. 
</p>
</li>
<li>
<p>
To satisfy the Kona 2015 committee comments, the wording in 
[booleantestable.requirements] has been improved to better separate the two different requirements of "can be 
contextually converted to <tt>bool</tt>" and "can be implicitly converted to <tt>bool</tt>. Both are necessary because 
it is possible to define a type that has the latter property but not the former, such as the following one:
</p>
<blockquote><pre>
using Bool = int;

struct OddBoolean 
{
  explicit OddBoolean(bool) = delete;
  OddBoolean(Bool){}
};

OddBoolean b2 = true; // OK
OddBoolean b1(true);  // Error
</pre></blockquote>
</li>
<li>
<p>
In [booleantestable.requirements] a note has been added to ensure that an implementation is not allowed to 
break any short-circuiting semantics.
</p>
</li>
<li>
<p>
I decided to separate LWG <a href="lwg-active.html#2587">2587</a>/<a href="lwg-active.html#2588">2588</a> from this issue. Both these issues aren't exactly the
same but depending on the committee's position, their resolution might benefit from the new vocabulary introduced
here.
</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 17.6.3.1 [utility.arg.requirements] p1, Table 17 &mdash; "EqualityComparable requirements", and
Table 18 &mdash; "LessThanComparable requirements" as indicated:</p>

<blockquote>
<p>
-1- [&hellip;] In these tables, <tt>T</tt> is an object or reference type to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are values of type (possibly <tt>const</tt>) <tt>T</tt>; 
<tt>s</tt> and <tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> denotes an identifier; <tt>rv</tt> 
is an rvalue of type <tt>T</tt>; <del>and</del> <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>) <tt>T</tt> or an
rvalue of type <tt>const T</tt><ins>; and <tt>BT</tt> denotes a type that meets the <tt>BooleanTestable</tt> 
requirements ([booleantestable.requirements])</ins>.
<p/>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 17 &mdash; <tt>EqualityComparable</tt> requirements [equalitycomparable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
<tt>==</tt> is an equivalence relation, that is, it has the
following properties: [&hellip;]
</td>
</tr>

</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 18 &mdash; <tt>LessThanComparable</tt> requirements [lessthancomparable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
<tt>&lt;</tt> is a strict weak ordering relation (25.5 [alg.sorting])
</td>
</tr>

</table>
</blockquote>

</blockquote>

</li>

<li><p>Between 17.6.3.2 [swappable.requirements] and 17.6.3.3 [nullablepointer.requirements] insert a new sub-clause 
as indicated:</p>

<blockquote>
?.?.?.? <b><tt>BooleanTestable</tt> requirements [booleantestable.requirements]</b>  
<blockquote>
<p>
-?- A <tt>BooleanTestable</tt> type is a boolean-like type that also supports conversions to <tt>bool</tt>.
A type <tt>B</tt> meets the <tt>BooleanTestable</tt> requirements if the expressions described in Table ?? are valid 
and have the indicated semantics, and if <tt>B</tt> also satisfies all the other requirements of this sub-clause 
[booleantestable.requirements].
<p/>
An object <tt>b</tt> of type <tt>B</tt> can be implicitly converted to <tt>bool</tt> and in addition can be 
contextually converted to <tt>bool</tt> (Clause 4). The result values of both kinds of conversions shall be equivalent. 
<p/>
[<i>Example</i>: The types <tt>bool</tt>, <tt>std::true_type</tt>, and <tt>std::bitset&lt;&gt;::reference</tt> are 
<tt>BooleanTestable</tt> types. &mdash; <i>end example</i>]
<p/>
For the purpose of Table ??, let <tt>B2</tt> and <tt>Bn</tt> denote types (possibly both equal to <tt>B</tt> or to each other) 
that meet the <tt>BooleanTestable</tt> requirements, let <tt>b1</tt> denote a (possibly <tt>const</tt>) value of <tt>B</tt>, 
let <tt>b2</tt> denote a (possibly <tt>const</tt>) value of <tt>B2</tt>, and let <tt>t1</tt> denote a value of type 
<tt>bool</tt>.
<p/>
[<i>Note</i>: These rules ensure what an implementation can rely on but doesn't grant it
license to break short-circuiting behavior of a <tt>BooleanTestable</tt> type. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Somewhere within the new sub-clause [booleantestable.requirements] insert the following new Table (?? denotes
the assigned table number):</p>

<blockquote>
<table border="1">
<caption>Table ?? &mdash; <tt>BooleanTestable</tt> requirements [booleantestable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational semantics</th>
</tr>

<tr>
<td>
<tt>bool(b1)</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<i>Remarks</i>: <tt>bool(b1) == t1</tt> for every value<br/>
<tt>b1</tt> implicitly converted to <tt>t1</tt>.
</td>
</tr>

<tr>
<td>
<tt>!b1</tt>
</td>
<td>
<tt>Bn</tt>
</td>
<td>
<i>Remarks</i>: <tt>bool(b1) == !bool(!b1)</tt> for<br/>
every value <tt>b1</tt>.
</td>
</tr>

<tr>
<td>
<tt>b1 &amp;&amp; b2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<tt>bool(b1) &amp;&amp; bool(b2)</tt>
</td>
</tr>

<tr>
<td>
<tt>b1 || b2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<tt>bool(b1) || bool(b2)</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 17.6.3.3 [nullablepointer.requirements] p5 and Table 25 &mdash; "NullablePointer requirements" as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-5- In Table 25, <tt>u</tt> denotes an identifier, <tt>t</tt> denotes a non-<tt>const</tt> lvalue of type <tt>P</tt>, <tt>a</tt> 
and <tt>b</tt> denote values of type (possibly <tt>const</tt>) <tt>P</tt>, <del>and</del> <tt>np</tt> denotes a value of type 
(possibly <tt>const</tt>) <tt>std::nullptr_t</tt><ins>, and <tt>BT</tt> denotes a type that meets the <tt>BooleanTestable</tt> 
requirements ([booleantestable.requirements])</ins>.
<p/>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 25 &mdash; <tt>NullablePointer</tt> requirements [nullablepointer]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational semantics</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a == np</tt><br/>
<tt>np == a</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a != np</tt><br/>
<tt>np != a</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.5.2.8 [tuple.rel] as indicated;</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(TTypes)</tt>, 
<tt>get&lt;i&gt;(t) == get&lt;i&gt;(u)</tt> is a valid expression returning a type that <del>is convertible to 
<tt>bool</tt></del><ins>meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>. 
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(TTypes)</tt>, 
<tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> and <tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt> are valid 
expressions returning types that <del>are convertible to 
<tt>bool</tt></del><ins>meet the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>. 
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.2.1 [container.requirements.general], Table 95 &mdash; "Container requirements", and
Table 97 &mdash; "Optional container operations" as indicated:</p>

<blockquote>
<p>
-4- In Tables 95, 96, and 97 <tt>X</tt> denotes a container class containing objects of type <tt>T</tt>, <tt>a</tt> and 
<tt>b</tt> denote values of type <tt>X</tt>, <tt>u</tt> denotes an identifier, <tt>r</tt> denotes a non-<tt>const</tt> value 
of type <tt>X</tt>, <del>and</del> <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of type <tt>X</tt><ins>, and <tt>BT</tt> 
denotes a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>.
</p>
<blockquote>
<table border="1">
<caption>Table 95 &mdash; Container requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.empty()</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 97 &mdash; Optional container requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.2.1 [iterator.requirements.general], Table 106 &mdash; "Input iterator requirements", and
Table 110 &mdash; "Random access iterator requirements" as indicated:</p>

<blockquote>
<p>
-12- In the following sections, <tt>a</tt> and <tt>b</tt> denote values of type <tt>X</tt> or <tt>const X</tt>, 
<tt>difference_type</tt> and <tt>reference</tt> refer to the types <tt>iterator_traits&lt;X&gt;::difference_type</tt> and 
<tt>iterator_traits&lt;X&gt;::reference</tt>, respectively, <tt>n</tt> denotes a value of <tt>difference_type</tt>, <tt>u</tt>, 
<tt>tmp</tt>, and <tt>m</tt> denote identifiers, <tt>r</tt> denotes a value of <tt>X&amp;</tt>, <tt>t</tt> denotes
a value of value type <tt>T</tt>, <tt>o</tt> denotes a value of some type that is writable to the output iterator<ins>, and <tt>BT</tt> 
denotes a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>.
</p>
<blockquote>
<table border="1">
<caption>Table 106 &mdash; Input iterator requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>
</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 110 &mdash; Random access iterator requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 25.1 [algorithms.general] p8+p9 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below also fix
(a) unusual wording forms used ("should work") which are unclear in which sense they are imposing normative requirements and
(b) the problem, that the current wording seems to allow that the predicate may mutate a call argument, if that is not a 
dereferenced iterator.
Upon applying the new wording it became obvious that the both the previous and the new wording has the effect that currently 
algorithms such as <tt>adjacent_find</tt>, <tt>search_n</tt>, <tt>unique</tt>, and <tt>unique_copy</tt> are not correctly 
described (because they have no iterator argument named <tt>first1</tt>), which could give raise to a new library issue. 
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<p>
-8- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object (20.9) that, when applied
to the result of dereferencing the corresponding iterator, returns a value testable as <tt>true</tt>. <del>In other words,
i</del><ins>I</ins>f an algorithm takes <tt>Predicate pred</tt> as its argument and <tt>first</tt> as its iterator argument, 
<del>it should work correctly in the construct <tt>pred(*first)</tt> contextually converted to 
<tt>bool</tt> (Clause 4)</del><ins>the expression <tt>pred(*first)</tt> shall have a type that meets the <tt>BooleanTestable</tt> 
requirements ( [booleantestable.requirements])</ins>. 
The function object <tt>pred</tt> shall not apply any non-constant function through <del>the dereferenced 
iterator</del><ins>its argument</ins>.
<p/>
-9- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function object that when applied
to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
<tt>T</tt> when <tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>. <del>In other words, 
i</del><ins>I</ins>f an algorithm takes <tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and 
<tt>first2</tt> as its iterator arguments, <del>it should work correctly in the construct <tt>binary_pred(*first1, *first2)</tt> 
contextually converted to <tt>bool</tt> (Clause 4)</del><ins>the expression <tt>binary_pred(*first1, *first2)</tt> shall 
have a type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements])</ins>. 
<tt>BinaryPredicate</tt> always takes the first iterator's <tt>value_type</tt> as its first argument, that is, in those cases 
when <tt>T</tt> value is part of the signature, <del>it should work correctly in the construct <tt>binary_pred(*first1, value)</tt> 
contextually converted to <tt>bool</tt> (Clause 4)</del><ins>the expression <tt>binary_pred(*first1, value)</tt> shall have a 
type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements])</ins>. <tt>binary_pred</tt> 
shall not apply any non-constant function through <del>the dereferenced iterators</del><ins>any of its arguments</ins>.
</p>
</blockquote>
</li>

<li><p>Change 25.5 [alg.sorting] p2 as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-2- <tt>Compare</tt> is a function object type (20.9). <del>The return value of the function call 
operation applied to an object of type <tt>Compare</tt>, when contextually converted 
to <tt>bool</tt>(Clause 4), yields <tt>true</tt> if the first argument of the call is less than the second, 
and <tt>false</tt> otherwise.</del> <tt>Compare comp</tt> is used throughout for algorithms assuming an ordering relation. 
<ins>Let <tt>a</tt> and <tt>b</tt> denote two argument values whose types depend on the corresponding algorithm. Then the expression 
<tt>comp(a, b)</tt> shall have a type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements]).
The return value of <tt>comp(a, b)</tt>, converted to <tt>bool</tt>, yields <tt>true</tt> if the 
first argument <tt>a</tt> is less than the second argument <tt>b</tt>, and <tt>false</tt> otherwise.</ins> It is assumed that 
<tt>comp</tt> will not apply any non-constant function through <del>the dereferenced iterator</del><ins>any of its arguments</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</li>

<li><p>Change 27.5.4.2 [fpos.operations] and Table 126 &mdash; "Position type requirements" as indicated:</p>

<blockquote>
<p>
-1- Operations specified in Table 126 are permitted. In that table,
</p>
<ul>
<li><p><tt>P</tt> refers to an instance of <tt>fpos</tt>,</p></li>
<li><p>[&hellip;]</p></li>
<li><p><tt>o</tt> refers to a value of type <tt>streamoff</tt>,</p></li>
<li><p><ins><tt>BT</tt> refers to a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements]),</ins></p></li>
<li><p>[&hellip;]</p></li>
</ul>
<blockquote>
<table border="1">
<caption>Table 126 &mdash; Position type requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>p == q</tt>
</td>
<td>
<del>convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>p != q</tt>
</td>
<td>
<del>convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
<blockquote>
</blockquote>
</li>

<li><p>Change 30.2.1 [thread.req.paramname] p1 as indicated:</p>

<blockquote>
<p>
-1- Throughout this Clause, the names of template parameters are used to express type requirements. <del>If a template
parameter is named <tt>Predicate</tt>, <tt>operator()</tt> applied to the template argument shall return a value that
is convertible to <tt>bool</tt></del><ins><tt>Predicate</tt> is a function object type (20.14 [function.objects]).
Let <tt>pred</tt> denote an lvalue of type <tt>Predicate</tt>. Then the expression <tt>pred()</tt> shall have a type that meets the 
<tt>BooleanTestable</tt> requirements ( [booleantestable.requirements]). The return value of <tt>pred()</tt>, 
converted to <tt>bool</tt>, yields <tt>true</tt> if the corresponding test condition is satisfied, and <tt>false</tt> otherwise</ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2115" href="#2115">2115.</a> Undefined behaviour for <tt>valarray</tt> assignments with <tt>mask_array</tt> index?</h3>
<p><b>Section:</b> 26.7.8 [template.mask.array] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2011-12-10 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Recently I received a Service Request (SR) alleging that one of our testcases causes an 
undefined behavior. The complaint is that 26.7.8 [template.mask.array] in C++11 
(and the corresponding subclause in C++03) are interpreted by some people to require that 
in an assignment "<tt>a[mask] = b</tt>", the subscript <tt>mask</tt> and the rhs <tt>b</tt> 
must have the same number of elements.
<p/>
IMHO, if that is the intended requirement, it should be stated explicitly.
<p/>
In any event, there is a tiny editorial cleanup that could be made:
<p/>
In C++11, 26.7.8.1 [template.mask.array.overview] para 2 mentions
</p>
<blockquote><p>
"the expression <tt>a[mask] = b;</tt>"
</p></blockquote>
<p>
but the semicolon cannot be part of an expression. The correction could omit the 
semicolon, or change the word "expression" to "assignment" or "statement".
<p/>
Here is the text of the SR, slightly modified for publication:
</p>
<blockquote>
<p>
Subject:  SR01174 LVS _26322Y31 has undefined behavior [open]
<p/>
[Client:]<br/>
The test case t263.dir&#47;_26322Y31.cpp seems to be illegal as it has an undefined 
behaviour. I searched into the SRs but found SRs were not related to the topic 
explained in this mail (SR00324, SR00595, SR00838).
</p>
<blockquote><pre>
const char vl[] = {"abcdefghijklmnopqrstuvwxyz"};
const char vu[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
const std::valarray&lt;char&gt; v0(vl, 27), vm5(vu, 5), vm6(vu, 6);
std::valarray&lt;char&gt; x = v0;
[&hellip;]
const bool vb[] = {false, false, true, true, false, true};
const std::valarray&lt;bool&gt; vmask(vb, 6);
x = v0;
x[vmask] = vm5;      // ***** HERE....
steq(&amp;x[0], "abABeCghijklmnopqrstuvwxyz");
x2 = x[vmask];       // ***** ....AND HERE
[&hellip;]
</pre></blockquote>
<p>
This problem has already been discussed between [experts]:
See thread <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/threads.html#00051">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;threads.html#00051</a> 
Conclusion <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/msg00099.html">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;msg00099.html</a>
<p/>
[Plum Hall:]<br/>
Before I log this as an SR, I need to check one detail with you.
<p/>
I did read the email thread you mentioned, and I did find a citation (see INCITS ISO&#47;IEC 14882-2003 
Section 26.3.2.6 on valarray computed assignments):
<p/>
Quote: "If the array and the argument array do not have the same length, the behavior is undefined",
<p/>
But this applies to computed assignment (<tt>*=</tt>, <tt>+=</tt>, etc), not to simple assignment. Here is the C++03 citation 
re simple assignment:
<p/>
26.3.2.2 valarray assignment [lib.valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;);
</pre><blockquote>
<p>
1 Each element of the <tt>*this</tt> array is assigned the value of the corresponding element of the argument array.
The resulting behavior is undefined if the length of the argument array is not equal to the length of the
<tt>*this</tt> array.
</p>
</blockquote></blockquote>
<p>
In the new C++11 (N3291), we find ...
<p/>
26.6.2.3 valarray assignment [valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp; v);
</pre><blockquote>
<p>
1 Each element of the <tt>*this</tt> array is assigned the value of the corresponding element of the argument
array. If the length of <tt>v</tt> is not equal to the length of <tt>*this</tt>, resizes <tt>*this</tt> to make 
the two arrays the same length, as if by calling <tt>resize(v.size())</tt>, before performing the assignment.
</p>
</blockquote></blockquote>
<p>
So it looks like the testcase might be valid for C++11 but not for C++03; what do you think?
<p/>
[Client:]<br/>
I quite agree with you but the two problems I mentioned:
</p>
<blockquote><pre>
x[vmask] = vm5;      // ***** HERE....
[&hellip;]
x2 = x[vmask];       // ***** ....AND HERE
</pre></blockquote>
<p>
refer to <tt>mask_array</tt> assignment hence target the C++03 26.3.8 paragraph. Correct?
<p/>
[Plum Hall:]<br/>
I mentioned the contrast between C++03 26.3.2.2 para 1 versus C++11 26.6.2.3 para 1.
<p/>
But in C++03 26.3.8, I don't find any corresponding restriction. Could you quote the specific 
requirement you're writing about?
<p/>
[Client:]<br/>
I do notice the difference between c++03 26.3.2.2 and c++11 26.6.2.3 about assignments between 
different sized <tt>valarray</tt> and I perfectly agree with you.
<p/>
But, as already stated, this is not a simple <tt>valarray</tt> assignment but a
<tt>mask_array</tt> assignment (c++03 26.3.8 &#47; c++11 26.6.8). See c++11 quote below:
<p/>
26.6.8 Class template mask_array<br/>
26.6.8.1 Class template mask_array overview<br/>
[....]
</p>
<ol>
<li><p>This template is a helper template used by the mask subscript operator:
<tt>mask_array&lt;T&gt; valarray&lt;T&gt;::operator[](const valarray&lt;bool&gt;&amp;)</tt>.
</p></li>
<li><p>It has reference semantics to a subset of an array specified by a boolean mask. Thus, 
the expression <tt>a[mask] = b;</tt> has the effect of assigning <em>the elements of <tt>b</tt></em> 
to the masked elements in <tt>a</tt> (those for which the corresponding element in <tt>mask</tt> is true.)
</p></li>
</ol>
<p>
26.6.8.2 mask_array assignment
</p>
<blockquote><pre>
void operator=(const valarray&lt;T&gt;&amp;) const;
const mask_array&amp; operator=(const mask_array&amp;) const;
</pre><blockquote>
<p>
1 These assignment operators have reference semantics, assigning the values of the argument array 
elements to selected elements of the <tt>valarray&lt;T&gt;</tt> object to which it refers.
</p>
</blockquote></blockquote>
<p>
In particular, [one of the WG21 experts] insisted on the piece "the elements of <tt>b</tt>".
<p/>
That is why I reported the test t263.dir&#47;_26322Y31.cpp having an undefined behaviour.
<p/>
[Plum Hall:]<br/>
OK, I can see that I will have to ask WG21; I will file an appropriate issue 
with the Library subgroup. In the meantime, I will mark this testcase as "DISPUTED" 
so that it is not required for conformance testing, until we get a definitive opinion.
</p>
</blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Open.
</p>
<p>
There appears to be a real need for clarification in the standard, and
implementations differ in their current interpretation.  This will need
some research by implementers and a proposed resolution before further
discussion is likely to be fruitful.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2116" href="#2116">2116.</a> <tt>std::swap noexcept(what?)</tt></h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
IMO if we specified <tt>is_[nothrow_]constructible</tt> in terms of a variable
declaration whose validity requires destructibility, it is clearly a bug
in our specification and a failure to realize the actual original
intent. The specification should have been in terms of placement-new.
<p/>
Daniel:<br/>
At the time of the specification this was intended and the solution is
<em>not</em> done by removing the destruction semantics of <tt>is_constructible</tt>.
<p/>
The design of <tt>is_constructible</tt> was also impacted by the previous
<tt>Constructible</tt> concept that <em>explicitly</em> contained destruction semantics,
because during conceptification of the library it turned out to simplify
the constraints  in the library because you did not need to add
<tt>Destructible</tt> all the time. It often was implied but never spoken out
in C++03.
<p/>
Pure construction semantics was considered as useful as well, so <tt>HasConstructor</tt> 
did also exist and would surely be useful as trait as well.
<p/>
Another example that is often overlooked: This also affects wrapper types like <tt>pair</tt>, 
<tt>tuple</tt>, <tt>array</tt> that contain potentially more than one type:
This is easy to understand if you think of <tt>T1</tt> having a deleted destructor
and <tt>T2</tt> having a constructor that may throw: Obviously the compiler has
potentially need to use the <tt>destructor</tt> of <tt>T1</tt> in the <em>constructor</em>
of <tt>std::pair&lt;T1, T2&gt;</tt> to ensure that the core language requirements
are satisfied (All previous fully constructed sub-objects must be destructed).
<p/>
The core language also honors this fact in 12.8 [class.copy] p11:
</p>
<blockquote><p>
A defaulted copy&#47;move constructor for a class <tt>X</tt> is defined as deleted (8.4.3 [dcl.fct.def.delete]) 
if <tt>X</tt> has:<br/>
[&hellip;]<br/>
&mdash; any direct or virtual base class or non-static data member of a type with a destructor that is deleted
or inaccessible from the defaulted constructor,<br/>
[&hellip;]
</p></blockquote>
<p>
Dave:<br/>
This is about <tt>is_nothrow_constructible</tt> in particular. The fact that it is 
foiled by not having a <tt>noexcept</tt> dtor is a defect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
<tt>is_nothrow_constructible</tt> is defined in terms of <tt>is_constructible</tt>, which is defined
by looking at a hypothetical variable and asking whether the variable definition is known not to
throw exceptions. The issue claims that this also examines the type's destructor, given the context,
and thus will return <tt>false</tt> if the destructor can potentially throw. At least one
implementation (Howard's) does return <tt>false</tt> if the constructor is <tt>noexcept(true)</tt>
and the destructor is <tt>noexcept(false)</tt>. So that's not a strained interpretation.
The issue is asking for this to be defined in terms of placement <tt>new</tt>, instead of in terms
of a temporary object, to make it clearer that <tt>is_nothrow_constructible</tt> looks at the
<tt>noexcept</tt> status of only the constructor, and not the destructor.
</p>
<p>
Sketch of what the wording would look like:
</p>
<p>
require <tt>is_constructible</tt>, and then also require that a placement <tt>new</tt> operation
does not throw. (Remembering the title of this issue... What does this imply for <tt>swap</tt>?
</p>
<p>
If we accept this resolution, do we need any changes to <tt>swap</tt>?
</p>
<p> STL argues: no, because you are already forbidden from passing anything with a throwing
desturctor to <tt>swap</tt>.
</p>
<p>
Dietmar argues: no, not true. Maybe statically the destructor can conceivably throw for some
values, but maybe there are some values known not to throw. In that case, it's correct to
pass those values to <tt>swap</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2117" href="#2117">2117.</a> <tt>ios_base</tt> manipulators should have <tt>showgrouping&#47;noshowgrouping</tt></h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals], 27.5.3.1.2 [ios::fmtflags], 27.5.6.1 [fmtflags.manip] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2011-12-15 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Iostreams should include a manipulator to toggle grouping on&#47;off for
locales that support grouped digits. This has come up repeatedly and
been deferred. See LWG <a href="lwg-closed.html#826">826</a> for the previous attempt.
<p/>
If one is using a locale that supports grouped digits, then output
will always include the generated grouping characters. However, very
plausible scenarios exist where one might want to output the number,
un-grouped. This is similar to existing manipulators that toggle
on&#47;off the decimal point, numeric base, or positive sign.
<p/>
See some user commentary <a href="http://www.tablix.org/~avian/blog/archives/2008/01/c_streams_suck/">here</a>.
</p>


<p><i>[21012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
This is a feature request.
</p>
<p>
Walter is slightly uncomfortable with processing feature requests through the issues lists.
</p>
<p>
Alisdair says this is far from the first feature request that has come in from the issues list.
</p>
<p>
STL: The fact that you can turn off grouping on hex output is compelling.
</p>
<p>
Marshall: if we add this flag, we'll need to update tables 87-91 as well.
</p>
<p>
STL: If it has been implemented somewhere, and it works, we'd be glad to add it.
</p>
<p>
Howard: We need to say what the default is.
</p>
<p>
Alisdair sumarizes:
</p>
<p>
(1) We want clear wording that says what the effect is of turning the flag off;
</p>
<p>
(2) what the default values are, and
</p>
<p>
(3) how this fits into tables 87-90. (and 128)
</p>

<p><i>[Issaquah 2014-02-10-12: Move to LEWG]</i></p>

<p>
Since this issue was filed, we have grown a new working group that is better placed to handle feature requests.
</p>
<p>
We will track such issues with an LEWG status until we get feedback from the Library Evolution Working Group.
</p>

<p><i>[Issaquah 2014-02-12: LEWG discussion]</i></p>


<table>
  <caption>Do we think this feature should exist?</caption>
  <tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
  <tr><td>2</td> <td>4</td><td>1</td><td>0</td><td>0</td></tr>
</table>

<p>Think about the ABI break for adding a flag. But this could be
mitigated by putting the data into an iword instead of a flag.</p>

<p>This needs to change Stage 2 in [facet.num.put.virtuals].</p>

<p>Previous resolution, which needs the above corrections:</p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Insert in 22.4.2.2.2 [facet.num.put.virtuals] paragraph 5:</p>

<blockquote><p>
<strong>Stage 1</strong>: The first action of stage 1 is to determine a conversion specifier. The tables that describe
this determination use the following local variables
</p>
<pre>
fmtflags flags = str.flags() ;
fmtflags basefield = (flags &amp; (ios_base::basefield));
fmtflags uppercase = (flags &amp; (ios_base::uppercase));
fmtflags floatfield = (flags &amp; (ios_base::floatfield));
fmtflags showpos = (flags &amp; (ios_base::showpos));
fmtflags showbase = (flags &amp; (ios_base::showbase));
<ins>fmtflags showgrouping = (flags &amp; (ios_base::showgrouping));</ins>
</pre>
</blockquote>
</li>

<li><p>Change header <tt>&lt;ios&gt;</tt> synopsis, 27.5.1 [iostreams.base.overview] as indicated:</p>

<blockquote><pre>
#include &lt;iosfwd&gt;

namespace std {
  [&hellip;]
  <i>// 27.5.6, manipulators:</i>
  [&hellip;]
  ios_base&amp; showpoint     (ios_base&amp; str);
  ios_base&amp; noshowpoint   (ios_base&amp; str);
  <ins>ios_base&amp; showgrouping  (ios_base&amp; str);</ins>
  <ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
  ios_base&amp; showpos       (ios_base&amp; str);
  ios_base&amp; noshowpos     (ios_base&amp; str);
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change class <tt>ios_base</tt> synopsis, 27.5.3 [ios.base] as indicated:</p>

<blockquote><pre>
namespace std {
  class ios_base {
  public:
  class failure;
    <i>// 27.5.3.1.2 fmtflags</i>
    typedef <i>T1</i> fmtflags;
    [&hellip;]
    static constexpr fmtflags showpoint = <i>unspecified</i> ;
    <ins>static constexpr fmtflags showgrouping = <i>unspecified</i> ;</ins>
    static constexpr fmtflags showpos = <i>unspecified</i> ;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Add a new entry to Table 122 &mdash; "<tt>fmtflags</tt> effects" as indicated:</p>

<table border="1">
<caption>Table 122 &mdash; <tt>fmtflags</tt> effects</caption>
<tr align="center">
<th>Element</th>
<th>Effect(s) if set</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>showpoint</tt>
</td>
<td>
generates a decimal-point character unconditionally in generated floatingpoint output
</td>
</tr>

<tr>
<td>
<ins><tt>showgrouping</tt></ins>
</td>
<td>
<ins>generates grouping characters unconditionally in generated output</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

</table>
 
</li>

<li><p>After 27.5.3.1.2 [ios::fmtflags] p12 insert the following:</p>
<blockquote><pre>
<ins>ios_base&amp; showgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <tt>str.setf(ios_base::showgrouping)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>str</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <tt>str.unsetf(ios_base::showgrouping)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>str</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2121" href="#2121">2121.</a> <tt>app</tt> for string streams</h3>
<p><b>Section:</b> 27.8.5.1 [stringstream.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2012-01-15 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This issue was raised while discussing issue <a href="lwg-defects.html#1448">1448</a>.
<p/>
Note the following program:
</p>
<blockquote><pre>
string s("s1: 123456789");
ostringstream s1(s, ios_base::out|ios_base::app);
s1 &lt;&lt; "hello";
cout &lt;&lt; s1.str() &lt;&lt; endl;
</pre></blockquote>
<p>
With g++4.x it prints:
</p>
<blockquote><pre>
s1: 123456789hello
</pre></blockquote>
<p>
With VisualC++10 it prints:
</p>
<blockquote><pre>
hello23456789
</pre></blockquote>
<p>
From my intuitive understanding the flag "app" should result in the output of g++4.x.
I also would read that from 27.5.3.1.4 [ios::openmode] claiming:
</p>
<blockquote><p>
<tt>app</tt>&nbsp;&nbsp;&nbsp;seek to end before each write
</p></blockquote>
<p>
However in issue <a href="lwg-defects.html#1448">1448</a> P.J.Plauger comments:
</p>
<blockquote><p>
I think we should say nothing special about <tt>app</tt> at construction time (thus leaving the write pointer at the beginning of the buffer).
Leave implementers wiggle room to ensure subsequent append writes as they see fit, but don't change existing rules for initial seek
position.
</p></blockquote>
<p>
Note that the flag <tt>ate</tt> on both platforms appends "hello" to <tt>s</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2136" href="#2136">2136.</a> Postconditions vs. exceptions</h3>
<p><b>Section:</b> 17.5.1 [structure] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The front matter in clause 17 should clarify that postconditions will not hold if a 
standard library function exits via an exception. Postconditions or guarantees that 
apply when an exception is thrown (beyond the basic guarantee) are described in an 
"Exception safety" section.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
Consensus that we do not clearly say this, and that we probably should.  A likely
location to describe the guarantees of <i>postconditions</i> could well be a new
sub-clause following 17.6.4.11 [res.on.required] which serves the same purpose
for <i>requires</i> clauses.  However, we need such wording before we can make
progress.
</p>

<p>
Also, see <a href="lwg-active.html#2137">2137</a> for a suggestion that we want to see a paper resolving
both issues together.
</p>

<p><i>[2015-05-06 Lenexa: EirkWF to write paper addressing 2136 and 2137]</i></p>

<p>MC: Idea is to replace all such "If no exception" postconditions with "Exception safety" sections.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2137" href="#2137">2137.</a> Misleadingly constrained post-condition in the presence of exceptions</h3>
<p><b>Section:</b> 28.8.3 [re.regex.assign] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.assign">issues</a> in [re.regex.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The post-conditions of <tt>basic_regex&lt;&gt;::assign</tt> 28.8.3 [re.regex.assign] p16 say:
</p>
<blockquote><p>
<span style="color:#C80000;font-weight:bold">If no exception is thrown,</span> <tt>flags()</tt> returns 
<tt>f</tt> and <tt>mark_count()</tt> returns the number of marked sub-expressions within the expression.
</p></blockquote>
<p>
The default expectation in the library is that post-conditions only hold, if there is no failure 
(see also <a href="lwg-active.html#2136">2136</a>), therefore the initial condition should be removed to prevent any
misunderstanding.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
A favorable resolution clearly depends on a favorable resolution to <a href="lwg-active.html#2136">2136</a>.
There is also a concern that this is just one example of where we would want to apply
such a wording clean-up, and which is really needed to resolve both this issue and
<a href="lwg-active.html#2136">2136</a> is a paper providing the clause 17 wording that gives the guarantee
for <i>postcondition</i> paragaraphs, and then reviews clauses 18-30 to apply that
guarantee consistently.  We do not want to pick up these issues piecemeal, as we risk
openning many issues in an ongoing process.
</p>

<p><i>[2015-05-06 Lenexa: EirkWF to write paper addressing 2136 and 2137]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<blockquote><pre>
template &lt;class string_traits, class A&gt;
  basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
    flag_type f = regex_constants::ECMAScript);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Effects</i>: Assigns the regular expression contained in the string <tt>s</tt>, interpreted according 
the flags specified in <tt>f</tt>. If an exception is thrown, <tt>*this</tt> is unchanged.
<p/>
-16- <i>Postconditions</i>: <del>If no exception is thrown,</del> <tt>flags()</tt> returns <tt>f</tt> and 
<tt>mark_count()</tt> returns the number of marked sub-expressions within the expression.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="2139" href="#2139">2139.</a> What is a <em>user-defined</em> type?</h3>
<p><b>Section:</b> 17.6.4.2.1 [namespace.std], 19.5 [syserr], 20.10.7.1 [allocator.uses.trait], 20.14.10.1 [func.bind.isbind], 20.14.10.2 [func.bind.isplace], 20.14.14 [unord.hash], 20.15.7.6 [meta.trans.other], 22.3.1 [locale], 22.4.1.4 [locale.codecvt], 28.12.1.4 [re.regiter.incr] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lo&iuml;c Joly <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#namespace.std">issues</a> in [namespace.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The expression "user-defined type" is used in several places in the standard, but I'm not sure what 
it means. More specifically, is a type defined in the standard library a user-defined type?
<p/>
From my understanding of English, it is not. From most of the uses of this term in the standard, it 
seem to be considered as user defined. In some places, I'm hesitant, e.g. 17.6.4.2.1 [namespace.std] p1:
</p>
<blockquote><p>
A program may add a template specialization for any standard library template to namespace <tt>std</tt> 
only if the declaration depends on a user-defined type and the specialization meets the standard library 
requirements for the original template and is not explicitly prohibited.
</p></blockquote>
<p>
Does it mean we are allowed to add in the namespace <tt>std</tt> a specialization for 
<tt>std::vector&lt;std::pair&lt;T, U&gt;&gt;</tt>, for instance?
<p/>
Additional remarks from the reflector discussion: The traditional meaning of user-defined types refers
to class types and enum types, but the library actually means here user-defined types that are not
(purely) library-provided. Presumably a new term - like <em>user-provided type</em> - should be introduced
and properly defined.
</p>

<p><i>[
2012-10 Portland: Move to Deferred 
]</i></p>


<p>
The issue is real, in that we never define this term and rely on a "know it when I see it"
intuition.  However, there is a fear that any attempt to pin down a definition is more
likely to introduce bugs than solve them - getting the wording for this precisely correct
is likely far more work than we are able to give it.
</p>

<p>
There is unease at simple closing as NAD, but not real enthusiasm to provide wording either.
Move to Deferred as we are not opposed to some motivated individual coming back with full
wording to review, but do not want to go out of our way to encourage someone to work on this
in preference to other issues.
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-03-05 Jonathan suggests wording]</i></p>

<p>
I dislike the suggestion to change to "user-provided" type because I already find the 
difference between user-declared / user-provided confusing for special member functions, 
so I think it would be better to use a completely different term. The core language
uses "user-defined conversion sequence" and "user-defined literal" and
similar terms for things which the library provides, so I think we
should not refer to "user" at all to distinguish entities defined
outside the implementation from things provided by the implementation.
<p/>
I propose "program-defined type" (and "program-defined specialization"), defined below. 
The P/R below demonstrates the scope of the changes required, even if this name isn't adopted. 
I haven't proposed a change for "User-defined facets" in [locale].
</p>

<p><i>[Lenexa 2015-05-06]</i></p>

<p>RS, HT: The core language uses "user-defined" in a specific way, including library things but excluding core language things, let's use a different term.</p>
<p>MC: Agree.</p>
<p>RS: "which" should be "that", x2</p>
<p>RS: Is std::vector&lt;MyType&gt; a "program-defined type"?</p>
<p>MC: I think it should be.</p>
<p>TK: std::vector&lt;int&gt; seems to take the same path.</p>
<p>JW: std::vector&lt;MyType&gt; isn't program-defined, we don't need it to be, anything that depends on that also depends on =MyType.</p>
<p>TK: The type defined by an "explicit template specialization" should be a program-defined type.</p>
<p>RS: An implicit instantiation of a "program-defined partial specialization" should also be a program-defined type.</p>
<p>JY: This definition formatting is horrible and ugly, can we do better?</p>
<p>RS: Checking ISO directives.</p>
<p>RS: Define "program-defined type" and "program-defined specialization" instead, to get rid of the angle brackets.</p>
<p>JW redrafting.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Add a new sub-clause to 17.3 [definitions]:</p>

<p><ins><b>17.3.? [defns.program.defined]</b></ins></p>
<p>
<ins><b>program-defined</b></ins>
<p/>
<ins>&lt;type&gt; a class type or enumeration type which is not part of the C++
standard library and not defined by the implementation. [<i>Note</i>: Types
defined by the implementation include extensions (1.4 [intro.compliance])
and internal types used by the library. &mdash; <i>end note</i>]</ins>
</p>
<p>
<ins><b>program-defined</b></ins>
<p/>
<ins>&lt;specialization&gt; an explicit template specialization or partial
specialization which is not part of the C++ standard library and not
defined by the implementation.</ins>
</p>
</li>

<li><p>Change 17.6.4.2.1 [namespace.std] paragraph 1+2:</p>

<p>
-1- The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <tt>std</tt> or to a
namespace within namespace <tt>std</tt> unless otherwise specified. A program may add a template specialization
for any standard library template to namespace <tt>std</tt> only if the declaration depends on a 
<del>user</del><ins>program</ins>-defined type and the specialization meets the standard library requirements for the 
original template and is not explicitly prohibited.
<p/>
-2- The behavior of a C++ program is undefined if it declares
<p/>
[&hellip;]
<p/>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a <del>user</del><ins>program</ins>-defined type and the instantiation meets the standard 
library requirements for the original template.
</p>
</li>

<li><p>Change 19.5 [syserr] paragraph 4:</p>

<p>
-4- The <tt>is_error_code_enum</tt> and <tt>is_error_condition_enum</tt> may be specialized for 
<del>user</del><ins>program</ins>-defined types to indicate that such types are eligible for class <tt>error_code</tt> 
and class <tt>error_condition</tt> automatic conversions, respectively.
</p>
</li>

<li><p>Change 20.10.7.1 [allocator.uses.trait] paragraph 1:</p>

<p>
-1- <i>Remarks</i>: automatically detects [&hellip;]. A program may specialize this template to derive from 
<tt>true_type</tt> for a <del>user</del><ins>program</ins>-defined type <tt>T</tt> that does not have a nested 
<tt>allocator_type</tt> but nonetheless can be constructed with an allocator where either: [&hellip;]
</p>
</li>

<li><p>Change 20.14.10.1 [func.bind.isbind] paragraph 2:</p>

<p>
-2- Instantiations of the <tt>is_bind_expression</tt> template [&hellip;]. A program may specialize
this template for a <del>user</del><ins>program</ins>-defined type <tt>T</tt> to have a <tt>BaseCharacteristic</tt> 
of <tt>true_type</tt> to indicate that <tt>T</tt> should be treated as a subexpression in a <tt>bind</tt> call.
</p>
</li>

<li><p>Change 20.14.10.2 [func.bind.isplace] paragraph 2:</p>

<p>
-2- Instantiations of the <tt>is_placeholder</tt> template [&hellip;]. A program may specialize this template for a 
<del>user</del><ins>program</ins>-defined type <tt>T</tt> to have a <tt>BaseCharacteristic</tt> of 
<tt>integral_constant&lt;int, <i>N</i>&gt;</tt> with <tt><i>N</i> &gt; 0</tt> to indicate that <tt>T</tt> should be 
treated as a placeholder type.
</p>
</li>

<li><p>Change 20.14.14 [unord.hash] paragraph 1:</p>

<p>
The unordered associative containers defined in 23.5 use specializations of the class template <tt>hash</tt> [&hellip;], 
the instantiation <tt>hash&lt;Key&gt;</tt> shall:
</p>
<ul>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>satisfy the requirement that the expression <tt>h(k)</tt>, where <tt>h</tt> is an object of type 
<tt>hash&lt;Key&gt;</tt> and <tt>k</tt> is an object of type <tt>Key</tt>, shall not throw an exception unless 
<tt>hash&lt;Key&gt;</tt> is a <del>user</del><ins>program</ins>-defined specialization that depends on at least one 
<del>user</del><ins>program</ins>-defined type.</p></li>
</ul>
</li>

<li><p>Change 20.15.7.5 [meta.trans.ptr] Table 57 (<tt>common_type</tt> row):</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td align="center">
&nbsp;
</td>

<td>
The member typedef <tt>type</tt> shall be<br/>
defined or omitted as specified below.<br/>
[&hellip;]. A program may<br/>
specialize this trait if at least one<br/>
template parameter in the<br/>
specialization is a <del>user</del><ins>program</ins>-defined type.<br/>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 22.4.1.4 [locale.codecvt] paragraph 3:</p>

<p>
-3- The specializations required in Table 81 (22.3.1.1.1) [&hellip;]. Other encodings can be converted 
by specializing on a <del>user</del><ins>program</ins>-defined <tt>stateT</tt> type.[&hellip;]
</p>
</li>

<li><p>Change 28.12.1.4 [re.regiter.incr] paragraph 8:</p>

<p>
-8- [<i>Note</i>: This means that a compiler may call an implementation-specific search function, in which case
a <del>user</del><ins>program</ins>-defined specialization of <tt>regex_search</tt> will not be called. &mdash; 
<i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2146" href="#2146">2146.</a> Are reference types <tt>Copy</tt>&#47;<tt>Move-Constructible</tt>&#47;<tt>Assignable</tt> or <tt>Destructible</tt>?</h3>
<p><b>Section:</b> 17.6.3.1 [utility.arg.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-03-23 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 17.6.3.1 [utility.arg.requirements] p1
</p>
<blockquote><p>
The template definitions in the C++ standard library refer to various named requirements whose details are set out in 
tables 17-24. In these tables, <tt>T</tt> is an object or reference type to be supplied by a C++ program instantiating 
a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are values of type (possibly <tt>const</tt>) <tt>T</tt>; <tt>s</tt> 
and <tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> denotes an identifier; <tt>rv</tt> is an rvalue of 
type <tt>T</tt>; and <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>) <tt>T</tt> or an rvalue of type <tt>const T</tt>.
</p></blockquote>
<p>
Is it really intended that <tt>T</tt> may be a reference type? If so, what should <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, 
<tt>s</tt>, <tt>t</tt>, <tt>u</tt>, <tt>rv</tt>, and <tt>v</tt> mean? For example, are "<tt>int &amp;</tt>" and 
"<tt>int &amp;&amp;</tt>" <tt>MoveConstructible</tt>?
<p/>
As far as I understand, we can explicitly specify template arguments for <tt>std::swap</tt> and <tt>std::for_each</tt>. 
Can we use reference types there?
</p>
<ol>
<li>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main()
{
  int x = 1;
  int y = 2;
  std::swap&lt;<span style="color:#C80000;font-weight:bold">int &amp;&amp;</span>&gt;(x, y); // <em>undefined?</em>
  std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
<li>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;

struct F
{
  void operator()(int n)
  {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
    ++count;
  }
  int count;
} f;

int main()
{
  int arr[] = { 1, 2, 3 };
  auto&amp;&amp; result = std::for_each&lt;int *, <span style="color:#C80000;font-weight:bold">F &amp;&amp;</span>&gt;( // <em>undefined?</em>
    std::begin(arr),
    std::end(arr),
    std::move(f));
  std::cout &lt;&lt; "count: " &lt;&lt; result.count &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
</ol>
<p>
Are these forms of usage well-defined?
<p/>
Let's also consider the following constructor of <tt>std::thread</tt>:
</p>
<blockquote><pre>
template &lt;class F, class ...Args&gt;
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre><blockquote>
<p>
<i>Requires</i>: <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall satisfy the <tt>MoveConstructible</tt> requirements.
</p>
</blockquote></blockquote>
<p>
When the first argument of this constructor is an lvalue (e.g. a name of a global function), template argument for <tt>F</tt> 
is deduced to be lvalue reference type. What should "<tt>MoveConstructible</tt>" mean with regard to an lvalue reference 
type? Maybe the wording should say that <tt>std::decay&lt;F&gt;::type</tt> and each <tt>std::decay&lt;Ti&gt;::type</tt> (where 
<tt>Ti</tt> is an arbitrary item in <tt>Args</tt>) shall satisfy the <tt>MoveConstructible</tt> requirements?
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>Moved to Open.</p>
<p>The questions raised by the issue are real, and should have a clear answer.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: std::thread needs to be fixed, and anything behaving like it needs to be fixed, rather than reference types. std::bind gets this right. We need to survey this. GR: That doesn't sound small to me. STL: Seach for CopyConstructible etc. It may be a long change, but not a hard one.</p>
<p>MC: It seems that we don't have a PR. Does anyone have one? Is anyone interested in doing a survey?</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>Casey volunteers to make a survey</p>

<p><i>[2016-06, Oulu]</i></p>

<p>
During an independent survey performed by Daniel as part of the analysis of LWG <a href="lwg-defects.html#2716">2716</a>,
some overlap was found between these two issues. Daniel suggested to take responsibility for surveying
LWG <a href="lwg-active.html#2146">2146</a> and opined that the P/R of LWG <a href="lwg-defects.html#2716">2716</a> should restrict to forwarding 
references, where the deduction to lvalue references can happen without providing an explicit template
argument just by providing an lvalue function argument.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2151" href="#2151">2151.</a> <tt>basic_string&lt;&gt;::swap</tt> semantics ignore allocators</h3>
<p><b>Section:</b> 21.3.1.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.require">active issues</a> in [string.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++11, <tt>basic_string</tt> is not described as a "container", and is not governed by the allocator-aware 
container semantics described in sub-clause 23.2 [container.requirements]; as a result, and 
requirements or contracts for the <tt>basic_string</tt> interface must be documented in Clause 
21 [strings].
<p/>
Sub-clause 21.3.1.6.8 [string::swap] defines the <tt>swap</tt> member function with no requirements, and
with guarantees to execute in constant time without throwing. Fulfilling such a contract is not reasonable 
in the presence of unequal non-propagating allocators.
<p/>
In contrast, 23.2.1 [container.requirements.general] p7 declares the behavior of member <tt>swap</tt> 
for containers with unequal non-propagating allocators to be undefined.
<p/>
Resolution proposal:
<p/>
Additional language from Clause 23 [containers] should probably be copied to Clause 
21 [strings]. I will refrain from an exactly recommendation, however, as I am raising further
issues related to the language in Clause 23 [containers].
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair has offered to provide wording.
</p>
<p>
Telecon notes that 23.2.1 [container.requirements.general]p13 says that <tt>string</tt> is an
allocator-aware container.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2154" href="#2154">2154.</a> What exactly does compile-time complexity imply?</h3>
<p><b>Section:</b> 26.6.1.3 [rand.req.urng] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> John Salmon <b>Opened:</b> 2012-04-26 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.urng">issues</a> in [rand.req.urng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The expressions <tt>G::min()</tt> and <tt>G::max()</tt> in Table 116 in 26.6.1.3 [rand.req.urng] are specified 
as having "compile-time" complexity.
<p/>
It is not clear what, exactly, this requirement implies.  If a URNG has a method:
</p>
<blockquote><pre>
static int min();
</pre></blockquote>
<p>
then is the method required to have a <tt>constexpr</tt> qualifier?  I believe the standard would benefit from 
clarification of this point.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2155" href="#2155">2155.</a> Macro <tt>__bool_true_false_are_defined</tt> should be removed</h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2012-04-30 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.runtime">active issues</a> in [support.runtime].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Since C99, the C standard describes a macro named  <tt>__bool_true_false_are_defined</tt>.
<p/>
In the process of harmonizing C++11 with C99, this name became part of the C++ standard.
<p/>
I propose that all mention of this name should be removed from the C and C++ standards.
<p/>
Here's the problem: The name was originally proposed as a transition tool, so that the headers for a 
project could contain lines like the following.
</p>
<blockquote><pre>
#if !defined(__bool_true_false_are_defined)
#define bool int /* or whatever */
#define true 1
#define false 0
#endif
</pre></blockquote>
<p>
Then when the project was compiled by a "new" compiler that implemented <tt>bool</tt> as defined by the 
evolving C++98 or C99 standards, those lines would be skipped; but when compiled by an "old" compiler that 
didn't yet provide <tt>bool</tt>, <tt>true</tt>, and <tt>false</tt>, then the <tt>#define</tt>'s would provide a
simulation that worked for most purposes.
<p/>
It turns out that there is an unfortunate ambiguity in the name.  One interpretation is as shown above, but 
a different reading says "bool, true, and false are #define'd", i.e. that the meaning of the macro is to
assert that these names are macros (not built-in) ... which is true in C, but not in C++.
<p/>
In C++11, the name appears in parentheses followed by a stray period, so
some editorial change is needed in any event:
<p/>
18.10 [support.runtime] para 1:
</p>
<blockquote><p>
Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> 
(alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt> (<tt>__bool_true_false_are_defined</tt>). 
<tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> 
(system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p></blockquote>
<p>
However, para 2 says
</p>
<blockquote><p>
"The contents of these headers are the same as the Standard C library headers <tt>&lt;setjmp.h&gt;</tt>, 
<tt>&lt;signal.h&gt;</tt>, <tt>&lt;stdalign.h&gt;</tt>, <tt>&lt;stdarg.h&gt;</tt>, <tt>&lt;stdbool.h&gt;</tt>, 
<tt>&lt;stdlib.h&gt;</tt>, and <tt>&lt;time.h&gt;</tt>, respectively, with the following 
changes:",
</p></blockquote>
<p>
and para 8 says 
</p>
<blockquote><p>
"The header <tt>&lt;cstdbool&gt;</tt> and the header <tt>&lt;stdbool.h&gt;</tt> shall 
not define macros named <tt>bool</tt>, <tt>true</tt>, or <tt>false</tt>."
</p></blockquote>
<p>
Thus para 8 doesn't exempt the C++ implementation from the arguably clear requirement of the C standard, to 
provide a macro named <tt>__bool_true_false_are_defined</tt> defined to be 1.
<p/>
Real implementations of the C++ library differ, so the user cannot count upon any consistency; furthermore, the 
usefulness of the transition tool has faded long ago.
<p/>
That's why my suggestion is that both C and C++ standards should eliminate any mention of 
<tt>__bool_true_false_are_defined</tt>.  In that case, the name belongs to implementers to provide, or not, as 
they choose.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
While not strictly necessary, the clean-up look good.
</p>
<p>
We would like to hear from our C liaison before moving on this issue though.
</p>

<p><i>[2015-05 Lenexa]</i></p>

<p>
LWG agrees. Jonathan provides wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit the footnote on 17.6.1.2 [headers] p7:</p>
<blockquote>
<p>
176) In particular, including <ins>any of</ins> the standard header<ins>s <tt>&lt;stdbool.h&gt;</tt>, <tt>&lt;cstdbool&gt;</tt>,</ins> <tt>&lt;iso646.h&gt;</tt> or <tt>&lt;ciso646&gt;</tt> has no effect.
</p>
</blockquote>
</li>

<li>
<p>Edit 18.10 [support.runtime] p1 as indicated (and remove the index entry for <tt>__bool_true_false_are_defined</tt>):</p>

<blockquote>
<p>
-1- Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> (alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt><ins>,</ins><del> (<tt>__bool_true_false_are_defined</tt>).</del> <tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> (system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p>
</blockquote>
</li>

<li>
<p>Remove Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis [tab:support.hdr.cstdbool] from 18.10 [support.runtime] </p>
<blockquote>
<table border="1">
<caption> Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis </caption>
<tr><td><b>Type</b></td><td><b>Name(s)</b></td></tr>
<tr><td><b>Macro:</b></td><td><tt>__bool_true_false_are_defined</tt></td></tr>
</table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2157" href="#2157">2157.</a> How does <tt>std::array&lt;T,0&gt;</tt> initialization work when <tt>T</tt> is not default-constructible?</h3>
<p><b>Section:</b> 23.3.7.8 [array.zero] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daryle Walker <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#array.zero">issues</a> in [array.zero].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Objects of <tt>std::array&lt;T,N&gt;</tt> are supposed to be initialized with aggregate initialization (when 
not the destination of a copy or move). This clearly works when <tt>N</tt> is positive. What happens when <tt>N</tt> 
is zero?  To continue using an (inner) set of braces for initialization, a <tt>std::array&lt;T,0&gt;</tt> implementation 
must have an array member of at least one element, and let default initialization take care of those secret elements.  
This cannot work when <tt>T</tt> has a set of constructors and the default constructor is deleted from that set.
Solution: Add a new paragraph in 23.3.7.8 [array.zero]:
</p>
<blockquote><p>
The unspecified internal structure of array for this case shall allow initializations like:
</p>
<blockquote><pre>
array&lt;T, 0&gt; a = { };
</pre></blockquote>
<p>
and said initializations must be valid even when <tt>T</tt> is not default-constructible.
</p></blockquote>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
Some discussion to understand the issue, which is that implementations currently have freedom to implement
an empty <tt>array</tt> by holding a dummy element, and so might not support value initialization, which is
surprising when trying to construct an empty container.  However, this is not mandated, it is an unspecified
implementation detail.
</p>

<p>
Jeffrey points out that the implication of 23.3.7.1 [array.overview] is that this initialization syntax
must be supported by empty <tt>array</tt> objects already.  This is a surprising inference that was not
obvious to the room, but consensus is that the reading is accurate, so the proposed resolution is not necessary,
although the increased clarity may be useful.
</p>

<p>
Further observation is that the same clause effectively implies that <tt>T</tt> must always be DefaultConstructible,
regardless of <tt>N</tt> for the same reasons - as an <i>initializer-list</i> may not supply enough values, and the
remaining elements must all be value initialized.
</p>

<p>
Concern that we are dancing angels on the head of pin, and that relying on such subtle implications in wording is
not helpful. We need a clarification of the text in this area, and await wording.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: What was the outcome of Portland? AM: Initially we thought we already had the intended behaviour. 
We concluded that <tt>T</tt> must always be <tt>DefaultConstructible</tt>, but I'm not sure why. GR: It's p2 in 
<tt>std::array</tt>, "up to <tt>N</tt>". AM: That wording already implies that "<tt>{}</tt>" has to work when <tt>N</tt> 
is zero. But the wording of p2 needs to be fixed to make clear that it does <em>not</em> imply that <tt>T</tt> must be 
<tt>DefaultConstructible</tt>.
<p/>
Conclusion: Update wording, revisit later. 
</p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>MC: How important is this? Can you not just use default construction for empty arrays? </p>
<p>TK: It needs to degenerate properly from a pack. STL agrees.</p> 
<p>JW: Yes, this is important, and we have to make it work.</p>
<p>MC: I hate the words "initialization like". </p>
<p>JW: I'll reword this.</p>
<p>WEB: Can I ask that once JW has reworded this we move it to Review rather than Open? </p>
<p>MC: We'll try to review it in a telecon and hopefully get it to tentatively ready.</p>
<p>STL: Double braces must also work: <tt>array&lt;T, 0&gt; a = {{}};</tt>.</p>
<p>Jonathan to reword.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<p>Add the following new paragraph between the current 23.3.7.8 [array.zero] p1 and p2:</p>

<blockquote><p>
-1- <tt>array</tt> shall provide support for the special case <tt>N == 0</tt>.
<p/>
<ins>-?- The unspecified internal structure of <tt>array</tt> for this case shall allow initializations like:</ins>
</p>
<blockquote><pre>
<ins>array&lt;T, 0&gt; a = { };</ins>
</pre></blockquote>
<p>
<ins>and said initializations must be valid even when <tt>T</tt> is not default-constructible.</ins>
<p/>
-2- In the case that <tt>N == 0</tt>, <tt>begin() == end() ==</tt> unique value. The return value of 
<tt>data()</tt> is unspecified.
<p/>
-3- The effect of calling <tt>front()</tt> or <tt>back()</tt> for a zero-sized array is undefined.
<p/>
-4- Member function <tt>swap()</tt> shall have a <em>noexcept-specification</em> which is equivalent to 
<tt>noexcept(true)</tt>.
</p></blockquote>





<hr>
<h3><a name="2158" href="#2158">2158.</a> Conditional copy&#47;move in <tt>std::vector</tt></h3>
<p><b>Section:</b> 23.3.11.3 [vector.capacity] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are various operations on <tt>std::vector</tt> that can cause elements of the vector to be 
moved from one location to another. A move operation can use either rvalue or const lvalue as 
argument; the choice depends on the value of <tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
is_copy_constructible&lt;T&gt;::value</tt>, where <tt>T</tt> is the element type. Thus, some operations 
on <tt>std::vector</tt> (e.g. 'resize' with single parameter, 'reserve', 'emplace_back') should have 
conditional requirements. For example, let's consider the requirement for 'reserve' in N3376 &ndash; 
23.3.11.3 [vector.capacity]&#47;2:
</p>
<blockquote><p>
<i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
</p></blockquote>
<p>
This requirement is not sufficient if an implementation is free to select copy constructor when 
<tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</tt> 
evaluates to true. Unfortunately, <tt>is_copy_constructible</tt> cannot reliably determine whether 
<tt>T</tt> is really copy-constructible. A class may contain public non-deleted copy constructor whose 
definition does not exist or cannot be instantiated successfully (e.g., 
<tt>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</tt> has copy constructor, but this type is not 
copy-constructible). Thus, the actual requirements should be:
</p>
<ul>
<li><p>
if <tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</tt> 
then <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>*this</tt>;
</p></li>
<li><p>
otherwise <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
</p></li>
</ul>
<p>
Maybe it would be useful to introduce a new name for such conditional requirement (in addition to 
"<tt>CopyInsertable</tt>" and "<tt>MoveInsertable</tt>").
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>
The problem does not appear to be as severe as described. The <tt>MoveInsertable</tt>
requirements are consistently correct, but an issue may arise on the
exception-safety guarantees when we check for
<tt>is_copy_constructible_v&lt;T&gt;</tt>.  The problem, as described, is
typically for templates that appear to have a copy constructor, but one that
fails to compile once instantiated, and so gives a misleading result for the
trait.
</p>
<p>
In general, users should not provide such types, and the standard would not
serve users well by trying to address support for such types.  However, the
standard should not be providing such types either, such as
<tt>vector&lt;unique_ptr&lt;T&gt;&gt;</tt>.  A possible resolution would be
to tighten the constraints in Table 80 &mdash; Container Requirements, so that if
the Requirements for the copy constructor/assingment operator of a container
are not satisfied, that operation shall be deleted.
</p>
<p>
A futher problem highlighted by this approach is that there are no constraints on
the copy-assignment operator, so that <tt>vector&lt;unique_ptr&lt;T&gt;&gt;</tt>
should be <tt>CopyAssignable</tt>! However, we can lift the equivalent constraints from
the Allocator-aware container requirements.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<p>
<table border="1">
<caption> 23.2.1 [container.requirements.general] Table 80 &mdash; Container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><tt>X(a)</tt></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into
    <tt>X</tt> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>a == X(a)</tt>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td><tt>X u(a)</tt><br/><tt>X u = a;</tt></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into
    <tt>X</tt> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>u == a</tt>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
</tr>
<tr>
  <td><tt>r = a</tt></td>
  <td><tt>X&amp;</tt></td>
  <td></td>
  <td>
    <ins><i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>
    and <tt>CopyAssignable</tt>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>r == a</tt>.</td>
  <td>linear</td>
</tr>
</table>
</p>

<p>
<table border="1">
<caption> 23.2.1 [container.requirements.general] Table 83 &mdash; Allocator-aware container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><tt>a = t</tt></td>
  <td><tt>X&amp;</tt></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt> and
    <tt>CopyAssignable</tt><del>.</del><ins>, otherwise this  expression shall
    be ill-formed</ins><br/>
    post: <tt>r == a</tt>.</td>
  <td>linear</td>
</tr>
</table>
</p>






<hr>
<h3><a name="2164" href="#2164">2164.</a> What are the semantics of <tt>vector.emplace(vector.begin(), vector.back())</tt>?</h3>
<p><b>Section:</b> 23.3.11.5 [vector.modifiers], 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2012-07-07 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in [vector.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Nikolay Ivchenkov recently brought the following example on the
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/dhy23mDFXj4/discussion">std-discussion</a> 
newsgroup, asking whether the following program well-defined:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt;int&gt; v;
  v.reserve(4);
  v = { 1, 2, 3 };
  v.emplace(v.begin(), v.back());
  for (int x : v)
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
Nikolay Ivchenkov:
<p/>
I think that an implementation of <tt>vector</tt>'s 'emplace' should initialize an intermediate object with 
<tt>v.back()</tt> before any shifts take place, then perform all necessary shifts and finally replace the 
value pointed to by <tt>v.begin()</tt> with the value of the intermediate object. So, I would expect the 
following output:
</p>
<blockquote><pre>
3
1
2
3
</pre></blockquote>
<p>
GNU C++ 4.7.1 and GNU C++ 4.8.0 produce other results:
</p>
<blockquote><pre>
2
1
2
3
</pre></blockquote>
<p>
Howard Hinnant:
<p/>
I believe Nikolay is correct that vector should initialize an intermediate object with <tt>v.back()</tt> 
before any shifts take place. As Nikolay pointed out in another email, this appears to be the only way to 
satisfy the strong exception guarantee when an exception is not thrown by <tt>T</tt>'s copy constructor, 
move constructor, copy assignment operator, or move assignment operator as specified by 
23.3.11.5 [vector.modifiers]/p1. I.e. if the emplace construction throws, the vector must remain unaltered.
<p/>
That leads to an implementation that tolerates objects bound to the function parameter pack of the <tt>emplace</tt> 
member function may be elements or sub-objects of elements of the container.
<p/>
My position is that the standard is correct as written, but needs a clarification in this area. Self-referencing 
<tt>emplace</tt> should be legal and give the result Nikolay expects. The proposed resolution of LWG <a href="lwg-active.html#760">760</a> 
is not correct.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG agrees with the analysis including the assessment of LWG <a href="lwg-active.html#760">760</a> and would appreciate a concrete wording proposal.
</p>

<p><i>[2015-04-07 dyp comments]</i></p>

<p>
The Standard currently does not require that creation of such
intermediate objects is legal. 23.2.3 [sequence.reqmts] Table 100
&mdash; "Sequence container requirements" currently specifies:
</p>

<blockquote>
<table border="1">
<caption>Table 100 &mdash; Sequence container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.emplace(p, args);</tt>
</td>
<td>
<tt>iterator</tt>
</td>
<td>
<i>Requires</i>: <tt>T</tt> is <tt>EmplaceConstructible</tt> into
<tt>X</tt> from <tt>args</tt>. For <tt>vector</tt> and <tt>deque</tt>,
<tt>T</tt> is also <tt>MoveInsertable</tt> into <tt>X</tt> and
<tt>MoveAssignable</tt>. [&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

<p>
The <tt>EmplaceConstructible</tt> concept is defined via
<tt>allocator_traits&lt;A&gt;::construct</tt> in 23.2.1 [container.requirements.general] p15.5 That's surprising to me
since the related concepts use the suffix <tt>Insertable</tt> if they
refer to the allocator. An additional requirement such as
<tt>std::is_constructible&lt;T, Args...&gt;</tt> is necessary to allow
creation of intermediate objects.
</p>

<p>
The creation of intermediate objects also affects other functions, such
as <tt>vector.insert</tt>. Since aliasing the vector is only allowed for
the single-element forms of <tt>insert</tt> and <tt>emplace</tt> (see
<a href="lwg-closed.html#526">526</a>), the range-forms are not affected. Similarly,
aliasing is not allowed for the rvalue-reference overload. See also LWG
<a href="lwg-defects.html#2266">2266</a>.
</p>

<p>
There might be a problem with a requirement of
<tt>std::is_constructible&lt;T, Args...&gt;</tt> related to the issues
described in LWG <a href="lwg-active.html#2461">2461</a>. For example, a scoped allocator
adapter passes additional arguments to the constructor of the value
type. This is currently not done in recent implementations of libstdc++
and libc++ when creating the intermediate objects, they simply create
the intermediate object by perfectly forwarding the arguments. If such
an intermediate object is then moved to its final destination in the
vector, a change of the allocator instance might be required &mdash;
potentially leading to an expensive copy. One can also imagine worse
problems, such as run-time errors (allocators not comparing equal at
run-time) or compile-time errors (if the value type cannot be created
without the additional arguments). I have not looked in detail into this
issue, but I'd be reluctant adding a requirement such as
<tt>std::is_constructible&lt;T, Args...&gt;</tt> without further
investigation.
</p>

<p>
It should be noted that the creation of intermediate objects currently
is inconsistent in libstdc++ vs libc++. For example, libstdc++ creates
an intermediate object for <tt>vector.insert</tt>, but not
<tt>vector.emplace</tt>, whereas libc++ does the exact opposite in this
respect.
</p>

<p>
A live demo of the inconsistent creation of intermediate objects can be
found <a href="http://coliru.stacked-crooked.com/a/449253d3d329ef4c">here</a>.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>HH: If it were easy, it'd have wording. Over the decades I have flipped 180 degrees on this. My current position is that it should work even if the element is in the same container.</p>
<p>TK: What's the implentation status? JW: Broken in GCC. STL: Broken in MSVS. Users complain about this every year.</p>
<p>MC: 526 says push_back has to work.</p>
<p>HH: I think you have to make a copy of the element anyway for reasons of exception safety. [Discussion of exception guarantees] </p>
<p>STL: vector has strong exception guarantees. Could we not just provide the Basic guarantee here. </p>
<p>HH: It would terrify me to relax that guarantee. It'd be an ugly, imperceptible runtime error. </p>
<p>HH: I agree if we had a clean slate that strong exception safety is costing us here, and we shouldn't provide it if it costs us.</p>
<p>STL: I have a mail here, "how can vector provide the strong guarantee when inserting in the middle". </p>
<p>HH: The crucial point is that you only get the strong guarantee if the exception is thrown by something other than the copy and move operations that are used to make the hole. </p>
<p>STL: I think we need to clean up the wording. But it does mandate currently that the self-emplacement must work, because nothings says that you can't do it. TK clarifies that a) self-emplacement must work, and b) you get the strong guarantee only if the operations for making the hole don't throw, otherwise basic. HH agrees. STL wants this to be clear in the Standard.</p>
<p>STL: Should it work for deque, too? HH: Yes.</p>
<p>HH: I will attempt wording for this. </p>
<p>TK: Maybe mail this to the reflector, and maybe someone has a good idea? </p>
<p>JW: I will definitely not come up with anything better, but I can critique wording.</p>
<p>Moved to Open; Howard to provide wording, with feedback from Jonathan.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2166" href="#2166">2166.</a> Heap property underspecified?</h3>
<p><b>Section:</b> 25.5.6 [alg.heap.operations] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2012-07-09 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.heap.operations">issues</a> in [alg.heap.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Another similar issue to the <tt>operator&lt;</tt> vs greater in <tt>nth_element</tt> but not as direct occurs 
in 25.5.6 [alg.heap.operations]:
</p>
<blockquote><p>
-1- A <em>heap</em> is a particular organization of elements in a range between two random access iterators 
<tt>[a,b)</tt>. Its two key properties are:
</p>
<ol>
<li>There is no element greater than <tt>*a</tt> in the range and
</li>
<li><tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in 
O(log(<tt>N</tt>)) time.
</li>
</ol>
</blockquote>
<p>
As noted by Richard Smith, it seems that the first bullet should read:
</p>
<blockquote><p>
<tt>*a</tt> is not less than any element in the range
</p></blockquote>
<p>
Even better the heap condition could be stated here directly, instead of leaving it unspecified, i.e.,
</p>
<blockquote><p>
Each element at <tt>(a+2*i+1)</tt> and <tt>(a+2*i+2)</tt> is less than the element at <tt>(a+i)</tt>, 
if those elements exist, for <tt>i&gt;=0</tt>.
</p></blockquote>
<p>
But may be that was may be intentional to allow other heap organizations?
<p/>
See also follow-up discussion of c++std-lib-32780.
<p/>

</p>
<p><i>[2016-08 &mdash; Chicago]</i></p>

<p>Walter provided wording</p>
<p>Tues PM: Alisdair &amp; Billy(MS) to improve the wording.</p>

<p><i>[2016-08-02 Chicago LWG]</i></p>

<p>
Walter provides initial Proposed Resolution. Alisdair objects to perceived
complexity of the mathematical phrasing.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p><i>[Note to editor: As a drive-by editorial adjustment, please replace the current
enumerated list format by the numbered bullet items shown below.]</i></p>


<p>Change [alg.heap.operations]:</p>

<p>1 A heap is a particular organization of elements in a range between two
random access iterators [a, b)<del>. Its two key properties are</del><ins>such
that</ins>:</p>

<p>(1.1) -- <del>There is no element greater than <tt>*a</tt> in the range and</del><br/>
         <ins>For all <tt>i >= 0</tt>,<br/>
         <tt>comp(a[i], a[L])</tt> is false whenever L = 2*i+1 &lt; b-a,<br/>
         and<br/>
         <tt>comp(a[i], a[R])</tt> is false whenever R = 2*i+2 &lt; b-a.</ins><br/>
</p>
<p>(1.2) -- <tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in O(log(N)) time.</p>
</blockquote>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter and Billy O'Neal provide revised Proposed Resolution, superseding
yesterday's.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 25.5.6 [alg.heap.operations] as indicated:</p>

<blockquote class="note">
<p>
Note to project editor: As a drive-by editorial adjustment, please replace the
current enumerated list format by numbered bullet items.
</p>
</blockquote>

<blockquote>
<p>
-1- A <em>heap</em> is a particular organization of elements in a range between two random access iterators 
<tt>[a, b)</tt><del>. Its two key properties are</del><ins>such that</ins>:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <del>There is no element greater than <tt>*a</tt> in the range and</del>
<ins>With <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>N</mi><mo>=</mo><mi>b</mi><mo>-</mo><mi>a</mi>
</math>, for all <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math>,
<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>N</mi></math>,
<code>comp(a[</code><math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mo form="prefix">&#x0230A;</mo>
	<mrow>
		<mfrac linethickness="1">
			<mrow>
				<mo form="prefix">(</mo>
				<mi>i</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo form="postfix">)</mo>
			</mrow>
			<mn>2</mn>
		</mfrac>
	</mrow>
	<mo form="postfix">&#x0230B;</mo>
</mrow>
</math><code>, a[<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math>])</code> is <tt>false</tt>.</ins>
</p>
<blockquote class="note">
<p>
[Drafting note for the project editor: In LaTeX the above insertion should be expressed as follows:
<p/>
With $N$ = <code>b</code>-<code>a</code>$, for all $i$, $0 &lt; i &lt; N$,
<code>comp(a[$\left \lfloor{\frac{(i-1)}{2}}\right \rfloor$], a[$i$])</code> is <code>false</code>.]
</p>
</blockquote>
</li>
<li><p>(1.2) &mdash; <tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in 
<math xmlns="http://www.w3.org/1998/Math/MathML"><mo>O(</mo><mo>log(</mo><mi>N</mi><mo>)</mo><mo>)</mo></math> time.</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2173" href="#2173">2173.</a> The meaning of operator + in the description of the algorithms</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-08-01 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 25.1 [algorithms.general]/12,
</p>
<blockquote><p>
In the description of the algorithms operators <tt>+</tt> and <tt>-</tt> are used for some of the iterator categories 
for which they do not have to be defined. In these cases the semantics of <tt>a+n</tt> is the same as that of
</p>
<blockquote><pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre></blockquote>
</blockquote>
<p>
There are several places where such operator <tt>+</tt> is applied to an output iterator &mdash; for example, see the 
description of <tt>std::copy</tt>:
</p>
<blockquote><pre>
template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy(InputIterator first, InputIterator last,
                    OutputIterator result);
</pre>
<blockquote><p>
-1- <i>Effects</i>: Copies elements in the range <tt>[first,last)</tt> into the range <tt>[result,result + (last -
first))</tt> starting from <tt>first</tt> and proceeding to <tt>last</tt>. For each non-negative integer 
<tt>n &lt; (last - first)</tt>, performs <tt>*(result + n) = *(first + n)</tt>.
</p></blockquote></blockquote>
<p>
<tt>std::advance</tt> is not supposed to be applicable to output iterators, so we need a different method of description.
<p/>
See also message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32908">c++std-lib-32908</a>.
</p>

<p><i>[2014-06-07 Daniel comments and provides wording]</i></p>

<p>
The specification for output iterators is somewhat tricky, because here a sequence of increments is required to
be combined with intervening <em>assignments</em> to the dereferenced iterator. I tried to respect this
fact by using a conceptual assignment operation as part of the specification.
<p/>
Another problem in the provided as-if-code is the question which requirements are imposed on <tt>n</tt>. Unfortunately,
the corresponding function <tt>advance</tt> is completely underspecified in this regard, so I couldn't borrow wording
from it. We cannot even assume here that <tt>n</tt> is the difference type of the iterator, because for output iterators there is
no requirements for this associated type to be defined. The presented wording attempts to minimize assumptions, but still
can be considered as controversial. 
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 25.1 [algorithms.general] around p12 as indicated:</p>

<blockquote>
<p>
-12- In the description of the algorithms operators <tt>+</tt> and <tt>-</tt> are used for some of the iterator categories for which
they do not have to be defined. In these cases the semantics of <tt>a+n</tt> is the same as that of
</p>
<blockquote>
<pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre>
</blockquote>
<p>
<ins>when <tt>X</tt> meets the input iterator requirements (24.2.3 [input.iterators]), otherwise it is the same as that of</ins>
</p>
<blockquote>
<pre>
<ins>X tmp = a;
for (auto i = n; i; ++tmp, (void) --i) 
  *tmp = <i>Expr</i>(i); 
return tmp;</ins>
</pre>
</blockquote>
<p>
<ins>where <tt><i>Expr</i>(i)</tt> denotes the <tt>n-i</tt>-th expression that is assigned to for the corresponding algorithm;</ins> 
and that of <tt>b-a</tt> is the same as of
</p>
<blockquote>
<pre>
return distance(a, b);
</pre>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2178" href="#2178">2178.</a> <tt>Allocator</tt> requirement changes not mentioned Annex C</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], C.5 [diff.library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2012-08-14 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Given that a number of things were removed from the allocator requirements (<tt>reference</tt>, <tt>const_reference</tt>, 
<tt>address()</tt> in 17.6.3.5 [allocator.requirements]), it seems that these incompatible changes should be 
mentioned in Annex C.5 [diff.library], more specifically in [diff.cpp03].
</p>

<p><i>[
2012-10 Portland: Move to Open 
]</i></p>


<p>
It was clearly pointed out by Bill during the C++11 process that our change to allocator requirements
potentially broke 3rd party user containers written to expect C++03 allocators, or rather, an
allocator written to the minimal requirements of C++11 might not be guaranteed to work with a container
written to the previous rules.  This was a trade-off in making allocaters easier to write by use of
the <tt>allocator_traits</tt> framework.
</p>

<p>
This probably does merit a write-up in Annex C, and we look forward to seeing wording.  Until then,
the best we can do is move the issue to Open.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2183" href="#2183">2183.</a> Muddled allocator requirements for <tt>match_results</tt> constructors</h3>
<p><b>Section:</b> 28.10.1 [re.results.const], 28.10.6 [re.results.all] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
28.10.1 [re.results.const] p1 says:
</p>
<blockquote><p>
In all <tt>match_results</tt> constructors, a copy of the <tt>Allocator</tt> argument shall be used for any memory 
allocation performed by the constructor or member functions during the lifetime of the object.
</p></blockquote>
<p>
There are three constructors:
</p>
<blockquote><pre>
match_results(const Allocator&amp; = Allocator());
match_results(const match_results&amp; m);
match_results(match_results&amp;&amp; m) noexcept;
</pre></blockquote>
<p>
The second and third constructors do no have an <tt>Allocator</tt> argument, so despite the "all <tt>match_results</tt> 
constructors", it is not possible to use "the <tt>Allocator</tt> argument" for the second and third constructors.
<p/>
The requirements for those two constructors also does not give any guidance. The second constructor has no language 
about allocators, and the third states that the stored <tt>Allocator</tt> value is move constructed from 
<tt>m.get_allocator()</tt>, but doesn't require using that allocator to allocate memory.
<p/>
The same basic problem recurs in 28.10.6 [re.results.all], which gives the required return value for 
<tt>get_allocator()</tt>:
</p>
<blockquote><p>
<i>Returns</i>: A copy of the <tt>Allocator</tt> that was passed to the object's constructor or, if that allocator 
has been replaced, a copy of the most recent replacement.
</p></blockquote>
<p>
Again, the second and third constructors do not take an <tt>Allocator</tt>, so there is nothing that meets this 
requirement when those constructors are used.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2184" href="#2184">2184.</a> Muddled allocator requirements for <tt>match_results</tt> assignments</h3>
<p><b>Section:</b> 28.10.1 [re.results.const], 28.10.6 [re.results.all] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The effects of the two assignment operators are specified in Table 141. Table 141 makes no mention of allocators, 
so, presumably, they don't touch the target object's allocator. That's okay, but it leaves the question: 
<tt>match_results::get_allocator()</tt> is supposed to return "A copy of the Allocator that was passed to the 
object's constructor or, if that allocator has been replaced, a copy of the most recent replacement"; if assignment 
doesn't replace the allocator, how can the allocator be replaced?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2189" href="#2189">2189.</a> Throwing <tt>swap</tt> breaks unordered containers' state</h3>
<p><b>Section:</b> 23.2.5.1 [unord.req.except] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-09-23 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The hash functor and key-comparison functor of unordered containers are allowed to throw on <tt>swap</tt>.
</p>
<p>
23.2.5.1 [unord.req.except]p3 "For unordered associative containers, no <tt>swap</tt> function throws
an exception unless that exception is thrown by the swap of the container's Hash or Pred object (if any)."
</p>
<p>
In such a case we must offer the basic exception safety guarantee, where both objects are left in valid
but unspecified states, and no resources are leaked.  This yields a corrupt, un-usable container if the
first <tt>swap</tt> succeeds, but the second fails by throwing, as the functors form a matched pair.
</p>
<p>
So our basic scenario is first, swap the allocators if the allocators propagate on swap, according to
<tt>allocator_traits</tt>.  Next we swap the pointers to our internal hash table data structures, so that
they match the allocators that allocated them.  (Typically, this operation cannot throw).  Now our containers
are back in a safely destructible state if an exception follows.
</p>
<p>
Next, let's say we swap the hash functor, and that throws.  We have a corrupt data structure, in that the
buckets are not correctly indexed by the correct functors, lookups will give unpredicatable results etc.
We can safely restore a usable state by forcibly clearing each container - which does not leak resources
and leaves us with two (empty but) usable containers.
</p>
<p>
Now let us assume that the hasher swap succeeds.  Next we swap the equality comparator functor, and this
too could throw. The important point to bear in mind is that these two functors form an important pairing
- two objects that compare equal by the equality functor must also hash to the same value.  If we swap
one without the other, we most likely leave the container in an unusable state, even if we clear out all
elements.
</p>
<p>
1. A colleague pointed out that the solution for this is to dynamically allocate the two functors, and then
we need only swap pointers, which is not a throwing operation.  And if we don't want to allocate on default
construction (a common QoI request), we might consider moving to a dynamically allocated functors whenever
<tt>swap</tt> is called, or on first insertion.  Of course, allocating memory in <tt>swap</tt> is a whole
new can of worms, but this does not really sound like the design we had intended.
</p>

<p>
2. The simplest option is to say that we do not support hasher or equality functors that throw on ADL
<tt>swap</tt>.  Note that the requirement is simply to not throw, rather than to be explicitly
marked as <tt>noexcept</tt>.  Throwing functors are allowed, so long as we never use values that
would actually manifest a throw when used in an unordered container.
</p>

<p>
Pablo went on to give me several more options, to be sure we have a full set to consider:
</p>
<p>
3. Disallow one or the other functor from throwing.  In that case, the 
possibly-throwing functor must be swapped first, then the other functor, 
the allocator, and the data pointer(s) afterwards (in any order -- there 
was a TC that allocator assignment and swap may not throw if the 
corresponding propagation trait is true.). Of course, the question 
becomes: which functor is allowed to throw and which one is not?
</p>
<p>
4. Require that any successful functor <tt>swap</tt> be reliably reversible.  
This is very inventive.  I know of no other place in the standard where 
such a requirement is stated, though I have occasionally wanted such a 
guarantee.
</p>
<p>
5. Allow a failed swap to leave the containers in a state where future 
insertions may fail for reasons other than is currently allowed.  
Specifically, if the hash and equality functors are out of sync, all 
insertions will fail.  Presumably some "incompletely swapped" exception 
would be thrown.  This is "slightly" inventive, although people have been 
discussing "radioactive" states for a while.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2191" href="#2191">2191.</a> Incorrect specification of <tt>match_results(match_results&amp;&amp;)</tt></h3>
<p><b>Section:</b> 28.10.1 [re.results.const] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-10-02 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
28.10.1 [re.results.const]/3: "Move-constructs an object of class <tt>match_results</tt> satisfying the same 
postconditions as Table 141."
</p>
<p>
Table 141 lists various member functions and says that their results should be the results of the corresponding member 
function calls on <tt>m</tt>. But <tt>m</tt> has been moved from, so the actual requirement ought to be based on the 
value that <tt>m</tt> had <em>before</em> the move construction, not on <tt>m</tt> itself.
</p>
<p>
In addition to that, the requirements for the copy constructor should refer to Table 141.
<p/>
<u>Ganesh</u>:
<p/>
Also, the requirements for move-assignment should refer to Table 141. Further it seems as if in Table 141 all phrases of
"for all integers <tt>n &lt; m.size()</tt>" should be replaced by "for all <em>unsigned</em> integers 
<tt>n &lt; m.size()</tt>".
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2195" href="#2195">2195.</a> Missing constructors for <tt>match_results</tt></h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-10-06 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results">active issues</a> in [re.results].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The requirement expressed in 28.10 [re.results] p2
</p>
<blockquote><p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 23.2.3 [sequence.reqmts], except that only operations defined for 
const-qualified sequence containers are supported.
</p></blockquote>
<p>
can be read to require the existence of the described constructors from as well, but they do not exist in the
synopsis. 
<p/>
The missing sequence constructors are: 
</p>
<blockquote><pre>
match_results(initializer_list&lt;value_type&gt;);
match_results(size_type, const value_type&amp;);
template&lt;class InputIterator&gt; match_results(InputIterator, InputIterator);
</pre></blockquote>
<p>
The missing allocator-aware container constructors are:
</p>
<blockquote><pre>
match_results(const match_results&amp;, const Allocator&amp;);
match_results(match_results&amp;&amp;, const Allocator&amp;);
</pre></blockquote>
<p>
It should be clarified, whether (a) constructors are an exception of above mentioned operations or (b) whether
at least some of them (like those accepting a <tt>match_results</tt> value and an allocator) should be added.
<p/>
As visible in several places of the standard (including the core language), constructors seem usually to be considered 
as "operations" and they certainly can be invoked for const-qualified objects.
<p/>
The below given proposed resolution applies only the minimum necessary fix, i.e. it excludes constructors from
above requirement. 
</p>

<p><i>[2013-04-20, Bristol]</i></p>

<p>Check current implementations to see what they do and, possibly, write a paper.</p>

<p><i>[2013-09 Chicago]</i></p>

<p>Ask Daniel to update the proposed wording to include the allocator copy and move constructors.</p>

<p><i>[2014-01-18 Daniel changes proposed resolution]</i></p>

<p><strong>Previous resolution from Daniel [SUPERSEDED]:</strong></p>

<blockquote class="note">
<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 23.2.3 [sequence.reqmts], except that only operations defined for 
const-qualified sequence containers <ins>that are not constructors</ins> are supported.
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05-06 Lenexa]</i></p>

<p>MC passes important knowledge to EF.</p>
<p>VV, RP: Looks good.</p>
<p>TK: Second form should be conditionally noexcept</p>
<p>JY: Sequence constructors are not here, but mentioned in the issue writeup. Why?</p>
<p>TK: That would have been fixed by the superseded wording.</p>
<p>JW: How does this interact with Mike Spertus' allocator-aware regexes? [...] Perhaps it doesn't.</p>
<p>JW: Can't create match_results, want both old and new resolution.</p>
<p>JY: It's problematic that users can't create these, but not this issue.</p>
<p>VV: Why conditional noexcept?</p>
<p>MC: Allocator move might throw.</p>
<p>JW: Update superseded wording to "only non-constructor operations that are"?</p>
<p>MC: Only keep superseded, but append "and the means of constructing match_results are limited to [...]"?</p>
<p>JY: Bullet 4 paragraph 2 needs to address the allocator constructor.</p>
<p>Assigned to JW for drafting.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: I want Mike Spertus to be aware of this issue.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 28.10 [re.results] p4, class template <tt>match_results</tt> synopsis, as indicated:</p>
<blockquote><pre>
[&hellip;]
// 28.10.1, construct/copy/destroy:
explicit match_results(const Allocator&amp; a = Allocator());
match_results(const match_results&amp; m);
<ins>match_results(const match_results&amp; m, const Allocator&amp; a);</ins>
match_results(match_results&amp;&amp; m) noexcept;
<ins>match_results(match_results&amp;&amp; m, const Allocator&amp; a) noexcept;</ins>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Change 28.10.1 [re.results.const]  as indicated: [<i>Drafting note:</i> Paragraph 6 as currently written,
makes not much sense, because the <tt>noexcept</tt> does not allow any exception to propagate. Further-on, the allocator requirements
do not allow for throwing move constructors. Deleting it seems to be near to editorial &mdash; <i>end drafting note</i>]</p>
<blockquote>

<pre>
match_results(const match_results&amp; m);
<ins>match_results(const match_results&amp; m, const Allocator&amp; a);</ins>
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Constructs an object of class <tt>match_results</tt>, as a copy of <tt>m</tt>.
</p>
</blockquote>

<pre>
match_results(match_results&amp;&amp; m) noexcept;
<ins>match_results(match_results&amp;&amp; m, const Allocator&amp; a) noexcept;</ins>
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Move-constructs an object of class <tt>match_results</tt> from <tt>m</tt> satisfying the same postconditions
as Table 142. <del>Additionally</del><ins>For the first form</ins>, the stored <tt>Allocator</tt> value is move constructed 
from <tt>m.get_allocator()</tt>.
<p/>
<del>-6- <i>Throws:</i> Nothing if the allocator's move constructor throws nothing.</del>
</p>
</blockquote>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="2198" href="#2198">2198.</a> <tt>max_load_factor(z)</tt> makes no strong guarantees, but bans useful behavior</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The user cannot specify a <tt>max_load_factor</tt> for their unordered container
at construction, it must be supplied after the event, when the container is
potentially not empty.  The contract for this method is deliberately vague, not
guaranteeing to use the value supplied by the user, and any value actually used
will be used as a ceiling that the container will <i>attempt</i> to respect.
</p>
<p>
The only guarantee we have is that, if user requests a <tt>max_load_factor</tt>
that is less than the current <tt>load_factor</tt>, then the operation will take
constant time, thus outlawing an implementation that chooses to rehash and so
preserve as a class invariant that <tt>load_factor &lt; max_load_factor</tt>.
</p>
<p>
Reasonable options conforming to the standard include ignoring the user's request
if the requested value is too low, or deferring the rehash to the next <tt>insert</tt>
operation and allowing the container to have a strange state (wrt <tt>max_load_factor</tt>)
until then - and there is still the question of rehashing if the next <tt>insert</tt>
is for a duplicate key in a unique container.
</p>
<p>
Given the deliberate vagueness of the current wording, to support a range of reasonable
(but not <i>perfect</i>) behaviors, it is not clear why the equally reasonable rehash
to restore the constraint should be outlawed.  It is not thought that this is a performance
critical operation, where users will be repeatedly setting low load factors on populated
containers, in a tight or (less unlikely) an instant response scenario.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2199" href="#2199">2199.</a> unordered containers are required to have an initial max load factor of 1.0</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The default constructor, allocator-aware constructor, and range-based constructors
for the unordered containers do not offer a means to control the initial
<tt>max_load_factor</tt>, so the standard mandates the value 1.0.  This seems overly
restrictive, as there is plenty of research suggesting a value between 0.5 and 1.0
is more often optimal for unique-key containers, and perhaps a slightly higher
value might be appropriate for multi-containers.
</p>
<p>
Rather than guess at the appropriate <tt>max_load_factor</tt>, it seems reasonable
that the standard should allow vendors to pick a value at their discretion, with
perhaps a note of advice.  It is less clear whether the default value should be
implementation-defined or unspecified, given the ease of a user determining this
by querying this attribute immediately after construction.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>
<p>
Marshall: It seems to me that what you really want is to be able to pass a max load factor in the
constructor, but that's a different issue.
</p>
<p>
Alisdair agrees in principle, but concerned with adding yet more constructors to these classes.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2201" href="#2201">2201.</a> Missing macro entries from C standard library</h3>
<p><b>Section:</b> C.5 [diff.library] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kevin McCarty <b>Opened:</b> 2012-02-03 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It seems that in C.5 [diff.library], Table 150 the following macros from 18.3.3 [c.limits], Table 31 
are missing:
</p>
<blockquote><pre>
LLONG_MIN 
LLONG_MAX
ULLONG_MAX
</pre></blockquote>
<p>
In addition in C.5 [diff.library], Table 150 the following macros from 18.3.3 [c.limits], Table 32 
are missing:
</p>
<blockquote><pre>
DECIMAL_DIG 
FLT_EVAL_METHOD
</pre></blockquote>
<p>
Furtheron it seems that in C.5 [diff.library], Table 149/150 further macros are missing as well, e.g. 
<tt>HUGE_VALF</tt>, <tt>INFINITY</tt>, etc.
</p>

<p><i>[2014-02 Issaquah:]</i></p>

<p>
This is an issue, all of C has not been updated for C99, C99 functions are missing, whole section needs to be overhauled.
<p/>
The issue needs to be updated for functions and other missing items and when that happens the issue title is wrong and
needs to be adapted.
</p>

<p><i>[2016-08, Chicago: Zhihao Yuan comments]</i></p>

<p>
We suggest to either:
</p>
<ol>
<li><p>
Having a paper to rewrite C.5 C standard library by striking
the content shared by C and C++ and leave only the
differences;
</p></li>
<li><p>
Having a paper, or a complete proposed wording to fix
the missing names added between C89 and C99.
</p></li>
</ol>
<p>
For 1), some C11 headers being excluded from C++ (such as
<tt>thread.h</tt>) need to be added to this section.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2202" href="#2202">2202.</a> Missing allocator support by <tt>async</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2012-10-19 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>Discussion:</b></p>

<p>
<tt>promise</tt>, <tt>packaged_task</tt>, and <tt>async</tt> are the only
places where a shared state is actually supposed to be allocated. Accordingly,
<tt>promise</tt> and <tt>packaged_task</tt> are "allocator-aware". But
function template <tt>async</tt> provides no way to provide an allocator.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Matt: deprecate async 
<p/>
Nico: read my paper 
<p/>
Alisdair: defer issues to wait for polymorphic allocators 
<p/>
Alisdair: defer, active topic of research Deferred 
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
We want whatever status approximates: "will not fix; we're working on a replacement facility and don't want to add features to a broken one"
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2206" href="#2206">2206.</a> Inaccuracy in <tt>initializer_list</tt> constructor requirements</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts], 23.2.4 [associative.reqmts], 23.2.5 [unord.req], 26.6.1.2 [rand.req.seedseq] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-21 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 23.2.3 [sequence.reqmts] p3, we have "<tt>il</tt> designates an object of type
<tt>initializer_list&lt;value_type&gt;</tt>", and then several functions that take
'<tt>il</tt>' as an argument. However, an expression like <tt>{1, 2, 'a'}</tt> is <em>not</em>
an object of type <tt>initializer_list&lt;int&gt;</tt> unless it's used to initialize
an explicitly-typed variable of that type. I believe we want:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
v = {1, 2, 'a'};
</pre></blockquote>
<p>
to compile portably, so we should say something different when defining '<tt>il</tt>'. The 
same phrasing happens in 23.2.4 [associative.reqmts], 23.2.5 [unord.req], and 
26.6.1.2 [rand.req.seedseq].
<p/>
This may just be an editorial issue because the actual class synopses declare the functions 
to take <tt>initializer_list&lt;exact_type&gt;</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This is definitely not NAD
</p>
<p>
Should copy the suggested wording as the proposed resolution.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2214" href="#2214">2214.</a> Clarify <tt>basic_ios::init</tt> call restrictions</h3>
<p><b>Section:</b> 27.5.5.2 [basic.ios.cons] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andrey Semashev <b>Opened:</b> 2012-11-09 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an ambiguity in how <tt>std::basic_ios::init</tt> method (27.5.5.2 [basic.ios.cons]) 
can be used in the derived class. The Standard only specify the state of the <tt>basic_ios</tt> 
object after the call completes. However, in <tt>basic_ios</tt> default constructor description 
(27.5.5.2 [basic.ios.cons]) there is this sentence:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (27.5.3.7 [ios.base.cons]) 
leaving its member objects uninitialized. The object shall be initialized by calling <tt>basic_ios::init</tt> 
before its first use or before it is destroyed, whichever comes first; otherwise the behavior is undefined.
</p></blockquote>
<p>
This restriction hints that <tt>basic_ios::init</tt> should be called exactly
once before the object can be used or destroyed, because <tt>basic_ios::init</tt> 
may not know whether it was called before or not (i.e. whether its members are actually 
uninitialized or are initialized by the previous call to <tt>basic_ios::init</tt>). There 
is no such restriction in the <tt>basic_ios::init</tt> preconditions so it is not clear whether it is
allowed to call <tt>basic_ios::init</tt> multiple times or not.
<p/>
This problem has already affected publicly available implementations.
For example, Microsoft Visual C++ STL introduces a memory leak if
<tt>basic_ios::init</tt> is called multiple times, while GCC 4.7 and STLPort
reinitialize the <tt>basic_ios</tt> object correctly without memory leak or any
other undesired effects. There was a discussion of this issue on Boost
<a href="http://article.gmane.org/gmane.comp.lib.boost.devel/235659">developers mailing list</a>, 
and there is a <a href="https://sourceforge.net/apps/trac/boost-log/ticket/2#comment:4">test case 
that reproduces the problem</a>. The test case is actually a bug report for my Boost.Log library, 
which attempts to cache <tt>basic_ostream</tt>-derived objects internally to avoid expensive construction 
and destruction. My stream objects allowed resetting the stream buffer pointers the stream
is attached to, without requiring to destroy and construct the stream.
<p/>
My personal view of the problem and proposed resolution follows.
<p/>
While apparently the intent of <tt>basic_ios::init</tt> is to provide a way to
initialize <tt>basic_ios</tt> after default construction, I see no reason to
forbid it from being called multiple times to reinitialize the stream.
Furthermore, it is possible to implement a conforming <tt>basic_ios</tt> that
does not have this restriction.
<p/>
The quoted above section of the Standard that describes the effects of
the default constructor is misleading. The Standard does not mandate
any data members of <tt>basic_ios</tt> or <tt>ios_base</tt> (27.5.3 [ios.base]), which
it derives from. This means that the implementation is allowed to use
non-POD data members with default constructors that initialize the
members with particular default values. For example, in the case of
Microsoft Visual C++ STL the leaked memory is an <tt>std::locale</tt> instance
that is dynamically allocated during <tt>basic_ios::init</tt>, a raw pointer to
which is stored within ios_base. It is possible to store e.g. an
<tt>unique_ptr</tt> instead of a raw pointer as a member of <tt>ios_base</tt>, the smart
pointer will default initialize the underlying raw pointer on default
construction and automatically destroy the allocated object upon being
reset or destroyed, which would eliminate the leak and allow
<tt>basic_ios::init</tt> to be called multiple times. This leads to conclusion
that the default constructor of <tt>basic_ios</tt> cannot leave "its member
objects uninitialized" but instead performs default initialization of
the member objects, which would mean the same thing in case of POD types.
<p/>
However, I feel that restricting <tt>ios_base</tt> and <tt>basic_ios</tt> members to
non-POD types is not acceptable. Since multiple calls to <tt>basic_ios::init</tt> are 
not forbidden by the Standard, I propose to correct the <tt>basic_ios</tt> default 
constructor description so that it is allowed to destroy <tt>basic_ios</tt> object 
without calling <tt>basic_ios::init</tt>. This would imply that any raw members of 
<tt>basic_ios</tt> and <tt>ios_base</tt> should be initialized to values suitable for 
destruction (essentially, this means only initializing raw pointers to NULL). The new 
wording could look like this:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (27.5.3.7 [ios.base.cons])
initializing its member objects to unspecified state, only suitable for <tt>basic_ios</tt> destruction.
The object shall be initialized by calling <tt>basic_ios::init</tt> before its first use; otherwise 
the behavior is undefined.
</p></blockquote>
<p>
This would remove the hint that <tt>basic_ios::init</tt> must be called exactly
once. Also, this would remove the requirement for <tt>basic_ios::init</tt> to
be called at all before the destruction. This is also an important issue because 
the derived stream constructor may throw an exception before it manages to call 
<tt>basic_ios::init</tt> (for example, if the streambuf constructor throws), and 
in this case the <tt>basic_ios</tt> destructor has undefined behavior.
<p/>
To my mind, the described modification is sufficient to resolve the issue. But to 
emphasize the possibility to call <tt>basic_ios::init</tt> multiple times, a remark 
or a footnote for <tt>basic_ios::init</tt> postconditions could be added to explicitly 
state the semantics of calling it multiple times. The note could read as follows:
</p>
<blockquote><p>
The function can be called multiple times during the object lifetime. Each subsequent 
call reinitializes the object to the described in postconditions initial state.
</p></blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Alisdair: The current wording is unclear but the proposed resolution is wrong
<p/>
Solution: Clarify that <tt>init</tt> must be called once and only once. Move then to review. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 27.5.5.2 [basic.ios.cons] as indicated:</p>
<blockquote><pre>
basic_ios();
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (27.5.3.7 [ios.base.cons]) 
<del>leaving its member objects uninitialized</del><ins>initializing its member objects to unspecified state, 
only suitable for <tt>basic_ios</tt> destruction</ins>. The object shall be initialized by calling 
<tt>basic_ios::init</tt> before its first use <del>or before it is destroyed, whichever comes first</del>; 
otherwise the behavior is undefined.
</p>
</blockquote>
<pre>
void init(basic_streambuf&lt;charT,traits&gt;* sb);
</pre><blockquote>
<p>
<i>Postconditions</i>: The postconditions of this function are indicated in Table 128.
<p/>
<ins>-?- <i>Remarks</i>: The function can be called multiple times during the object lifetime. Each subsequent 
call reinitializes the object to the described in postconditions initial state.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2215" href="#2215">2215.</a> (unordered) associative container functors should be <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-11-14 <b>Last modified:</b> 2015-10-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the functors used to arrange elements in the various associative and
unordered containers are given by a set of expressions in tables 102 &mdash; Associative container
requirements, and 103 &mdash; Unordered associative container requirements.  In keeping with Library
convention these expressions make the minimal requirements necessary on their types.  For
example, we have the following 3 row extracts for the unordered containers:
</p>
<table>
<tr>
  <td>
    <b>Expression</b>
  </td>
  <td>
    <b>Assertion/note pre-/post-condition</b>
  </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n, hf, eq)</tt>
<tt>X a(n, hf, eq)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.
 </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n, hf)</tt>
<tt>X a(n, hf)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> is <tt>CopyConstructible</tt> and 
                  <tt>key_equal</tt> is <tt>DefaultConstructible</tt>.
 </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n)</tt>
<tt>X a(n)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>DefaultConstructible</tt>.
 </td>
</tr>
</table>

<p>
However, the signature for each class template requires that the functors must effectively be
<tt>CopyConstructible</tt> for each of these expressions:
</p>

<blockquote><pre>
template &lt;class Key,
          class T,
          class Hash  = hash&lt;Key>,
          class Pred  = std::equal_to&lt;Key>,
          class Allocator = std::allocator&lt;std::pair&lt;const Key, T> > >
class unordered_map
{
  <i>...</i>

  <i>// construct/destroy/copy</i>
  explicit unordered_map(size_type n = <i>see below</i>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());

  <i>...</i>
}
</pre></blockquote>

<p>
The letter of the standard can be honored as long as implementors recognize
their freedom to split this one signature into multiple overloads, so that
the documented default arguments (requiring a <tt>CopyConstructible</tt> functor)
are not actually passed as default arguments.
</p>
<p>
As we look into the requirements for the copy constructor and copy-assignment
operator, the requirements are even more vague, as the explicit requirements on
the functors are not called out, other than saying that the functors are copied.
</p>
<p>
Must the functors be <tt>CopyAssignable</tt>? Or is <tt>CopyConstructible</tt>
sufficient in this case?  Do we require that the functors be <tt>Swappable</tt>
so that the copy-swap idiom can be deployed here?  Note that a type that is both
<tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> is still not guaranteed to
be <tt>Swappable</tt> as the user may delete the <tt>swap</tt> function for their
type in their own namespace, which would be found via ADL.
</p>
<p>
Some clean-up of the requirements table looks necessary, to at least document the
assignment behavior.  In addition, we should have clear guidance on whether these
functors should always be <tt>CopyConstructible</tt>, as suggested by the class
template definitions, or if the requirement tables are correct and we should
explicitly split up the constructors in the (unordered) associative containers
to no longer use default (function) arguments to obtain their defaulted functors.
</p>
<p>
I recommend the simplest solution would be to always require that the functors
for (unordered) associative containers be <tt>CopyConstructible</tt>, above the
requirements tables themselves, so that the issue need not be addressed within
the tables.  I suggest that the assignment operators for these containers add
the requirement that the functors be <tt>Swappable</tt>, rather than forwarding
the corresponding <tt>Assignable</tt> requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to propose wording.
</p>

<p><i>[2014-06-08, Daniel comments]</i></p>

<p>
The area of this issue partially overlaps what LWG <a href="lwg-active.html#2227">2227</a> addresses.
</p>

<p><i>[2015-10-20, Daniel comments]</i></p>

<p>
The revised resolution of LWG <a href="lwg-active.html#2227">2227</a> should resolve this issue as well. It follows the recommendations
of the submitter to require <tt>CopyConstructible</tt> requirements for the function objects owned by containers,
but it does not impose any further fundamental requirements.
</p>


<p><b>Proposed resolution:</b></p>
<p>
See the resolution of LWG <a href="lwg-active.html#2227">2227</a>.
</p>





<hr>
<h3><a name="2216" href="#2216">2216.</a> <tt>regex_replace(basic_string)</tt> allocator handling</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-11-26 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<blockquote><pre>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
      const basic_regex&lt;charT, traits&gt;&amp; e,
      const charT* fmt,
      regex_constants::match_flag_type flags = 
	    regex_constants::match_default);
</pre></blockquote>
<p>
and friends are documented as
</p>
<blockquote><p>
Constructs an empty string result of type <tt>basic_string&lt;charT, ST, SA&gt;</tt>
and calls <tt>regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags)</tt>.
</p></blockquote>
<p>
This appears to require the result to have a default-constructed
allocator, which isn't even possible for all allocator types. I
suspect the allocator should be copied from 's' instead. Possibly
there should be an additional defaulted argument to override the
allocator of the result.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2220" href="#2220">2220.</a> Under-specification of <tt>operator==</tt> for <tt>regex_token_iterator</tt></h3>
<p><b>Section:</b> 28.12.2.2 [re.tokiter.comp] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-11-21 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Consider the following example:
</p>
<blockquote><pre>
std::string str0("x");
std::regex rg0("a");
std::regex_token_iterator it0(str0.begin(), str0.end(), rg0, -1); // points at "x" in str0
std::string str1("x");
std::regex rg1("b");
std::regex_token_iterator it1(str1.begin(), str1.end(), rg1, -1); // points at "x" in str1
</pre></blockquote>
<p>
28.12.2.2 [re.tokiter.comp] p1 says that <tt>it0.operator==(it1)</tt> returns true "if 
<tt>*this</tt> and <tt>right</tt> are both suffix iterators and <tt>suffix == right.suffix</tt>"; both 
conditions are satisfied in this example. It does not say that they must both be iterators 
into the same sequence, nor does it say (as general iterator requirements do) that they must 
both be in the domain of <tt>==</tt> in order for the comparison to be meaningful. It's a 
simple statement: they're equal if the strings they point at compare equal. Given this being
a valid comparison, the obtained result of "true" looks odd.
<p/>
The problem is that for iterator values prior to the suffix iterator, equality means the same 
regular expression and the same matched sequence (both uses of "same" refer to identity, not equality); 
for the suffix iterator, equality means that the matched sequences compare equal.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2221" href="#2221">2221.</a> No formatted output operator for <tt>nullptr</tt></h3>
<p><b>Section:</b> 27.7.3 [output.streams] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2012-12-07 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
When I write 
</p>
<blockquote><pre>
std::cout &lt;&lt; nullptr &lt;&lt; std::endl;
</pre></blockquote>
<p>
I get a compilation error, "ambiguous overload for '<tt>operator&lt;&lt;</tt>' in '<tt>std::cout &lt;&lt; nullptr</tt>'". 
As far as I can tell, the compiler is right to issue that error. There are inserters for <tt>const void*</tt>, 
<tt>const char*</tt>, <tt>const signed char*</tt>, and <tt>const unsigned char*</tt>, and none for 
<tt>nullptr_t</tt>, so the expression really is ambiguous.
<p/>
<em>Proposed wording</em>:
<p/>
The obvious library solution is to add a <tt>nullptr_t</tt> overload, which would be defined something like
</p>
<blockquote><pre>
template&lt;class C, class T&gt;
basic_ostream&lt;C, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;C, T&gt;&amp; os, nullptr_t) 
{ 
  return os &lt;&lt; (void*) nullptr; 
}
</pre></blockquote>
<p>
We might also consider addressing this at a core level: add a special-case language rule that addresses all 
cases where you write <tt>f(nullptr)</tt> and <tt>f</tt> is overloaded on multiple pointer types. (Perhaps 
a tiebreaker saying that <tt>void*</tt> is preferred in such cases.)
</p>

<p><i>[2016-01-18, comments from Mike and Ville collected by Walter Brown]</i></p>

<p>
<b>Mike Miller</b>: "Changing overload resolution sounds like something that should be
considered by EWG before CWG [&hellip;]"
<p/>
<b>Ville</b>: "Agreed, such a change would be Evolutionary. Personally, I think it would also be wrong, because 
I don't see how <tt>void*</tt> is the right choice to prefer in the case of code that is currently ambiguous. 
Sure, it would solve this particular library issue, but it seemingly has wider repercussions. If LWG really wants 
to, EWG can certainly discuss this issue, but I would recommend solving it on the LWG side (which doesn't mean 
that the standard necessarily needs to change, I wouldn't call it far-fetched to NAD it)."
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Zhihao recommends NAD:</p>
<p>
<tt>nullptr</tt> is printable if being treated as <tt>void*</tt>, but causes
UB if being treated as <tt>char cv*</tt>. Capturing this ambigurity
at compile time and avoid a runtime UB is a good thing.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: General agreement on providing the overload; discussion on what it should say.</p>
<p>Polls:<br/>
Matt's suggestion (in the issue): 2/0/6/2/2/<br/>
Unspecified output: 3/2/5/0/1<br/>
Specified output: 1/1/6/3/0</p>
<p>Move to Open</p>

<p><i>[2016-08 Chicago]</i></p>

<p>
The group consensus is that we only output <tt>nullptr</tt> because
it is of a fundamental type, causing problems in functions doing
forwarding, and we don't want to read it back.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606
</p>

<ol>
<li><p>Insert the signature into 27.7.3.1 [ostream], class template <tt>basic_ostream</tt> synopsis, as follows:</p>

<blockquote class="note">
<p>
[<i>Drafting notes:</i> Why member?  Don't want to define a new category of inserters just for this.]
</p>
</blockquote>

<blockquote>
<pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ostream
    : virtual public basic_ios&lt;charT, traits&gt; {
  public:
    [&hellip;]
    basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(const void* p);
    <ins>basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(nullptr_t);</ins>
    basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(
      basic_streambuf&lt;char_type, traits&gt;* sb);
    [&hellip;]
  };
</pre>
</blockquote>
</li>

<li><p>Append the following new paragraphs to 27.7.3.6.3 [ostream.inserters]:</p>

<blockquote>
<pre>
basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;
  (basic_streambuf&lt;charT, traits&gt;* sb);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<pre>
<ins>basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(nullptr_t);</ins>
</pre>
<blockquote>
<p>
<ins>-??- <i>Effects:</i> As if by <tt>*this &lt;&lt; s</tt>, where <tt>s</tt> is an
implementation-defined NTBS.</ins>
<p/>
<ins>-??- <i>Returns:</i> <tt>*this</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="2227" href="#2227">2227.</a> Stateful comparison objects in associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2012-12-19 <b>Last modified:</b> 2015-10-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 102 in 23.2.4 [associative.reqmts]/8 states on expression <tt>a.key_comp()</tt> that it 
"returns the comparison object out of which a was constructed". At the same time, 
23.2.1 [container.requirements.general]/8 states (starting in the third line) that 
"...Any <tt>Compare</tt>, <tt>Pred</tt>, or <tt>Hash</tt> objects belonging to <tt>a</tt> and <tt>b</tt> 
shall be swappable and <em>shall be exchanged</em> by unqualified calls to non-member swap...". This is 
problematic for any compliant implementation, since once swapped the container cannot return the comparison 
object out of which it was constructed unless incurring in storing an otherwise needless object.
<p/>
The simple solution is to correct that statement in Table 102, but I believe this is part of a larger problem 
of underspecified behavior: The new standard has made an effort in regards to allocators and now fully 
specifies what happens to stateful allocator objects. It has even specified what happens to stateful <tt>hasher</tt> 
and <tt>key_equal</tt> members of unordered containers (they propagate), but it says nothing about stateful 
comparison objects of (ordered) associative containers, except for the statement in 
23.2.1 [container.requirements.general]/8 referred above and only related to <tt>swap</tt>.
<p/>
For example, it is unclear to me what is specified to happen on an assignment: should the comparison object 
be copied/moved along with the elements, or should the left-hand side object keep its own?
Maybe this has been intentionally left unspecified with the purpose of compatibility with C++98, which I 
understand it specified that comparison objects were kept for the entire life of the container (like allocators) 
&mdash; an unfortunate choice. But anyway, the segment of 23.2.1 [container.requirements.general] quoted 
above seems to break any possible backwards compatibility with C++98 in this regard.
<p/>
Therefore, taking into consideration consistency with how this is dealed with for unordered associative 
containers, I propose that Table 102 is modified as follows:
</p>
<ul>
<li>
<p>
The row for expression <tt>a.key_comp()</tt> is changed so that its "assertion/note pre-/post-condition" reads 
"Returns <tt>a</tt>'s comparison object."
</p>
</li>

<li>
<p>
A new row is added at the appropriate location (which I believe would be after "X(il)" row), with:
</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td>
<tt>X(b)<br/>
X a(b)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.
</td>
<td>
Linear in <tt>b.size()</tt>
</td>
</tr>

<tr>
<td>
<tt>a = b</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.
</td>
<td>
Linear in <tt>a.size()</tt> and <tt>b.size()</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ul>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>

<p><i>[2013-04-18, Bristol]</i></p>
 
<p>
STL: can't believe we don't specify this already. this is totally necessary
<p/>
Alisdair: how does it do this? copy construction? assignment?
<p/>
Also need it for move.
<p/>
STL: we already specify this for constructing from a comparator, not during copy construction though.
<p/>
Jonathan: don't like wording, should say "<tt>key_compare</tt> is <tt>CopyConstructible</tt>. Uses <tt>b.key_comp()</tt> 
as a comparison object."
<p/>
STL: we get it right for unordered!
<p/>
Jonathan: can't wordsmith this now, but I think implementations do the right thing.
<p/>
Alisdair: not sure what right thing is for moves. Also we say nothing about propagating allocators to functors.
</p>
<p>
Moved to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
TK: There's no need for fine-grained propagate/not-propagate control. If you don't want to propagate the predicate, you can 
simply construct or insert from an iterator range.
<p/>
VV: libstdc++ already implements the resolution of this issue.
<p/>
GR: There are a couple of other problems. We don't specify move constructor and move assignment for maps. Those are just general.
<p/>
TK: General container requirements already describe the semantics for {copy,move}-{construction,assignment}, so it doesn't 
seem that there's room for choice in <tt>std::map</tt> assignments. <tt>unordered_map</tt> is different, though.
<p/>
[Note: Check what general container requirements say about container equality.]
<p/>
DK will draft wording. The decision is to unambiguously make all {copy,move}-{construction,assignment} operations endow the 
LHS with the exact state of the RHS, including all predicates and hash function states.
<p/>
Conclusion: Update wording, revisit later. 
</p>

<p><i>[2015-05-06 Lenexa: Waiting for updated wording]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(b)<br/>
X a(b)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.</ins>
</td>
<td>
<ins>Linear in <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = b</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.</ins>
</td>
<td>
<ins>Linear in <tt>a.size()</tt> and <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.key_comp()</tt>
</td>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><tt>a</tt>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>


</table>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2015-10-19 Daniel comments and provides alternative wording]</i></p>

<p>
The current standard is especially unclear in regard to what effects move operations of unordered/associative
containers should have. We have one example that is standardized exactly in this way by looking at 
23.6.5.2 [priqueue.cons.alloc] p7:
</p>
<blockquote>
<pre>
template &lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp; q, const Alloc&amp; a);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the first argument and <tt>a</tt> as 
the second argument, and initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>
</p>
</blockquote>
</blockquote>
<p>
A similarly comparable example are the move-operations of <tt>std::unique_ptr</tt> in regard to the deleter 
(when this is no a reference), which also respect move-capabilities of that function object.
<p/>
We have wording from C++98 for associative containers (but <em>not</em> for unordered containers!) that was never
adjusted to C++11 move-semantics in 23.2.4 [associative.reqmts] p12:
</p>
<blockquote><p>
When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.
</p></blockquote>
<p>
The second sentence of this wording is problematic for several reasons:
</p>
<ol>
<li><p>It only talks about copy operations, not about move operations, except that the term "assignment" without
leading "copy" is a bit ambigious (albeit it seems clear in the complete context).</p></li>
<li><p>It is not really clear how to interpret "as if that comparison object had been
passed to the target container in its constructor" for an assignment operation. A possible but not conclusive
interpretation could be that this is wording supporting a "copy-via-swap" idiom.</p></li>
<li><p>There does not exist similar wording for unordered containers, except that Table 102 provides entries for
copy construction and copy assignment of the containers whose wording just talks of "copies" in either case.</p></li>
</ol>
<p>
Existing implementations differ already:
</p>
<ol>
<li><p>Visual Studio 2015 uses copy construction and copy assignment for the two copy operations but uses swap operations
for the move operations.</p></li>
<li><p>GCC's libstdc++ performs copy construction and copy assignment for the two copy operations and for the two
move operations, respectively</p></li>
<li><p>clang++'s libc++ performs copy/move construction and copy/move assignment for the corresponding
four copy/move operations</p></li>
</ol>
<p>
The alternative wording provided below attempts to clarify that container copy/move operations perform the corresponding
copy/move operations on the owned function objects.
<p/>
In addition the wording also resolves LWG <a href="lwg-active.html#2215">2215</a>: I believe that the current
wording should require that container function objects should meet the <tt>CopyConstructible</tt> requirements. Adding
this general requirement also fixes the underspecified requirements of the accessor functions <tt>key_comp()</tt> and
<tt>value_comp()</tt>.
<p/>
I don't think that a general requirement for <tt>Swappable</tt> is needed, only the member <tt>swap</tt> function currently requires this.
Nonetheless the wording below does <em>support</em> stateful functors that are <em>also</em> moveable or move-assignable,
therefore the specified semantics in terms of move operations.
<p/>
I should add the following warning, though: If this proposed wording would be accepted, there is a little chance of
code breakage, because the current wording <em>can</em> be read that in general there is no requirement that the
container functors are <tt>CopyConstructible</tt>. The following code example is accepted by gcc + libstd++:
</p>
<blockquote><pre>
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Cmp {
  Cmp() = default;
  Cmp(const Cmp&amp;) = delete;
  Cmp(Cmp&amp;&amp;) = delete;
  Cmp&amp; operator=(const Cmp&amp;) = delete;
  Cmp&amp; operator=(Cmp&amp;&amp;) = delete;
  template&lt;class T&gt;
  bool operator()(const T&amp; x, const T&amp; y) const
  {
    return x &lt; y;
  }
};

typedef std::map&lt;int, int, Cmp&gt; MyMap;

int main() {
  MyMap m;
  std::cout &lt;&lt; (m.find(12) == m.end()) &lt;&lt; std::endl;
}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 23.2.4 [associative.reqmts] p8 as indicated:</p>

<blockquote><p>
-8- In Table 101, <tt>X</tt> denotes an associative container class, <tt>a</tt> denotes a value of type <tt>X</tt>, 
<ins><tt>b</tt> denotes a possibly <tt>const</tt> value of type <tt>X</tt>, <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of 
type <tt>X</tt>,</ins> <tt>u</tt> denotes the name of a variable being declared, [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 101 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 101 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<tt>Compare</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Compare</tt> is <tt>CopyConstructible</tt>.</ins><br/>
defaults to <tt>less&lt;key_type&gt;</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X(c)<br/>
X u(c);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<del><i>Requires:</i> <tt>key_compare</tt> is <tt>CopyConstructible</tt>.<br/></del> 
<i>Effects</i>: Constructs an empty container.<br/> 
Uses a copy of <tt>c</tt> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(i,j,c)<br/>
X u(i,j,c);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<i>Requires:</i> <del><tt>key_compare</tt> is <tt>CopyConstructible</tt>.<br/></del> 
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: Constructs an empty container and inserts elements<br/>
from the range <tt>[i, j)</tt> into it; uses <tt>c</tt> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(b)<br/>
X a(b)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the comparison object of <tt>a</tt> from<br/> 
the comparison object of <tt>b</tt>.</ins>
</td>
<td>
<ins>Linear in <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>X(rv)<br/>
X a(rv)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the comparison object of <tt>a</tt> from<br/> 
the comparison object of <tt>rv</tt>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = b</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>key_compare</tt> is <tt>CopyAssignable</tt>.<br/> 
<i>Effects:</i> Copy assigns the comparison object of <tt>b</tt><br/>
to the comparison object of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear in <tt>a.size()</tt> and <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = rv</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>key_compare</tt> is <tt>MoveAssignable</tt>.<br/> 
<i>Effects:</i> Move assigns from the comparison object of <tt>rv</tt><br/>
to the comparison object of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.key_comp()</tt>
</td>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><tt>a</tt>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 23.2.4 [associative.reqmts] p12 as indicated:</p>

<blockquote><p>
-12- When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. <del>When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.</del>
</p></blockquote>
</li>


<li><p>Change 23.2.5 [unord.req] p11 as indicated:</p>

<blockquote><p>
-11- In Table 102: <tt>X</tt> denotes an unordered associative container class, <tt>a</tt> denotes a value of type <tt>X</tt>, 
<tt>b</tt> denotes a possibly <tt>const</tt> value of type <tt>X</tt>, <ins><tt>rv</tt> denotes a non-<tt>const</tt> rvalue 
of type <tt>X</tt>,</ins> [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::hasher</tt>
</td>
<td>
<tt>Hash</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Hash</tt> is <tt>CopyConstructible</tt>.<br/></ins>
<tt>Hash</tt> shall be a unary function object type<br/> 
such that the expression <tt>hf(k)</tt> has type <tt>std::size_t</tt>.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::key_equal</tt>
</td>
<td>
<tt>Pred</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Pred</tt> is <tt>CopyConstructible</tt>.<br/></ins>
<tt>Pred</tt> shall be a binary predicate that takes<br/> 
two arguments of type <tt>Key</tt>.<br/> 
<tt>Pred</tt> is an equivalence relation.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(n, hf, eq)<br/>
X a(n, hf, eq)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<del><i>Requires</i>: <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.<br/></del>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>X(n, hf)<br/>
X a(n, hf)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> is <tt>CopyConstructible</tt> and<br/></del>
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(i, j, n, hf, eq)<br/>
X a(i, j, n, hf, eq)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.<br/></del>
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>X(i, j, n, hf)<br/>
X a(i, j, n, hf)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> is <tt>CopyConstructible</tt> and<br/></del>
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.<br/> 
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(b)<br/>
X a(b)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<del>Copy constructor. In addition<br/>
to the requirements of Table 95,<br/>
copies the hash function,<br/>
predicate, and maximum load<br/>
factor.</del>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the hash function, predicate, and maximum load factor<br/> 
of <tt>a</tt> from the corresponding objects of <tt>b</tt>.</ins>
</td>
<td>
Average case linear in<br/> 
<tt>b.size()</tt>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><tt>X(rv)<br/>
X a(rv)</tt></ins>
</td>
<td>
<ins><tt>X</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the hash function, predicate, and maximum load factor<br/> 
of <tt>a</tt> from the corresponding objects of <tt>rv</tt>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<tt>a = b</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<del>Copy assignment operator. In<br/>
addition to the requirements of<br/>
Table 95, copies the hash<br/>
function, predicate, and<br/>
maximum load factor.</del>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyAssignable</tt>.<br/> 
<i>Effects:</i> Copy assigns the hash function, predicate, and maximum load factor<br/> 
of <tt>b</tt> to the corresponding objects of <tt>a</tt>.</ins>
</td>
<td>
Average case linear in<br/> 
<tt>b.size()</tt>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><tt>a = rv</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>MoveAssignable</tt>.<br/> 
<i>Effects:</i> Move assigns the hash function, predicate, and maximum load factor<br/> 
from <tt>rv</tt> to the corresponding objects of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2237" href="#2237">2237.</a> <tt>&lt;cuchar&gt;</tt> macros</h3>
<p><b>Section:</b> 21.5 [c.strings] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2013-01-29 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Apparently C1X changes <tt>__STDC_UTF_16__</tt> and <tt>__STDC_UTF_32__</tt> from macros
defined in <tt>uchar.h</tt> (and reflected in C++ by Table 79) to be predefined by the compiler. 
Do we want to do the same?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2238" href="#2238">2238.</a> Problematic iterator-pair constructor of containers</h3>
<p><b>Section:</b> 21.5 [c.strings] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Johannes Schaub <b>Opened:</b> 2013-02-02 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The non-explicit nature of the iterator-pair constructor of containers, such a
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
can be selected in unexpected situations, leading to a hard runtime error, as demonstrated by the following example:
</p>

<blockquote><pre>
#include &lt;vector&gt;

void f(std::vector&lt;char&gt; v){ /* ... */}

int main() {
  f({"A", "B"});
}
</pre></blockquote>

<p>
The actually intended initializer-list constructor isn't feasible here, so the best match is the constructor template
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
This compiles, but will result in code running amok. The potential trap (that cannot be easily detected by the
library implementation) could be reduced by making this constructor explicit. It would still have the effect to 
be selected here, but the code would be ill-formed, so the programmer gets a clear meassage here.
</p>

<p><i>[2014-06 Rapperswil]</i></p>

<p>
JW: can't fix this, don't want to touch this, Do The Right Thing clause has been a source of tricky issues. 
only really happens with string literals, that's the only way to create an array that isn't obviously an array
<p/>
GR: want to see paper
<p/>
AM: is it only string literals, or also UDLs?
<p/>
STL: maybe, but we don't need to deal with that. This is only a problem in a very specific case 
<p/>
Leave as Open. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2243" href="#2243">2243.</a> <tt>istream::putback</tt> problem</h3>
<p><b>Section:</b> 27.7.2.3 [istream.unformatted] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-03-01 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 27.7.2.3 [istream.unformatted] / 34, when describing <tt>putback</tt>, it says that "<tt>rdbuf-&gt;sputbackc()</tt>" 
is called. The problem are not the obvious typos in the expression, but the fact that it may lead to different 
interpretations, since nowhere is specified what the required argument to <tt>sputbackc</tt> is.
<p/>
It can be guessed to be "<tt>rdbuf()-&gt;sputbackc(c)</tt>", but "<tt>rdbuf()-&gt;sputbackc(char_type())</tt>" or 
just anything would be as conforming (or non-confoming) as the first guess.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2248" href="#2248">2248.</a> <tt>numeric_limits::is_iec559</tt> misnamed</h3>
<p><b>Section:</b> 18.3.2 [limits] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2013-03-08 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This member should probably be named "is_ieee754". Or at least the standard should explain that IEC-559 no longer exists, 
and that it's been superseded by IEEE-754.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2256" href="#2256">2256.</a> On <tt>vector</tt> iterator invalidation</h3>
<p><b>Section:</b> 23.3.11.5 [vector.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2013-04-29 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in [vector.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.3.11.5 [vector.modifiers]/p3 says:
</p>
<blockquote><pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
<i>Effects</i>: Invalidates iterators and references at or after the point of the erase.
</p>
</blockquote></blockquote>
<p>
Consider this example:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;cassert&gt;

int main()
{
  typedef std::vector&lt;int&gt; C;
  C c = {1, 2, 3, 4};
  C::iterator i = c.begin() + 1;
  C::iterator j = c.end() - 1;
  assert(*i == 2);
  assert(*j == 4);
  c.erase(c.begin());
  <span style="color:#C80000;font-weight:bold">assert(*i == 3); // Why is this not perfectly fine?!</span>
}
</pre></blockquote>
<p>
Why has the iterator <tt>i</tt> been invalidated? It still refers to a perfectly reasonable, fully constructed object. 
If <tt>vector::iterator</tt> were to be implemented as a pointer (which is legal), it is not possible for that last 
line to do anything but run fine.
<p/>
The iterator <tt>j</tt> on the other hand now points at end, and any iterators that may now point beyond <tt>end()</tt>, 
into uninitialized memory, are clearly invalid.
<p/>
But why do we say that an iterator that <em>must</em> point to a valid object is invalid? This looks to me like we 
simply got sloppy in our specification.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to <a href="lwg-defects.html#2698">2698</a>
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2260" href="#2260">2260.</a> Missing requirement for <tt>Allocator::pointer</tt></h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-05-14 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For an allocator <tt>A&lt;T&gt;</tt> which defines <tt>A&lt;T&gt;::pointer</tt> to a class type,
i.e. not <tt>T*</tt>, I see no requirement that <tt>A&lt;T&gt;::pointer</tt> is convertible to
<tt>A&lt;U&gt;::pointer</tt>, even if <tt>T*</tt> is convertible to <tt>U*</tt>.  Such conversions are
needed in containers to convert from e.g. <tt>ListNodeBase*</tt> to <tt>ListNode&lt;T&gt;*</tt>.
</p>

<p>The obvious way to do such conversions appears to be
<tt>pointer_traits::pointer_to()</tt>, but that's ill-formed if the static
member function <tt>A&lt;T&gt;::pointer::pointer_to()</tt> doesn't exist and the
allocator requirements don't mention that function, so you need to
cast <tt>A&lt;T&gt;::pointer</tt> to <tt>A&lt;T&gt;::void_pointer</tt> then cast that to
<tt>A&lt;U&gt;::pointer</tt>.
</p>

<p>
Is converting via <tt>void_pointer</tt> really intended, or are we missing a requirement that 
<tt>pointer_traits&lt;A&lt;T&gt;::pointer&gt;::pointer_to()</tt> be well-formed?
</p>

<p>Proposed resolution:</p>

<p>Add to the Allocator requirements table the following requirement:</p>

<blockquote>
<p>
The expression <tt>pointer_traits&lt;XX::pointer&gt;::pointer_to(r)</tt> is well-defined.
</p>
</blockquote>

<p><i>[2013-09 Chicago]</i></p>

<p>
Pablo to come back with proposed wording
</p>

<p><i>[2015-07 Telecom]</i></p>

<p>
Marshall to ping Pablo for proposed wording and disable current wording.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class = "note">
<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2261" href="#2261">2261.</a> Are containers required to use their '<tt>pointer</tt>' type internally?</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-05-14 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is a container <tt>C</tt> only supposed to refer to allocated memory (blocks of
contiguous storage, nodes, etc.) through objects of type <tt>C::pointer</tt>
rather than <tt>C::value_type*</tt>?
</p>

<p>
I don't see anything explicitly requiring this, so a container could
immediately convert the result of <tt>get_allocator().allocate(1)</tt> to a
built-in pointer of type <tt>value_type*</tt> and only deal with the built-in
pointer until it needs to deallocate it again, but that removes most
of the benefit of allowing allocators to use custom pointer types.
</p>

<p><i>[2014-06-12, Jonathan comments]</i></p>

<p>
This issue is basically the same issue as LWG <a href="lwg-active.html#1521">1521</a>, which agrees it's an issue, 
to be dealt with in the future, so I request that <a href="lwg-active.html#2261">2261</a> not be closed as a dup 
unless we reopen <a href="lwg-active.html#1521">1521</a>.
</p>

<p><i>[2016-08, Zhihao comments]</i></p>

<p>The <tt>pointer</tt> types are not exposed in the container interface,
and we consider that the memory allocation constraints
"all containers defined in this clause obtain memory using an
allocator" already implies the reasonable expectation.  We
propose the fix as non-normative.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Tues PM: General agreement on direction, Alisdair and Billy to update wording</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<p><i>[Drafting notes: if people prefer this to be normative, strip
the "Note" markups.]</i></p>


<p>Modify 23.2.1/8 [container.requirements.general] as indicated:</p>

<blockquote><p>
Unless otherwise specified, all containers defined in this clause obtain
memory using an allocator<ins> [Note: The containers and their iterators
access the memory allocated by such an allocator only through objects of
type <tt>_P_</tt> or <tt>pointer_traits&lt;_P_>::rebind&lt;<i>unspecified</i>&gt;</tt>, where
<tt>_P_</tt> is <tt>allocator_traits&lt;allocator_type&gt;::pointer</tt>.
--end note]</ins> (see 17.6.3.5).
</p></blockquote>





<hr>
<h3><a name="2262" href="#2262">2262.</a> Requirement for <tt>unique_ptr&lt;T&gt;::get_deleter()(p)</tt> to be able to destroy the <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.11.1.2 [unique.ptr.single] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rob Desbois <b>Opened:</b> 2013-05-15 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3337 20.11.1.2.5 [unique.ptr.single.modifiers] contains 2 non-normative notes stating:
</p>

<blockquote>
<p>
[para 4]: &quot;The order of these operations is significant because the call to <tt>get_deleter()</tt> 
may destroy <tt>*this</tt>.&quot;
</p>
<p>
[para 5]: &quot;The postcondition does not hold if the call to <tt>get_deleter()</tt> destroys <tt>*this</tt> since 
<tt>this->get()</tt> is no longer a valid expression.&quot;
</p>
</blockquote>

<p>
It seems this wording was created to resolve <a href="lwg-defects.html#998">998</a> due to the possibility that a <tt>unique_ptr</tt> may be 
destroyed through deletion of its stored pointer where that directly or indirectly refers to the same <tt>unique_ptr</tt>. 
If <tt>unique_ptr</tt> is required to support circular references then it seems this must be normative text: an implementation 
is currently allowed to operate on <tt>*this</tt> after the assignment and deletion specified in para 4, since this is only 
'disallowed' by the non-normative note.
</p>

<p>I propose the following draft rewording:</p>

<p>
[para 4]: <i>Effects</i>: assigns <tt>p</tt> to the stored pointer, and then if the old value of the stored pointer, <tt>old_p</tt>, was not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(old_p)</tt>. <ins>No operation shall be performed after the call to 
<tt>get_deleter()(old_p)</tt> that requires <tt>*this</tt> to be valid, because the deletion may destroy <tt>*this</tt> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <tt>get_deleter()</tt> may destroy <tt>*this</tt>. &mdash; <i>end note</i>]</del>
<p/>
[para 5]: <i>Postconditions</i>: <ins>If the call <tt>get_deleter()(old_p)</tt> destroyed <tt>*this</tt>, none. Otherwise,</ins> 
<tt>get() == p</tt>. <del>[<i>Note:</i> The postcondition does not hold if the call to <tt>get_deleter()</tt>
destroys <tt>*this</tt> since <tt>this->get()</tt> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>

<p>
I expect it will also be necessary to amend the requirements for a deleter, so in addition:
</p>

<p>
20.11.1.2 [unique.ptr.single] [para 1]: The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <tt>D</tt> is not an lvalue reference type, <tt>d(ptr)</tt> shall be valid if <tt>ptr</tt> 
refers directly or indirectly to the invoking <tt>unique_ptr</tt> object.</ins>
</p>

<p><i>[2013-10-05, Stephan T. Lavavej comments and provides alternative wording]</i></p>

<p>
In Chicago, we determined that the original proposed change to 20.11.1.2 [unique.ptr.single]/1 was insufficient, because 
<tt>d</tt> might be a reference to a deleter functor that's destroyed during self-destruction.
<p/>
We believed that 20.11.1.2.5 [unique.ptr.single.modifiers]/4 was already sufficiently clear. The Standard occasionally prevents 
implementations of <tt>X</tt> from doing various things, through the principle of "nothing allows <tt>X</tt> to fail in that situation".  
For example, <tt>v.push_back(v[0])</tt> is required to work for non-empty vectors because nothing allows that to fail. In this case, 
the intent to allow self-destruction is already clear.
<p/>
Additionally, we did not believe that 20.11.1.2.5 [unique.ptr.single.modifiers]/5 had to be changed. The current note is slightly 
squirrely but it does not lead to confusion for implementers or users.
</p>

<p>
Previous resolution from Rob Desbois:
</p>
<blockquote class="note">
<ol>
<li>
<p>
Edit 20.11.1.2 [unique.ptr.single] p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <tt>D</tt> is not an lvalue reference type, <tt>d(ptr)</tt> shall be valid if <tt>ptr</tt> 
refers directly or indirectly to the invoking <tt>unique_ptr</tt> object.</ins>
</p></blockquote>
</li>

<li>
<p>
Edit 20.11.1.2.5 [unique.ptr.single.modifiers] p4+5 as indicated:
</p>
<blockquote><pre>
void reset(pointer p = pointer()) noexcept;
</pre><blockquote>
<p>
-3- <i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well formed, shall have well-defined behavior,
and shall not throw exceptions.
<p/>
-4- <i>Effects:</i> assigns <tt>p</tt> to the stored pointer, and then if the old value of the stored pointer, <tt>old_p</tt>, was not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(old_p)</tt>. <ins>No operation shall be performed after the call to 
<tt>get_deleter()(old_p)</tt> that requires <tt>*this</tt> to be valid, because the deletion may destroy <tt>*this</tt> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <tt>get_deleter()</tt> may destroy <tt>*this</tt>. &mdash; <i>end note</i>]</del>
<p/>
-5- <i>Postconditions:</i> <ins>If the call <tt>get_deleter()(old_p)</tt> destroyed <tt>*this</tt>, none. Otherwise,</ins> 
<tt>get() == p</tt>. <del>[<i>Note:</i> The postcondition does not hold if the call to <tt>get_deleter()</tt>
destroys <tt>*this</tt> since <tt>this->get()</tt> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>
</blockquote></blockquote>
</li>
</ol>

</blockquote>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li>
<p>
Edit 20.11.1.2 [unique.ptr.single] p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins><tt>d(ptr)</tt> shall be valid even if it triggers the destruction of <tt>d</tt> or (if 
<tt>D</tt> is an lvalue reference to function object type) the function object that <tt>d</tt> refers to.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05, Lenexa]</i></p>

<p>
After some discussion in Lenexa there was some wavering on if the added sentence is necessary. Here is example code that 
demonstrates why the extra sentence is necessary. In this example the call to <tt>d(ptr)</tt> is valid, however the deleter 
references <tt>*this</tt> after destructing its element:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

class Deleter
{
    int state_ = 0;

    enum
    {
        destructed            = -4,
        self_move_assigned    = -3,
        move_assigned_from    = -2,
        move_constructed_from = -1
    };
public:
    ~Deleter() {state_ = destructed;}

    Deleter() = default;
    Deleter(Deleter const&amp;) = default;
    Deleter&amp; operator=(Deleter const&amp;) = default;

    Deleter(Deleter&amp;&amp; a) noexcept
        : state_(a.state_)
    {a.state_ = move_constructed_from;}

    Deleter&amp; operator=(Deleter&amp;&amp; a) noexcept
    {
        if (this == &amp;a)
            state_ = self_move_assigned;
        else
        {
            state_ = a.state_;
            a.state_ = move_assigned_from;
        }
        return *this;
    }

    Deleter(int state)
        : state_(state)
    {
        assert(state &gt;= 0);
    }

    template &lt;class T&gt;
    void
    operator()(T* t) const
    {
        std::cout &lt;&lt; "Deleter beginning operator()(T*)\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter about to destruct the X.\n";
        delete t;
        std::cout &lt;&lt; "Deleter has destructed the X.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter ending operator()(T*)\n";
    }

    friend
    std::ostream&amp;
    operator&lt;&lt;(std::ostream&amp; os, const Deleter&amp; a)
    {
        switch (a.state_)
        {
        case destructed:
            os &lt;&lt; "**destructed**";
            break;
        case self_move_assigned:
            os &lt;&lt; "self_move_assigned";
            break;
        case move_assigned_from:
            os &lt;&lt; "move_assigned_from";
            break;
        case move_constructed_from:
            os &lt;&lt; "move_constructed_from";
            break;
        default:
            os &lt;&lt; a.state_;
            break;
        }
        return os;
    }
};

struct X
{
    Deleter deleter_{1};
};

int main()
{
    auto xp = new X;
    {
        std::unique_ptr&lt;X, Deleter&amp;&gt; p(xp, xp-&gt;deleter_);
        std::cout &lt;&lt; "unique_ptr is constructed.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; p.get_deleter() &lt;&lt; '\n';
        std::cout &lt;&lt; "Destructing unique_ptr...\n";
    }
    std::cout &lt;&lt; "unique_ptr is destructed.\n";
}
</pre></blockquote>
<p>
Which outputs:
</p>
<blockquote>
<pre>
unique_ptr is constructed.
The deleter = 1
Destructing unique_ptr...
Deleter beginning operator()(T*)
The deleter = 1
Deleter about to destruct the X.
Deleter has destructed the X.
The deleter = **destructed**
Deleter ending operator()(T*)
unique_ptr is destructed.
</pre>
</blockquote>
<p>
The line "<tt>The deleter = **destructed**</tt>" represents the deleter referencing itself after it has been destructed by the 
<tt>d(ptr)</tt> expression, but prior to that call returning.
<p/>
Suggested alternative to the current proposed wording:
</p>
<blockquote>
<p>
The expression <tt>d(ptr)</tt> shall not refer to the object <tt>d</tt> after it executes <tt>ptr-&gt;~T()</tt>.
</p>
</blockquote>

<p><i>[2015-07, Telecom]</i></p>

<p>
Geoffrey: Deleter may or may not execute ~T().<br/>
Alisdair: After the destructor after the element has run. Say it in words instead of code. <br/>
Howard will provide updated wording. Perhaps need both normative and non-normative wording.<br/>
</p>

<p><i>[2015-08-03, Howard updates P/R per telecon discussion.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li>
<p>
Edit 20.11.1.2 [unique.ptr.single] p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.9), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>The expression <tt>d(ptr)</tt>, if it destructs the object referred to by <tt>ptr</tt>,
shall not refer to the object <tt>d</tt> after it destructs <tt>*ptr</tt>.
[<i>Note:</i> The object being destructed may control the lifetime of <tt>d</tt>. &mdash; <i>end note</i>]</ins>
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2265" href="#2265">2265.</a> 29.3p9 appears to rule out some acceptable executions</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Brian Demsky <b>Opened:</b> 2013-06-17 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe that the following variation on IRIW should admit executions in
which <tt>c1 = d1 = 5</tt> and <tt>c2 = d2 = 0</tt>.  If this is allowed, then what is sequence of
program evaluations for 29.3 [atomics.order] p9 that justifies the store to <tt>z</tt>?  It seems that
29.3 [atomics.order] p9 should not allow this execution because one of the stores to <tt>x</tt> or <tt>y</tt> has
to appear earlier in the sequence, each of the <tt>fetch_adds</tt> reads the previous load in the thread (and thus must 
appear later in the sequence), and 29.3 [atomics.order] p9 states that each load must read from the last prior 
assignment in the sequence.
</p>

<blockquote><pre>
atomic_int x;
atomic_int y;
atomic_int z;
int c1, c2, d1, d2;

static void a(void* obj)
{
  atomic_store_explicit(&amp;x, 5, memory_order_relaxed); 
}

static void b(void* obj)
{
  atomic_store_explicit(&amp;y, 5, memory_order_relaxed); 
}

static void c(void* obj)
{
  c1 = atomic_load_explicit(&amp;x, memory_order_relaxed);
  // this could also be an atomic load if the address depends on c1:
  c2 = atomic_fetch_add_explicit(&amp;y, c1, memory_order_relaxed);  
}

static void d(void* obj)
{
  d1 = atomic_load_explicit(&amp;y, memory_order_relaxed);
  d2 = atomic_fetch_add_explicit(&amp;x, d1, memory_order_relaxed); 
}

int user_main(int argc, char** argv)
{
  thrd_t t1, t2, t3, t4;

  atomic_init(&amp;x, 0);
  atomic_init(&amp;y, 0);

  printf("Main thread: creating 4 threads\n");
  thrd_create(&amp;t1, (thrd_start_t)&amp;a, NULL);
  thrd_create(&amp;t2, (thrd_start_t)&amp;b, NULL);
  thrd_create(&amp;t3, (thrd_start_t)&amp;c, NULL);
  thrd_create(&amp;t4, (thrd_start_t)&amp;d, NULL);

  thrd_join(t1);
  thrd_join(t2);
  thrd_join(t3);
  thrd_join(t4);
  printf("c1=%d c2=%d\n",c1,c2);
  printf("d1=%d d2=%d\n",d1,d2);

  // Can this store write 1000 (i.e., c1=d1=5, c2=d2=0)?
  atomic_store(&amp;z, (c1+d1)*100+c2+d2);

  printf("Main thread is finished\n");

  return 0;
}
</pre></blockquote>

<p>
It seems that the easiest fix is to allow a load in 29.3 [atomics.order] p9 to read from any prior
store in the evaluation order.
<p/>
That said, I would personally advocate the following:
It seems to me that C/C++ atomics are in a bit of different situation than Java
because:
</p>
<ol>
<li><p>People are expected to use relaxed C++ atomics in potentially racy
situations, so it isn't clear that semantics as complicated as the JMM's
causality would be sane.
</p></li>
<li><p>People who use C/C++ atomics are likely to be experts and use them in a
very controlled fashion. I would be really surprised if compilers would find
any real wins by optimizing the use of atomics.
</p></li>
</ol>
<p>
Why not do something like:
<p/>
There is satisfaction DAG of all program evaluations. Each evaluation
observes the values of variables as computed by some prior assignment in
the DAG.
<p/>
There is an edge <tt>x-&gt;y</tt> between two evaluations <tt>x</tt> and <tt>y</tt> if:
</p>
<ol>
<li><p>the evaluation <tt>y</tt> observes a value computed by the evaluation <tt>x</tt> or
</p></li>
<li><p>the evaluation <tt>y</tt> is an atomic store, the evaluation <tt>x</tt> is an atomic load, and
there is a condition branch c that may depend (intrathread dependence) on <tt>x</tt>
and <tt>x-sb-&gt;c</tt> and <tt>c-sb-&gt;y</tt>.
</p></li>
</ol>
<p>
This seems to allow reordering of relaxed atomics that processors do without
extra fence instructions, allows most reorderings by the compiler, and gets
rid of satisfaction cycles.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
This was partially addressed (weasel-worded) in C++14 (See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3786.htm">N3786</a>).
The remainder is an open research problem.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3710.html">N3710</a> outlines a "solution" that doesn't have a consensus behind it because it costs performance.  We have no better solution at the moment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2267" href="#2267">2267.</a> <tt>partial_sort_copy</tt> underspecified for ranges of two different types</h3>
<p><b>Section:</b> 25.5.1.4 [partial.sort.copy] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern  <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of this function is:
</p>

<blockquote><pre>
template&lt;class InputIterator, class RandomAccessIterator&gt;
RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
                  RandomAccessIterator result_first,
                  RandomAccessIterator result_last);

</pre></blockquote>

<p>
(and the usual overload for an explicitly provided comparison function). The standard says nothing about requirements 
in the case where the input type (<tt>iterator_traits&lt;InputIterator&gt;::value_type</tt>) and the output type 
(<tt>iterator_traits&lt;RandomAccessIterator&gt;::value_type</tt>) are different.
<p/>
Presumably the input type must be convertible to the output type. What's less clear is what the requirements are on 
the comparison operator. Does the algorithm only perform comparisons on two values of the output type, or does it also 
perform comparisons on values of the input type, or might it even perform heterogeneous comparisons?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2269" href="#2269">2269.</a> Container iterators and argument-dependent lookup</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code snippet:
</p>

<blockquote><pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
  std::vector&lt;int&gt; v1(100, 3);
  std::vector&lt;int&gt; v2(100);
  copy(v1.begin(), v1.end(), v2.begin());
}
</pre></blockquote>

<p>
It compiles without error on my desktop. Is it required to? I can't find evidence from the standard that it is. 
In my test <tt>std::copy</tt> was found by argument-dependent lookup because the implementation I used made 
<tt>std::vector&lt;int&gt;::iterator</tt> a user-defined type defined in namespace <tt>std</tt>. But the standard 
only requires <tt>std::vector&lt;int&gt;::iterator</tt> to be an implementation specified random access iterator 
type. I can't find anything requiring it to be a user-defined type at all (and in fact there are reasonable implementation 
where it isn't), let alone a user defined type defined in a specific namespace.
</p>

<p>
Since the defining namespace of container iterators is visible to users, should the standard say anything about what 
that namespace is?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2286" href="#2286">2286.</a> <tt>stringbuf::underflow()</tt> underspecified</h3>
<p><b>Section:</b> 27.8.2.4 [stringbuf.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-08-29 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 27.8.2.4 [stringbuf.virtuals]/1, <tt>basic_stringbuf::underflow()</tt> is specified to unconditionally 
return <tt>traits::eof()</tt> when a read position is not available.
<p/>
The semantics of <tt>basic_stringbuf</tt> require, and existing libraries implement it so that this function makes 
a read position available if possible to do so, e.g. if some characters were inserted into the stream since the 
last call to <tt>overflow()</tt>, resulting in <tt>pptr() &gt; egptr()</tt>. Compare to the conceptually similar 
D.5.1.3 [depr.strstreambuf.virtuals]/15.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>

<li><p>Change 27.8.2.4 [stringbuf.virtuals] as indicated:</p>

<blockquote>
<pre>
int_type underflow();
</pre><blockquote>
<p>
-1- <i>Returns:</i> If the input sequence has a read position available <ins>or the function makes a read position available 
(as described below)</ins>, returns <tt>traits::to_int_type(*gptr())</tt>. Otherwise, returns <tt>traits::eof()</tt>. Any 
character in the underlying buffer which has been initialized is considered to be part of the input sequence.
<p/>
<ins>-?- The function can make a read position available only if <tt>(mode &amp; ios_base::in) != 0</tt> and if the write 
next pointer <tt>pptr()</tt> is not null and is greater than the current read end pointer <tt>egptr()</tt>. To make a read 
position available, the function alters the read end pointer <tt>egptr()</tt> to equal <tt>pptr()</tt>.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2289" href="#2289">2289.</a> <tt>constexpr</tt> guarantees of defaulted functions still insufficient</h3>
<p><b>Section:</b> 20.4.2 [pairs.pair], 20.5.2.1 [tuple.cnstr], 20.17.5 [time.duration] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-09 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a> and
some similar <tt>constexpr</tt> papers, specific wording was added to <tt>pair</tt>, <tt>tuple</tt>, and other templates
that were intended to impose implementation constraints that ensure that the observable <tt>constexpr</tt> "character"
of a defaulted function template is solely determined by the required expressions of the user-provided types when instantiated,
for example:
</p>

<blockquote><p>
The defaulted move and copy constructor, respectively, of pair shall be a <tt>constexpr</tt> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function.
</p></blockquote>

<p>
This wording doesn't require enough, especially since the core language via CWG 1358 does now support <tt>constexpr</tt>
function template instantiations, even if such function cannot appear in a constant expression (as specified in 5.20 [expr.const]) 
or as a constant initializer of that object (as specified in  [basic.start.init]). The wording should be 
improved and should require valid uses in constant expressions and as constant initializers instead.
</p>

<p><i>[Lenexa 2015-05-05]</i></p>

<p>STL : notice order of move/copy and copy/move with "respectively".</p>
<p>General word-smithing; ask for updated wording</p>
<p>Are we happy with this with changes we are suggesting?</p>
<p>unanimous</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 20.4.2 [pairs.pair] p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of pair shall be a <tt>constexpr</tt> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function</del><ins>An invocation of the move or copy constructor of <tt>pair</tt> shall be a constant expression 
(5.20 [expr.const]) if all required element-wise initializations would be constant expressions. An invocation of the 
move or copy constructor of <tt>pair</tt> shall be a constant initializer for that <tt>pair</tt> object ( [basic.start.init])
if all required element-wise initializations would be constant initializers for the respective subobjects</ins>.
</p>
</blockquote>
</li>

<li><p>Change 20.5.2.1 [tuple.cnstr] p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of <tt>tuple</tt> shall be a <tt>constexpr</tt> function if 
and only if all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function. The defaulted move and copy constructor of <tt>tuple&lt;&gt;</tt> shall be <tt>constexpr</tt> 
functions</del><ins>An invocation of the move or copy constructor of <tt>tuple</tt> shall be a constant expression (5.20 [expr.const])
if all required element-wise initializations would be constant expressions. An invocation of the move or copy constructor of 
<tt>tuple</tt> shall be a constant initializer for that <tt>tuple</tt> object ( [basic.start.init]) if all 
required element-wise initializations would be constant initializers for the respective subobjects. An invocation of the 
move or copy constructor of <tt>tuple&lt;&gt;</tt> shall be a constant expression, or a constant initializer for that 
<tt>tuple&lt;&gt;</tt> object, respectively, if the function argument would be constant expression</ins>.
</p>
</blockquote>
</li>

<li><p>Change 20.17.5 [time.duration] p7 as indicated:</p>

<blockquote>
<p>
-7- <i>Remarks:</i> <del>The defaulted copy constructor of duration shall be a <tt>constexpr</tt> function if and only if
the required initialization of the member <tt>rep_</tt> for copy and move, respectively, would satisfy the
requirements for a <tt>constexpr</tt> function.</del><ins>An invocation of the copy constructor of <tt>duration</tt> shall 
be a constant expression (5.20 [expr.const]) if the required initialization of the member <tt>rep_</tt> would be a constant expression.
An invocation of the copy constructor of <tt>duration</tt> shall be a constant initializer for that <tt>duration</tt> object 
( [basic.start.init]) if the required initialization of the member <tt>rep_</tt> would be constant initializers 
for this subobject</ins>.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2290" href="#2290">2290.</a> Top-level "SFINAE"-based constraints should get a separate definition in Clause 17</h3>
<p><b>Section:</b> 20.15 [meta] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-02 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library specification uses at several places wording that is intended to refer to
core language template deduction failure at the top-level of expressions (aka "SFINAE"), for example:
</p>

<blockquote><p>
The expression <tt>declval&lt;T&gt;() = declval&lt;U&gt;()</tt> is well-formed when treated as an unevaluated operand (Clause 5). 
Access checking is performed as if in a context unrelated to <tt>T</tt> and <tt>U</tt>. Only the validity of the immediate context 
of the assignment expression is considered. [<i>Note:</i> The compilation of the expression can result in side effects 
such as the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result in the program
being ill-formed. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Similar wording can be found in the specification of <tt>result_of</tt>, <tt>is_constructible</tt>, and <tt>is_convertible</tt>,
being added to resolve an NB comment by LWG <a href="lwg-defects.html#1390">1390</a> and <a href="lwg-defects.html#1391">1391</a> through 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">N3142</a>.
<p/>
This wording is necessary to limit speculative compilations needed to implement these traits, but it is also lengthy and repetitive.
</p>

<p><i>[2014-05-19, Daniel suggests a descriptive term]</i></p>

<p>
<b>constrictedly well-formed expression</b>:
<p/>
An expression <em>e</em> depending on a set of types <tt>A1</tt>, ..., <tt>An</tt> which is well-formed when treated as 
an unevaluated operand (Clause 5). Access checking is performed as if in a context unrelated to <tt>A1</tt>, ..., 
<tt>An</tt>. Only the validity of the immediate context of <em>e</em> is considered. [<i>Note:</i> The compilation of 
the expression can result in side effects such as the instantiation of class template specializations and function 
template specializations, the generation of implicitly-defined functions, and so on. Such side effects are not in the 
"immediate context" and can result in the program being ill-formed. &mdash; <i>end note</i>]
</p>

<p><i>[2014-05-20, Richard and Jonathan suggest better terms]</i></p>

<p>
Richard suggested "locally well-formed"
<p/>
Jonathan suggested "contextually well-formed" and then "The expression ... is valid in a contrived argument
deduction context"
</p>

<p><i>[2014-06-07, Daniel comments and improves wording]</i></p>

<p>
The 2014-05-19 suggestion did only apply to expressions, but there are two important examples that are not expressions, but instead
are involving an <em>object definition</em> (<tt>std::is_constructible</tt>) and a <em>function definition</em> 
(<tt>std::is_convertible</tt>), respectively, instead. Therefore I suggest to rephrase the usage of "expression" into "program 
construct" in the definition of Jonathan's suggestion of "valid in a contrived argument deduction context".
<p/>
I would like to point out that given the new definition of "valid in a contrived argument deduction context", there are several other 
places of the Library specification that could take advantage of this wording to improve the existing specification, such as 
20.14.12.2 [func.wrap.func] p2, most functions in 20.10.8.2 [allocator.traits.members], and the <tt>**Insertable</tt>, 
<tt>EmplaceConstructible</tt>, and <tt>Erasable</tt> definitions in 23.2.1 [container.requirements.general], but given that
these are not fully described in terms of the aforementioned wording <em>yet</em>, I would recommend to fix them by a separate issue 
once the committee has agreed on following the suggestion presented by this issue.
</p>

<p><i>[2015-05-05 Lenexa: Move to Open]</i></p>

<p>...</p>
<p>MC: I think we like the direction but it isn't quite right: it needs some work</p>
<p>JW: I'm prepared to volunteer to move that further, hopefully with the help of Daniel</p>
<p>Roger Orr: should this be Core wording because it doesn't really have anything to do with libraries - the term could then just be used here</p>
<p>AM: Core has nothing to deal with that, though</p>
<p>HT: it seems there is nothing to imply that allows dropping out with an error - maybe that's a separate issue</p>
<p>MC: I'm not getting what you are getting at: could you write an issue? - any objection to move to Open?</p>
<p>...</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Add the following new definition to 17.3 [definitions] as indicated:</p>

<p>
<ins><b>valid in a contrived argument deduction context</b> [defns.valid.contr.context]</ins>
<p/>
<ins>A program construct <em>c</em> depending on a set of types <tt>A1</tt>, ..., <tt>An</tt>, and treated as 
an unevaluated operand (Clause 5) when <em>c</em> is an expression, which is well-formed. 
Access checking is performed as if in a context unrelated to <tt>A1</tt>, ..., <tt>An</tt>. 
Only the validity of the immediate context (14.8.2 [temp.deduct]) of <em>c</em> is considered. 
[<i>Note:</i> The compilation of <em>c</em> can result in side effects such as the instantiation of class template 
specializations and function template specializations, the generation of implicitly-defined functions, and so on. 
Such side effects are not in the "immediate context" and can result in the program being ill-formed. &mdash; 
<i>end note</i>].</ins>
</p>
</li>

<li><p>Change Table 49 ("Type property predicates") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 49 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T, class U&gt;<br/>
struct is_assignable;</tt>
</td>

<td>
The expression
<tt>declval&lt;T&gt;() =<br/>
declval&lt;U&gt;()</tt> is <ins>valid in a<br/>
contrived argument deduction context<br/>
([defns.valid.contr.context]) for types<br/>
<tt>T</tt> and <tt>U</tt>.</ins>
<del>well-formed when treated<br/>
as an unevaluated operand<br/>
(Clause 5). Access<br/>
checking is performed as if<br/>
in a context unrelated to <tt>T</tt><br/>
and <tt>U</tt>. Only the validity of<br/>
the immediate context of<br/>
the assignment expression<br/>
is considered. [<i>Note</i>: The<br/>
compilation of the<br/>
expression can result in<br/>
side effects such as the<br/>
instantiation of class<br/>
template specializations<br/>
and function template<br/>
specializations, the<br/>
generation of<br/>
implicitly-defined<br/>
functions, and so on. Such<br/>
side effects are not in the<br/>
"immediate context" and<br/>
can result in the program<br/>
being ill-formed. &mdash; end<br/>
note]</del>
</td>

<td align="center">
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 20.15.4.3 [meta.unary.prop] p7 as indicated:</p>

<blockquote><p>
-7- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_constructible&lt;T, Args...&gt;</tt> shall be satisfied
if and only if the following variable definition <del>would be well-formed</del> for some invented 
variable <tt>t</tt> <ins>would be valid in a contrived argument deduction context ([defns.valid.contr.context]) for 
types <tt>T</tt> and <tt>Args...</tt></ins>:
</p>
<blockquote><pre>
T t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
[<i>Note</i>: These tokens are never interpreted as a function declaration. &mdash; <i>end note</i>] <del>Access checking is
performed as if in a context unrelated to <tt>T</tt> and any of the <tt>Args</tt>. Only the validity of the immediate context
of the variable initialization is considered. [<i>Note</i>: The evaluation of the initialization can result in side
effects such as the instantiation of class template specializations and function template specializations, the
generation of implicitly-defined functions, and so on. Such side effects are not in the "immediate context"
and can result in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

<li><p>Change Table 57 ("Other transformations") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class... ArgTypes&gt;<br/>
struct result_of&lt;Fn(ArgTypes...)&gt;;</tt>
</td>

<td align="center">
[&hellip;]
</td>

<td>
If the expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...)</tt> is<br/>
<ins>valid in a contrived argument deduction<br/>
context ([defns.valid.contr.context]) for types<br/>
<tt>Fn</tt> and <tt>ArgTypes...</tt></ins>
<del>well<br/>
formed when treated as an<br/>
unevaluated operand (Clause 5)</del>, the<br/>
member typedef type shall name the<br/>
type<br/>
<tt>decltype(<i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...))</tt>;<br/>
otherwise, there shall be no member<br/>
type. <del>Access checking is performed as<br/>
if in a context unrelated to <tt>Fn</tt> and<br/>
<tt>ArgTypes</tt>. Only the validity of the<br/>
immediate context of the expression is<br/>
considered. [<i>Note</i>: The compilation of<br/>
the expression can result in side<br/>
effects such as the instantiation of<br/>
class template specializations and<br/>
function template specializations, the<br/>
generation of implicitly-defined<br/>
functions, and so on. Such side effects<br/>
are not in the "immediate context"<br/>
and can result in the program being<br/>
ill-formed. &mdash; <i>end note</i>]</del>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 20.15.6 [meta.rel] p4 as indicated:</p>

<blockquote><p>
-4- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied if and
only if the return expression in the following code would be <del>well-formed</del><ins>valid in a contrived argument 
deduction context ([defns.valid.contr.context]) for types <tt>To</tt> and <tt>From</tt></ins>, including any implicit conversions
to the return type of the function:
</p>
<blockquote><pre>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
<p>
[<i>Note</i>: This requirement gives well defined results for reference types, <tt>void</tt> types, array types, and
function types. &mdash; <i>end note</i>] <del>Access checking is performed as if in a context unrelated to <tt>To</tt> 
and <tt>From</tt>. Only the validity of the immediate context of the expression of the return-statement (including conversions to
the return type) is considered. [<i>Note</i>: The evaluation of the conversion can result in side effects such as
the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result
in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2292" href="#2292">2292.</a> Find a better phrasing for "shall not participate in overload resolution"</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-09-03 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 CD has 25 sections including the phrase "X shall not
participate in overload resolution ...". Most of these uses are double
negatives, which are hard to interpret. "shall not ... unless" tends
to be the easiest to read, since the condition is true when the
function is available, but we also have a lot of "if X is not Y, then
Z shall not participate", which actually means "You can call Z if X is
Y." The current wording is also clumsy and long-winded. We should find
a better and more concise phrasing.
<p/>
As an initial proposal, I'd suggest using "X is enabled if and only if Y" in prose
and adding an "<i>Enabled If:</i> ..." element to 17.5.1.4 [structure.specifications].
<p/>
Daniel:
<p/>
I suggest to name this new specification element for 17.5.1.4 [structure.specifications]
as "<i>Template Constraints:</i>" instead, because the mentioned wording form was intentionally provided 
starting with LWG <a href="lwg-defects.html#1237">1237</a> to give implementations more freedom to realize the 
concrete constraints. Instead of the original <tt>std::enable_if</tt>-based specifications
we can use better forms of "SFINAE" constraints today and it eases the path to possible language-based
constraints in the future.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2295" href="#2295">2295.</a> Locale name when the provided <tt>Facet</tt> is a <tt>nullptr</tt></h3>
<p><b>Section:</b> 22.3.1.2 [locale.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-09-04 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.3.1.2 [locale.cons] p14 ends with:
</p>
<blockquote><p>
"[&hellip;] If <tt>f</tt> is null, the resulting object is a copy of <tt>other</tt>."
</p></blockquote>
<p>
but the next line p15 says: 
</p>
<blockquote><p>
"<i>Remarks:</i> The resulting locale has no name."
</p></blockquote>
<p>
But both can't be true when <tt>other</tt> has a name and <tt>f</tt> is null.
<p/>
I've tried it on two implementations (MSVC,GCC) and they are inconsistent with each other on this.
</p>
<p>
Daniel Kr&uuml;gler:
<p/>
As currently written, the <i>Remarks</i> element applies unconditionally for all cases and thus should
"win". The question arises whether the introduction of this element by LWG <a href="lwg-closed.html#424">424</a> had actually intended
to change the previous <i>Note</i> to a <i>Remarks</i> element. In either case the wording should be improved
to clarify this special case.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2303" href="#2303">2303.</a> Explicit instantiation of <tt>std::vector&lt;UserType&gt;</tt> broken?</h3>
<p><b>Section:</b> 18.6.2.3 [new.delete.placement] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-18 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library gives explicit permission in 17.6.4.2.1 [namespace.std] p2 that user code may explicitly instantiate
a library template provided that the instantiations depend on at least one user-defined type:
</p>

<blockquote><p>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a user-defined type and the instantiation meets the standard library requirements
for the original template.
</p></blockquote>

<p>
But it seems that the C++11 library is not specified in a way that guarantees such an instantiation to be well-formed
if the minimum requirements of the library is not satisfied. 
<p/>
For example, in general, the first template parameter of <tt>std::vector</tt> is not required to be 
<tt>DefaultConstructible</tt> in general, but due to the split of the single C++03 member function
with default argument
</p>
<blockquote><pre>
void resize(size_type sz, T c = T());
</pre></blockquote>
<p>
into
</p>
<blockquote><pre>
void resize(size_type sz);
void resize(size_type sz, const T&amp; c);
</pre></blockquote>
<p>
the effect is now that for a type <tt>ND</tt> that is not <tt>DefaultConstructible</tt>, such as
</p>
<blockquote><pre>
struct NP { 
  NP(int); 
};
</pre></blockquote>
<p>
the explicit instantiation of <tt>std::vector&lt;ND&gt;</tt> is no longer well-formed, because the attempt to
instantiate the single-argument overload of <tt>resize</tt> cannot not succeed, because this function imposes
the <tt>DefaultInsertable</tt> requirements and given the default allocator this effectively requires
<tt>DefaultConstructible</tt>.
</p>
<p>
But <tt>DefaultConstructible</tt> is not the only point, what about <tt>CopyConstructible</tt> versus
<tt>MoveConstructible</tt> alone? It turns out that currently the second <tt>resize</tt> overload
would fail during an explicit instantiation for a type like
</p>
<blockquote><pre>
struct MO { 
  MO() = default; 
  MO(MO&amp;&amp;) = default; 
};
</pre></blockquote>
<p>
because it imposes <tt>CopyInsertable</tt> requirements that end up being equivalent to the <tt>CopyConstructible</tt>
requirements for the default allocator.
<p/>
Technically a library can solve these issues: For special member functions by defining them in some base class, for others
by transforming them effectively into a function template due to the great feature of default template arguments for
function templates (At the very moment the validity of the latter approach depends on a resolution of core language issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1635">CWG 1635</a>, though). E.g. the here mentioned 
<tt>resize</tt> functions of <tt>std::vector</tt> could be prevented from instantiation by defining them like this 
with an implementation:
</p>
<blockquote><pre>
template&lt;class = void&gt;
void resize(size_type sz) { [&hellip;] }
template&lt;class = void&gt;
void resize(size_type sz, const T&amp; c) { [&hellip;] }
</pre></blockquote>
<p>
In this case, these functions could also be defined in a base class, but the latter approach won't work in all cases.
<p/>
Basically such an implementation is required to constrain all member functions that are not covered by the general
requirements imposed on the actual library template parameters. I tested three different C++11 library implementations
and but none could instantiate for example <tt>std::list</tt>, <tt>std::vector</tt>, or <tt>std::deque</tt> with
value types that are not <tt>DefaultConstructible</tt> or only <tt>MoveConstructible</tt>. 
<p/>

<p/>
This issue is raised to clarify the current situation in regard to the actual requirements imposed on user-provided
types that are used to explicitly instantiate Library-provided templates. For example, the current Container requirements
impose very little requirements on the actual value type and it is unclear to which extend library implementations have
to respect that. 
<p/>
The minimum solution of this issue should be to at least realize that there is no fundamental requirement on 
<tt>DefaultConstructible</tt> for value types of library containers, because we have since C++03 the general
statement of 17.6.3.1 [utility.arg.requirements] ("In general, a default constructor is not required.").
It is unclear whether <tt>CopyConstructible</tt> should be required for an explicit instantiation request, but
given the careful introduction of move operations in the library it would seem astonishing that a
<tt>MoveConstructible</tt> type wouldn't suffice for value types of the container types.
<p/>
In any case I can envision at least two approaches to solve this issue:
</p>
<ol>
<li>
<p>
As indicated in LWG <a href="lwg-active.html#2292">2292</a>, those function could get an explicit "<i>Template Constraints:</i>"
element, albeit this promises more than needed to solve this issue.
</p>
</li>
<li>
<p>
The library could introduce a completely new element form, such as "<i>Instantiation Constraints:</i>" that
would handle this situation for explicit instantiation situations. This would allow for simpler techniques
to solve the issue when explicit instantiation is required compared to the first bullet, because it would not 
(necessarily) guarantee SFINAE-friendly expression-wellformedness, such as inspecting the expression 
<tt>std::declval&lt;std::vector&lt;ND&gt;&amp;&gt;.resize(0)</tt> in an unevaluated context.
</p>
</li>
</ol>

<p>
It should be noted that the 2013-08-27 comment to LWG <a href="lwg-defects.html#2193">2193</a> could be resolved by a similar solution
as indicated in this issue here.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2307" href="#2307">2307.</a> Should the Standard Library use <tt>explicit</tt> only when necessary?</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-09-26 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#2193">2193</a> yields <tt>explicit</tt> for default ctors to allow <tt>{}</tt>, but not for
all cases of uniform initialization. For example:
</p>
<blockquote><pre>
explicit vector(size_type count, const Allocator&amp; alloc = Allocator());
</pre></blockquote>
<p>
This prevents <tt>{n, alloc()}</tt>. Although this use is relatively rare,
but the behavior is inconsistent with that of
</p>
<blockquote><pre>
vector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());
</pre></blockquote>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2318" href="#2318">2318.</a> <tt>basic_string</tt>'s wording has confusing relics from the copy-on-write era</h3>
<p><b>Section:</b> 21.3.1 [basic.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.3.1.4 [string.capacity]/8 specifies <tt>basic_string::resize(n, c)</tt> with:
</p>
<blockquote><p>
<i>Effects:</i> Alters the length of the string designated by <tt>*this</tt> as follows:
</p>
<ul>
<li><p>
If <tt>n &lt;= size()</tt>, the function replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose 
elements are a copy of the initial elements of the original string designated by <tt>*this</tt>.
</p>
</li>
<li><p>
If <tt>n &gt; size()</tt>, the function replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose 
first <tt>size()</tt> elements are a copy of the original string designated by <tt>*this</tt>, and whose remaining elements are all 
initialized to <tt>c</tt>.
</p>
</li>
</ul>
</blockquote>
<p>
This wording is a relic of the copy-on-write era. In addition to being extremely confusing, it has undesirable implications.  
Saying "replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose elements are a copy" suggests 
that the trimming case can reallocate. Reallocation during trimming should be forbidden, like <tt>vector</tt>.
<p/>
At least 7 paragraphs are affected: 21.3.1.4 [string.capacity]/8, 21.3.1.6.2 [string::append]/9, 
21.3.1.6.3 [string::assign]/3 and /10, 21.3.1.6.4 [string::insert]/11, 21.3.1.6.5 [string::erase]/4, and 
21.3.1.6.6 [string::replace]/11 say "replaces the string [designated/controlled] by <tt>*this</tt>". (21.3.1.6.7 [string::copy]/3 
is different &mdash; it "replaces the string designated by <tt>s</tt>".)
<p/>
Of the affected paragraphs, <tt>resize()</tt> and <tt>erase()</tt> are the most important to fix because they should forbid 
reallocation during trimming.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2321" href="#2321">2321.</a> Moving containers should (usually) be required to preserve iterators</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2.1 [container.requirements.general]/10 says that unless otherwise specified, "no <tt>swap()</tt> function invalidates 
any references, pointers, or iterators referring to the elements of the containers being swapped. [<i>Note:</i> The <tt>end()</tt> 
iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]". However, move constructors and move 
assignment operators aren't given similar invalidation guarantees. The guarantees need several exceptions, so I do not believe 
that blanket language like /11 "Unless otherwise specified (either explicitly or by defining a function in terms of other functions), 
invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, 
or change the values of, objects within that container." is applicable.
</p>

<p><i>[2014-02-13 Issaquah]</i></p>

<p>
General agreeement on intent, several wording nits and additional paragraphs to hit.
</p>
<p>
STL to provide updated wording.  Move to Open.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
AM: in the proposed wording, I'd like to mention that the iterators now refer to elements of a different container. 
I think we're saying something like this somewhere. JY: There's some wording like that for swap I think. TK: It's also in 
<tt>list::splice()</tt>. DK to JY: 23.2.1p9.
<p/>
VV: The issue says that STL was going to propose new wording. Has he done that? AM: I believe we're looking at that. 
GR: The request touches on multiple paragraphs, and this PR has only one new paragraph, so this looks like it's not up-to-date. 
MC: This was last updated a year ago in Issaquah.
<p/>
<b>Conclusion</b>: Skip, not up to date. 
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>Still waiting for updated wording</p>

<p><i>[2015-08, Chicago]</i></p>

<p>Still waiting for updated wording</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.2.1 [container.requirements.general]/10 change as indicated:</p>

<blockquote><p>
-10- Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.7.5) all container types defined in this
Clause meet the following additional requirements:
</p>
<ul>
<li><p>
[&hellip;]
</p></li>
<li><p>
no copy constructor or assignment operator of a returned iterator throws an exception.
</p></li>
<li><p>
<ins>no move constructor (or move assignment operator when 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt> is true) of a container 
(except for <tt>array</tt>) invalidates any references, pointers, or iterators referring to the elements of the source container. 
[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]</ins>
</p></li>
<li><p>
no <tt>swap()</tt> function throws an exception.
</p></li>
<li><p>
no <tt>swap()</tt> function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped. [<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element, so it may be
invalidated. &mdash; <i>end note</i>]
</p></li>
</ul>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2331" href="#2331">2331.</a> <tt>regex_constants::collate</tt>'s effects are inaccurately summarized</h3>
<p><b>Section:</b> 28.5.1 [re.synopt] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.synopt">active issues</a> in [re.synopt].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table in 28.5.1 [re.synopt]/1 says that <tt>regex_constants::collate</tt> "Specifies that character ranges of the form 
"<tt>[a-b]</tt>" shall be locale sensitive.", but 28.13 [re.grammar]/14 says that it affects individual character comparisons 
too.
</p>

<p><i>[2012-02-12 Issaquah : recategorize as P3]</i></p>


<p>
Marshall Clow: 28.13/14 only applies to ECMAScript
</p>

<p>
All: we're unsure
</p>

<p>
Jonathan Wakely: we should ask John Maddock
</p>

<p>
Move to P3
</p>

<p><i>[2014-5-14, John Maddock response]</i></p>

<p>
The original intention was the original wording: namely that <tt>collate</tt> only made character ranges locale sensitive.  
To be frank it's a feature that's probably hardly ever used (though I have no real hard data on that), and is a leftover 
from early POSIX standards which <em>required</em> locale sensitive collation for character ranges, and then later changed 
to implementation defined if I remember correctly (basically nobody implemented locale-dependent collation).
<p/>
So I guess the question is do we gain anything by requiring all character-comparisons to go through the locale when this bit 
is set? Certainly it adds a great deal to the implementation effort (it's not what Boost.Regex has ever done). I guess the 
question is are differing code-points that collate identically an important use case? I guess there might be a few Unicode 
code points that do that, but I don't know how to go about verifying that.
<p/>
STL:
<p/>
If this was unintentional, then 28.5.1 [re.synopt]/1's table should be left alone, while 28.13 [re.grammar]/14 
should be changed instead.
<p/>
Jeffrey Yasskin:
<p/>
<a href="http://www.unicode.org/reports/tr18/tr18-13.html#Tailored_Loose_Matches">This page</a>
mentions that [V] in Swedish should match "W" in a perfect world.
<p/>
However, the most recent version of <a href="http://www.unicode.org/reports/tr18/#Tailored_Loose_Matches">TR18</a> retracts
both language-specific loose matches <em>and</em> language-specific ranges
because "for most full-featured regular expression engines, it is
quite difficult to match under code point equivalences that are not
1:1" and "tailored ranges can be quite difficult to implement
properly, and can have very unexpected results in practice. For
example, languages may also vary whether they consider lowercase below
uppercase or the reverse. This can have some surprising results: [a-Z]
may not match anything if <tt>Z &lt; a</tt> in that locale."
<p/>
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.15">ECMAScript</a> doesn't include collation at all.
<p/>
IMO, +1 to changing 28.13 instead of 28.5.1. It seems like we'd be on
fairly solid ground if we wanted to remove <tt>regex_constants::collate</tt>
entirely, in favor of named character classes, but of course that's
not for this issue.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 28.5.1 [re.synopt]/1, Table 138 &mdash; "<tt>syntax_option_type</tt> effects", change as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <tt>syntax_option_type</tt> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>collate</tt>
</td>
<td>
Specifies that character <del>ranges of the form "<tt>[a-b]</tt>"</del><ins>comparisons and character range comparisons</ins> 
shall be locale sensitive.
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2335" href="#2335">2335.</a> <tt>array&lt;array&lt;int, 3&gt;, 4&gt;</tt> should be layout-compatible with <tt>int[4][3]</tt></h3>
<p><b>Section:</b> 23.3.7 [array] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-10-04 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to replace some uses of C arrays with <tt>std::array</tt>, we need it
to be possible to cast from a <tt>std::array&lt;&gt;</tt> to an equivalent C array.
Core wording doesn't appear to be in quite the right state to allow
casting, but if we specify that appropriate types are
layout-compatible, we can at least write:
</p>
<blockquote><pre>
union {
  array&lt;array&lt;array&lt;int, 2&gt;, 3&gt;, 4&gt; arr;
  int carr[4][3][2];
};
</pre></blockquote>
<p>
to view memory as the other type: C++14 CD [class.mem]p18.
</p>
I believe it's sufficient to add "<tt>array&lt;T, N&gt;</tt> shall be
layout-compatible (3.9 [basic.types]) with <tt>T[N]</tt>." to 
23.3.7.1 [array.overview], but we might also need some extension to 
9.2 [class.mem] to address the possibility of layout-compatibility 
between struct and array types.
<p>
I checked that libc++ on MacOS already implements this, although it
would be good for someone else to double-check; I haven't checked any
other standard libraries.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2338" href="#2338">2338.</a> &sect;[re.traits]/7 expects of locale facets something not guaranteed by [locale.facet]/4</h3>
<p><b>Section:</b> 28.7 [re.traits], 22.3.1.1.2 [locale.facet] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-10-15 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.7 [re.traits]/7, begins with "if <tt>typeid(use_facet&lt;collate&lt;charT&gt; &gt;) == typeid(collate_byname&lt;charT&gt;)</tt>", 
which appears to be pseudocode with the intention to convey that the collate facet has not been replaced by the user. Cf. the wording in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">N1429</a> "there is no portable way to implement 
<tt>transform_primary</tt> in terms of <tt>std::locale</tt>, since even if the sort key format returned by 
<tt>std::collate_byname&lt;&gt;::transform</tt> is known and can be converted into a primary sort key, the user can still 
install their own custom <tt>std::collate</tt> implementation into the locale object used, and that can use any sort key 
format they see fit.".
<p/>
Taken literally, 28.7 [re.traits]/7 appears to imply that named locales are required to hold their collate facets with 
dynamic type <tt>std::collate_byname&lt;charT&gt;</tt>, which is in fact true in some implementations (e.g libc++), but not others 
(e.g. libstdc++). This does not follow from the description of <tt>_byname</tt> in 22.3.1.1.2 [locale.facet]/4, which is only 
required to provide equivalent semantics, to the named locale's facet, not to actually be one.
</p>


<p><i>[2015-05-06 Lenexa: Move to Open]</i></p>


<p>MC, RP: Consequence of failing to follow the rule is UB.</p>
<p>MC: Tightening of requirements.</p>
<p>RP: It should be this way, we just didn't impose it before.</p>
<p>MC: Second change is a bug fix, original code didn't work.</p>
<p>TK: Doesn't seem to make things worse.</p>
<p>Bring up in larger group tomorrow.</p>
<p>JW arrives.</p>
<p>JW: libstdc++ violates this due to two std::string ABIs.</p>
<p>JW: This prevents installing a type derived from Facet_byname, constrains the implementor from using a smarter derived class version.</p>
<p>JW: Can't look at facet id to detect replacement, because replacements have the same id.</p>
<p>RP: Can you give it multiple ids through multiple inheritance?</p>
<p>JW: No, the facet mechanism wouldn't like that.</p>
<p>JW: We should also ask Martin Sebor, he's implemented this stuff recently.</p>
<p>MC: Sounds like this resolution doesn't work, need a better solution.</p>
<p>JW: Write in words "if the facet has not been replaced by the user", the implementation knows how to detect that, but not like this.</p>
<p>RP: User RE traits need to detect this too.</p>
<p>JW: =(</p>
<p>Move to Open, JW will invite Martin Sebor to join LWG for discussion.</p>
<p>Later ... </p>
<p>JW: This is not needed for user specializations after all.</p>
<p>MC: Agree, [re.traits]/7 only applies to the stdlib traits.</p>
<p>NM: Effects: doesn't make sense.</p>
<p>JW, NM, Martin Sebor to come up with new wording.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 22.3.1.1.2 [locale.facet]/4 as indicated:</p>

<blockquote><p>
For some standard facets a standard "...<tt>_byname</tt>" class, derived from it, implements the virtual function
semantics <del>equivalent to</del><ins>provided by</ins> that facet of the locale constructed by <tt>locale(const char*)</tt> 
with the same name.
Each such facet provides a constructor that takes a <tt>const char*</tt> argument, which names the locale, and a
<tt>refs</tt> argument, which is passed to the base class constructor. Each such facet also provides a constructor
that takes a string argument <tt>str</tt> and a <tt>refs</tt> argument, which has the same effect as calling the first
constructor with the two arguments <tt>str.c_str()</tt> and <tt>refs</tt>. If there is no "...<tt>_byname</tt>" 
version of a facet, the base class implements named locale semantics itself by reference to other facets. <ins>For any 
locale <tt>loc</tt> constructed by <tt>locale(const char*)</tt> and facet <tt>Facet</tt> that has a corresponding standard 
<tt>Facet_byname</tt> class, <tt>typeid(use_facet&lt;Facet&gt;(loc)) == typeid(Facet_byname)</tt>.</ins>
</p></blockquote>
</li>

<li><p>Modify 28.7 [re.traits]/7 as indicated:</p>

<blockquote><pre>
template &lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
</pre><blockquote>
<p>
-7- <i>Effects:</i> if <tt>typeid(use_facet&lt;collate&lt;charT&gt; &gt;<ins>(getloc())</ins>) == typeid(collate_byname&lt;charT&gt;)</tt> 
and the form of the sort key returned by <tt>collate_byname&lt;charT&gt;::transform(first, last)</tt> is known and
can be converted into a primary sort key then returns that key, otherwise returns an empty string.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2342" href="#2342">2342.</a> User conversion to <tt>wchar_t const*</tt> or to <tt>wchar_t</tt> not invoked for <tt>operator&lt;&lt;</tt></h3>
<p><b>Section:</b> 27.7.3.1 [ostream] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alf P. Steinbach <b>Opened:</b> 2013-10-29 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream">issues</a> in [ostream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For wide streams argument types <tt>wchar_t const*</tt> and <tt>wchar_t</tt> are supported only as template parameters. 
User defined conversions are not considered for template parameter matching. Hence inappropriate overloads of 
<tt>operator&lt;&lt;</tt> are selected when an implicit conversion is required for the argument, which is inconsistent 
with the behavior for <tt>char const*</tt> and <tt>char</tt>, is unexpected, and is a useless result.
<p/>
Demonstration:
</p>
<blockquote><pre>
#include &lt;iostream&gt;

struct Byte_string
{ 
  operator char const*() const { return "Hurray, it works!"; } 
};

struct Wide_string
{ 
  operator wchar_t const*() const { return L"Hurray, it works!"; } 
};

struct Byte_ch
{ 
  operator char() const { return 'X'; } 
};

struct Wide_ch
{ 
  operator wchar_t() const { return L'X'; } 
};

auto main() -> int
{
  using namespace std;
  wcout &lt;&lt; "'X' as char value   : " &lt;&lt; Byte_ch() &lt;&lt; endl;
  wcout &lt;&lt; "'X' as wchar_t value: " &lt;&lt; Wide_ch() &lt;&lt; endl;
  wcout &lt;&lt; "Byte string pointer : " &lt;&lt; Byte_string() &lt;&lt; endl;
  wcout &lt;&lt; "Wide string pointer : " &lt;&lt; Wide_string() &lt;&lt; endl;
}
</pre></blockquote>
<p>
Example output:
</p>
<blockquote><pre>
'X' as char value   : X
'X' as wchar_t value: 88
Byte string pointer : Hurray, it works!
Wide string pointer : 000803C8
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 27.7.3.1 [ostream], class template <tt>basic_ostream</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
[&hellip;]

<i>// 27.7.3.6.4 character inserters</i>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          charT);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          char);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         char);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            wchar_t);</ins>
[&hellip;]

template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const charT*);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const char*);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         const char*);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            const wchar_t*);</ins>
[&hellip;]
}

</pre></blockquote>
</li>

<li><p>Modify 27.7.3.6.4 [ostream.inserters.character] as indicated: <em>[Drafting note: 
The replacement of <tt>os</tt> by <tt>out</tt> in p1 and the insertion of "<tt>out.</tt>" in p4 
just fix two obvious typos &mdash; end drafting note]</em></p>

<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            wchar_t c);</ins>

<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          unsigned char c);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>out</tt>. 
Constructs a character sequence <tt>seq</tt>. If <tt>c</tt> has type <tt>char</tt> and the character type of the stream 
is not <tt>char</tt>, then <tt>seq</tt> consists of <tt>out.widen(c)</tt>; otherwise <tt>seq</tt> consists of <tt>c</tt>. 
Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Inserts <tt>seq</tt> into 
<tt>out</tt>. Calls <tt><del>os</del><ins>out</ins>.width(0)</tt>.
<p/>
-2- <i>Returns:</i> <tt>out</tt>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            const wchar_t* s);</ins>
											
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>s</tt> shall not be a null pointer.
<p/>
-4- <i>Effects:</i> Behaves like a formatted inserter (as described in 27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>out</tt>. 
Creates a character sequence <tt>seq</tt> of <tt>n</tt> characters starting at <tt>s</tt>, each widened using <tt>out.widen()</tt> 
(27.5.5.3), where <tt>n</tt> is the number that would be computed as if by:
</p>
<ul>
<li><p>
<tt>traits::length(s)</tt> for the <ins>following</ins> overload<ins>s:</ins>
<ul>
<li><p>
where the first argument is of type <tt>basic_ostream&lt;charT, traits&gt;&amp;</tt> 
and the second is of type <tt>const charT*</tt>,
</p></li>
<li><p>
<del>and also for the overload</del> where the first argument is of type 
<tt>basic_ostream&lt;char, traits&gt;&amp;</tt> and the second is of type <tt>const char*</tt>,
</p></li>
<li><p>
<ins>where the first argument is of type 
<tt>basic_ostream&lt;wchar_t, traits&gt;&amp;</tt> and the second is of type <tt>const wchar_t*</tt>,</ins>
</p></li>
</ul> 
</p></li>
<li><p>
<tt>std::char_traits&lt;char&gt;::length(s)</tt> for the overload where the first argument is of type
<tt>basic_ostream&lt;charT, traits&gt;&amp;</tt> and the second is of type <tt>const char*</tt>,
</p></li>
<li><p>
<tt>traits::length(reinterpret_cast&lt;const char*&gt;(s))</tt> for the other two overloads.
</p></li>
</ul>
<p>
Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Inserts <tt>seq</tt> into 
<tt>out</tt>. Calls <tt><ins>out.</ins>width(0)</tt>.
<p/>
-5- <i>Returns:</i> <tt>out</tt>.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2348" href="#2348">2348.</a> <tt>charT('1')</tt> is not the wide equivalent of <tt>'1'</tt></h3>
<p><b>Section:</b> 20.9 [template.bitset], 27.7.6 [quoted.manip] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Example: <tt>char16_t('1') != u'1'</tt> is possible.
<p/>
The numeric value of <tt>char16_t</tt> is defined to be Unicode
code point, which is same to the ASCII value and UTF-8 for
7-bit chars.  However, <tt>char</tt> is not guaranteed to have an
encoding which is compatible with ASCII. For example, <tt>'1'</tt> in EBCDIC is 241.
<p/>
I found three places in the standard casting narrow char
literals: <tt>bitset::bitset</tt>, <tt>bitset::to_string</tt> and <tt>quoted</tt>.
<p/>
PJ confirmed this issue and says he has a solution used
in their <tt>&lt;filesystem&gt;</tt> implementation, and he may want to
propose it to the standard.
<p/>
The solution in my mind, for now, is to make those default
arguments magical, where the "magic" can be implemented
with a C11 <tt>_Generic</tt> selection (works in clang):
</p>
<blockquote><pre>
#define _G(T, literal) _Generic(T{}, \
      char: literal, \
      wchar_t: L ## literal, \
      char16_t: u ## literal, \
      char32_t: U ## literal)

  _G(char16_t, '1') == u'1'
</pre></blockquote>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Ask for complete PR (need quoted, to string, et al.)</p>
<p>Will then take it up again</p>
<p>Expectation is that this is correct way to fix this</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> This is a sample wording fixing only one case;
 I'm just too lazy to copy-paste it before we discussed whether
 the solution is worth and sufficient (for example, should the
 other `charT`s like `unsigned char` just don't compile without
 supplying those arguments?  I hope so). &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 20.9 [template.bitset] p1, class template <tt>bitset</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;size_t N&gt; class bitset {
  public:
    [&hellip;]
    template&lt;class charT, class traits, class Allocator&gt;
      explicit bitset(
        const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type pos = 0,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type n =
          basic_string&lt;charT,traits,Allocator&gt;::npos,
          charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
     [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.9.1 [bitset.cons] as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
explicit 
bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
         basic_string&lt;charT, traits, Allocator&gt;::npos,
         charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
</pre><blockquote>
<p>
<ins>-?- The default values of <tt>zero</tt> and <tt>one</tt> compare equal to the
character literals <tt>0</tt> and <tt>1</tt> of type <tt>charT</tt>, respectively.</ins>
<p/>
-3- <i>Requires::</i> <tt>pos &lt;= str.size()</tt>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2349" href="#2349">2349.</a> Clarify input/output function rethrow behavior</h3>
<p><b>Section:</b> 27.7.2.2.1 [istream.formatted.reqmts] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-06 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.formatted.reqmts">issues</a> in [istream.formatted.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The formatted input function requirement says in 27.7.2.2.1 [istream.formatted.reqmts]:
</p>
<blockquote><p>
"If an exception is thrown during input then <tt>ios::badbit</tt> is turned on
in <tt>*this</tt>'s error state.  If <tt>(exceptions()&amp;badbit) != 0</tt> then the exception
is rethrown."
</p></blockquote>
<p>
while some formatted function may throw an exception from <tt>basic_ios::clear</tt>, for example
in 20.9.4 [bitset.operators] p6:
</p>
<blockquote><p>
"If no characters are stored in <tt>str</tt>, calls <tt>is.setstate(ios_base::failbit)</tt> (which may 
throw <tt>ios_base::failure</tt>)"
</p></blockquote>
<p>
So should this exception be considered as "an exception [...] thrown
during input"?  And here is an implementation divergence (or you
can read the following as "a bug libc++ only has" :)
</p>
<blockquote><pre>
cin.exceptions(ios_base::failbit);
bitset&lt;N&gt; b;
try {
  cin &gt;&gt; b;  // type 'a' and return
} catch (...)
{}
</pre></blockquote>
<p>
Now <tt>cin.rdstate()</tt> is just <tt>failbit</tt> in libstdc++ (and Dinkumware, by
PJ), but <tt>failbit &amp; badbit</tt> libc++. Similar difference found in other
places, like <tt>eofbit &amp; badbid</tt> after <tt>std::getline</tt>.
<p/>
PJ and Matt both agree that the intention (of <tt>badbit</tt> + rethrow) is
"to signify an exception arising in user code, not the iostreams package".
<p/>
In addition, I found the following words in unformatted input
function's requirements (27.7.2.3 [istream.unformatted]):
</p>
<blockquote><p>
If an exception is thrown during input then <tt>ios::badbit</tt> is turned on
in <tt>*this</tt>'s error state. (Exceptions thrown from <tt>basic_ios&lt;&gt;::clear()</tt>
are not caught or rethrown.)  If <tt>(exceptions()&amp;badbit) != 0</tt> then the
exception is rethrown.
</p></blockquote>
<p>
The content within the parenthesis is added by LWG defect <a href="lwg-defects.html#61">61</a>,
and does fix the ambiguity. However, it only fixed the 1 of 4
requirements, and it lost some context (the word "rethrown" is not
seen before this sentence within this section).
</p>

<p><i>[Lenexa 2015-05-07: Marshall to research and report]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> The editor is kindly asked to introduce additional spaces at the following marked occurrences of
<tt>operator&amp;</tt> &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 27.7.2.2.1 [istream.formatted.reqmts] p1 as indicated:</p>

<blockquote><p>
-1- Each formatted input function begins execution by constructing an object of class <tt>sentry</tt> with the <tt>noskipws</tt>
(second) argument false. If the <tt>sentry</tt> object returns true, when converted to a value of type <tt>bool</tt>, the
function endeavors to obtain the requested input. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> 
is thrown during input then <tt>ios::badbit</tt>
is turned on[Footnote 314] in <tt>*this</tt>'s error state. If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> 
then the exception is rethrown.
In any case, the formatted input function destroys the <tt>sentry</tt> object. If no exception has been thrown, it returns <tt>*this</tt>.
</p></blockquote>
</li>

<li><p>Modify 27.7.3.6.1 [ostream.formatted.reqmts] p1 as indicated:</p>

<blockquote><p>
-1- Each formatted output function begins execution by constructing an object of class <tt>sentry</tt>. If this object
returns true when converted to a value of type <tt>bool</tt>, the function endeavors to generate the requested
output. If the generation fails, then the formatted output function does <tt>setstate(ios_base::failbit)</tt>,
which might throw an exception. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> is thrown 
during output, then <tt>ios::badbit</tt> is turned on[Footnote 327]
in <tt>*this</tt>'s error state. If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> then the exception is rethrown. 
Whether or not
an exception is thrown, the <tt>sentry</tt> object is destroyed before leaving the formatted output function. If no
exception is thrown, the result of the formatted output function is <tt>*this</tt>.
</p></blockquote>
</li>

<li><p>Modify 27.7.3.7 [ostream.unformatted] p1 as indicated:</p>

<blockquote><p>
-1- Each unformatted output function begins execution by constructing an object of class <tt>sentry</tt>. If this object
returns true, while converting to a value of type <tt>bool</tt>, the function endeavors to generate the requested
output. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> is thrown during output, 
then ios::badbit is turned on[Footnote 330] in <tt>*this</tt>'s error state.
If <tt>(exceptions() &amp; badbit) != 0</tt> then the exception is rethrown. In any case, the unformatted output
function ends by destroying the <tt>sentry</tt> object, then, if no exception was thrown, returning the value specified
for the unformatted output function.
</p></blockquote>
</li>

<li><p>Modify 27.7.2.3 [istream.unformatted] p1 as indicated:</p>

<blockquote><p>
-1- Each unformatted input function begins execution by constructing an object of class <tt>sentry</tt> with the default
argument <tt>noskipws</tt> (second) argument true. If the <tt>sentry</tt> object returns true, when converted to a value
of type <tt>bool</tt>, the function endeavors to obtain the requested input. Otherwise, if the <tt>sentry</tt> constructor exits
by throwing an exception or if the sentry object returns false, when converted to a value of type <tt>bool</tt>, the
function returns without attempting to obtain any input. In either case the number of extracted characters
is set to <tt>0</tt>; unformatted input functions taking a character array of non-zero size as an argument shall also
store a null character (using <tt>charT()</tt>) in the first location of the array. If an exception<ins>, other than the 
ones thrown from <tt>clear()</tt>, if any,</ins> is thrown during input
then <tt>ios::badbit</tt> is turned on[Footnote 317] in <tt>*this</tt>'s error state. <del>(Exceptions thrown from 
<tt>basic_ios&lt;&gt;::clear()</tt> are not caught or rethrown.)</del> If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> 
then the exception is rethrown. It also counts the number of characters extracted. If no exception has been thrown it ends 
by storing the count in a member object and returning the value specified. In any event the <tt>sentry</tt> object is destroyed 
before leaving the unformatted input function.
</p></blockquote>
</li>

</ol>






<hr>
<h3><a name="2352" href="#2352">2352.</a> Is a default-constructed <tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt>?</h3>
<p><b>Section:</b> 26.6.7.1 [rand.util.seedseq] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With respect to class <tt>seed_seq</tt> 26.6.7.1 [rand.util.seedseq], is a default-constructed 
<tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt> sequence?
<p/>
Implementations differ.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2362" href="#2362">2362.</a> unique, associative <tt>emplace()</tt> should not move/copy the <tt>mapped_type</tt> constructor 
arguments when no insertion happens</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-02-15 <b>Last modified:</b> 2015-09-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>a_uniq.emplace(args)</tt> is specified as:
</p>

<blockquote><p>
<i>Effects</i>: Inserts a value_type object <tt>t</tt> constructed with<br/>
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in the<br/>
container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of<br/>
the returned pair is true if and only if the insertion takes place,<br/>
and the iterator component of the pair points to the element with key<br/>
equivalent to the key of <tt>t</tt>. 
</p></blockquote>

<p>
However, we occasionally find code of the form:
</p>

<blockquote><pre>
std::unique_ptr&lt;Foo&gt; p(new Foo);
auto res = m.emplace("foo", std::move(p));
</pre></blockquote>

<p>
where we'd like to avoid destroying the <tt>Foo</tt> if the insertion doesn't
take place (if the container already had an element with the specified key).
<p/>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873">N3873</a> includes
a partial solution to this in the form of a new <tt>emplace_stable</tt> member function, but LEWG's 
discussion strongly agreed that we'd rather have <tt>emplace()</tt> Just Work:
<p/>
Should <tt>map::emplace()</tt> be guaranteed not to move/copy its arguments if the insertion doesn't happen?
<p/>
SF: 8 F: 3 N: 0 A: 0 SA: 0
<p/>
This poll was marred by the fact that we didn't notice or call out
that <tt>emplace()</tt> must construct the key before doing the lookup, and it
must not then move the key after it determines whether an insert is
going to happen, and the <tt>mapped_type</tt> instance must live next to the key.
<p/>
The very similar issue <a href="lwg-closed.html#2006">2006</a> was previously marked NAD, with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3178.htm">N3178</a> as
discussion. However, given LEWG's interest in the alternate behavior,
we should reopen the question in this issue.
<p/>
We will need a paper that describes how to implement this before we can make more progress.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2363" href="#2363">2363.</a> Defect in 30.4.1.4.1 [thread.sharedtimedmutex.class]</h3>
<p><b>Section:</b> 30.4.1.5.1 [thread.sharedtimedmutex.class] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-16 <b>Last modified:</b> 2016-03-07</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1.5.1 [thread.sharedtimedmutex.class] paragraph 2: 
</p>
<blockquote><p> The class <tt>shared_timed_mutex</tt> shall satisfy all of the 
<tt>SharedTimedMutex</tt> requirements (30.4.1.4). It shall be a standard layout class (Clause 9).
</p></blockquote> 
<p>
There's no <tt>SharedTimedMutex</tt> requirements; this name doesn't appear anywhere else in the standard. (Prior to N3891, 
this was <tt>SharedMutex</tt>, which was equally undefined.)
<p/>
I assume this concept should be defined somewhere?
<p/>
Also, n3891 changes 30.4.1.5 [thread.sharedtimedmutex.requirements] from defining "shared mutex type" to defining 
"shared timed mutex type", but its paragraph 2 still talks about "shared mutex type". Is that OK? I think you could argue 
that it's clear enough what it means, but presumably it should use the term that paragraph 1 defined.
<p/>
30.4.2.3 [thread.lock.shared] paragraph 1 talks about the "shared mutex requirements", which again is a term that isn't 
defined, and presumably means "the requirements on a shared timed mutex type" or similar (maybe if <tt>SharedMutex</tt> or 
<tt>SharedTimedMutex</tt> were defined it could be reused here).
</p>

<p><i>[2014-05-22, Daniel comments]</i></p>

<p>
As for <tt>SharedTimedMutex</tt>, there exists a similar problem in regard to <tt>TimedMutex</tt> referred to in
30.4.1.3.1 [thread.timedmutex.class] p2 and in 30.4.1.3.2 [thread.timedmutex.recursive] p2, but nowhere defined.
<p/>
Another problem is, that according to 30.4.1.2.1 [thread.mutex.class] p3, "The class <tt>mutex</tt> shall satisfy all the 
<tt>Mutex</tt> requirements (30.4.1 [thread.mutex.requirements]).", but there are no concrete <tt>Mutex</tt> requirements,
30.4.1 [thread.mutex.requirements] &mdash; titled as "Mutex requirements" &mdash; describes <em>mutex types</em>,
<em>timed mutex types</em>, and <em>shared timed mutex types</em>.
</p>

<p><i>[2014-06-08, Daniel comments and provides wording]</i></p>

<p>
The presented wording adds to the existing <em>mutex types</em>, <em>timed mutex types</em>, and <em>shared timed mutex types</em> 
terms a new set of corresponding <tt>MutexType</tt>, <tt>TimedMutexType</tt>, and <tt>SharedTimedMutexType</tt> requirements. 
<p/>
The reason for the change of requirement names is two-fold: First, the new name better matches the intention to have a concrete 
name for the requirements imposed on the corresponding <em>mutex types</em> (This kind of requirement deviate from the more general
<tt>Lockable</tt> requirements, which are not restricted to a explicitly enumerated set of library types). Second, using 
<tt>**MutexType</tt> over <tt>**Mutex</tt> provides the additional advantage that it reduces the chances of confusing named 
requirements from template parameters named <tt>Mutex</tt> (such as for <tt>unique_lock</tt> or <tt>shared_lock</tt>).
<p/>
Nonetheless the here presented wording has one unfortunate side-effect: Once applied it would have the effect that types
used to instantiate <tt>std::shared_lock</tt> cannot be user-defined shared mutex types due to 30.4.2.3 [thread.lock.shared]. 
The reason is based on the currently lack of an existing <tt>SharedLockable</tt> requirement set, which would complete the 
existing <tt>BasicLockable</tt> and <tt>Lockable</tt> requirements (which are "real" requirements). This restriction is not
actually a problem introduced by the provided resolution but instead one that existed before but becomes more obvious now.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
Thanks to Daniel, and please put it in SG1-OK status. Perhaps open another issue for the remaining problem Daniel points out?
</p>

<p><i>[2015-10 pre-Kona]</i></p>

<p>
SG1 hands this over to LWG for wording review
</p>

<p><i>[2015-10-21 Kona, Daniel comments and adjusts wording to to untimed shared mutex types]</i></p>

<p>
The new wording reflects the addition of the new shared mutex types. The approach used for <tt>shared_lock</tt>
is similar to the one used for <tt>unique_lock</tt>: The template argument <tt>Mutex</tt> has a reduced requirement set that is not
sufficient for <em>all</em> operations. Only those members that require stronger requirements of <tt>SharedTimedMutexType</tt>
specify that additionally in the <i>Requires</i> element of the corresponding prototype specifications.
<p/>
The proposed wording could be more general if we would introduce more fundamental requirements set for <tt>SharedLockable</tt>
and <tt>SharedTimedLockable</tt> types which could be satisfied by user-provided types as well, because the 
<tt>SharedMutexType</tt> and <tt>SharedTimedMutexType</tt> requirements are essentially restricted to an enumerated set of
types provided by the Standard Library. But this extension seemed too large for this issue and can be easily fixed later
without any harm. 
</p>

<p><b>Previous resolution [SUPERSEDED]:</b></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 30.4.1.2 [thread.mutex.requirements.mutex] as indicated:</p>

<blockquote><p>
-1- The <em>mutex types</em> are the standard library types <tt>std::mutex</tt>, <tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_timed_mutex</tt>, and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>MutexType</em></tt></ins> 
requirements set out in this section. In this description, <tt>m</tt> denotes an object of a mutex type.
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.1 [thread.mutex.class] as indicated:</p>

<blockquote><p>
-3- The class <tt>mutex</tt> shall satisfy all the <tt>Mutex<ins>Type</ins></tt> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.2 [thread.mutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_mutex</tt> shall satisfy all the <del>Mutex</del><ins><tt>MutexType</tt></ins> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3 [thread.timedmutex.requirements] as indicated:</p>

<blockquote><p>
-1- The <em>timed mutex types</em> are the standard library types <tt>std::timed_mutex</tt>, <tt>std::recursive_timed_mutex</tt>,
and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>TimedMutexType</em></tt></ins> requirements set out below. 
In this description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_time</tt> denotes an object of an instantiation of 
<tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.1 [thread.timedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.2 [thread.timedmutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.5 [thread.sharedtimedmutex.requirements] as indicated: [<i>Drafting note</i>: The reference to the
timed mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedTimedMutexType</tt> <em>refine</em> <tt>TimedMutexType</tt>.]</p>

<blockquote>
<p>
-1- The standard library type <tt>std::shared_timed_mutex</tt> is a <em>shared timed mutex type</em>. Shared timed mutex
types shall meet the <ins><tt><em>SharedTimedMutexType</em></tt></ins> requirements <del>of timed mutex types 
(30.4.1.3 [thread.timedmutex.requirements]), and additionally shall meet the requirements</del> set out below. In this 
description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_type</tt> denotes
an object of an instantiation of <tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of
<tt>time_point</tt> (20.12.6).
<p/>
<ins>-?- The shared timed mutex types shall meet the <tt>TimedMutexType</tt> requirements (30.4.1.3 [thread.timedmutex.requirements]).</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.4.1.5.1 [thread.sharedtimedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_timed_mutex</tt> shall satisfy all of the <tt>SharedTimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.2.3 [thread.lock.shared] as indicated: [<i>Drafting note</i>: Once 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3995.htm">N3995</a> has been applied, the following 
reference should be changed to the new <tt>SharedMutexType</tt> requirements ([thread.sharedmutex.requirements]) or 
even better to some new <tt>SharedLockable</tt> requirements (to be defined) &mdash; <i>end drafting note</i>]</p>

<blockquote><p>
-1- [&hellip;] The supplied <tt>Mutex</tt> type shall meet the <del>shared mutex</del><ins><tt>SharedTimedMutexType</tt></ins> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).
<p/>
-2- [<i>Note</i>: <tt>shared_lock&lt;Mutex&gt;</tt> meets the <tt>TimedLockable</tt> requirements 
(30.2.5.4). &mdash; <i>end note</i>]
</p></blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-02 Jacksonville]</i></p>

<p>
Marshall to review wording.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 30.4.1.2 [thread.mutex.requirements.mutex] as indicated:</p>

<blockquote><p>
-1- The <em>mutex types</em> are the standard library types <tt>std::mutex</tt>, <tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_timed_mutex</tt>, <tt>std::shared_mutex</tt>, and <tt>std::shared_timed_mutex</tt>. They shall meet the 
<ins><tt><em>MutexType</em></tt></ins> requirements set out in this section. In this description, <tt>m</tt> denotes an object 
of a mutex type.
<p/>
-2- The mutex types shall meet the <tt>Lockable</tt> requirements (30.2.5.3 [thread.req.lockable.req]).
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.1 [thread.mutex.class] as indicated:</p>

<blockquote><p>
-3- The class <tt>mutex</tt> shall satisfy all the <tt>Mutex<ins>Type</ins></tt> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.2 [thread.mutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_mutex</tt> shall satisfy all the <del>Mutex</del><ins><tt>MutexType</tt></ins> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3 [thread.timedmutex.requirements] as indicated:</p>

<blockquote><p>
-1- The <em>timed mutex types</em> are the standard library types <tt>std::timed_mutex</tt>, <tt>std::recursive_timed_mutex</tt>,
and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>TimedMutexType</em></tt></ins> requirements set out below. 
In this description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_time</tt> denotes an object of an instantiation of 
<tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
<p/>
-2- The timed mutex types shall meet the <tt>TimedLockable</tt> requirements (30.2.5.4 [thread.req.lockable.timed]).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.1 [thread.timedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.2 [thread.timedmutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.4 [thread.sharedmutex.requirements] as indicated:  [<i>Drafting note</i>: The reference to the
mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedMutexType</tt> <em>refines</em> <tt>MutexType</tt>.]</p>

<blockquote><p>
-1- The standard library types <tt>std::shared_mutex</tt> and <tt>std::shared_timed_mutex</tt> are <em>shared mutex types</em>.
Shared mutex types shall meet the <ins><tt><em>SharedMutexType</em></tt></ins> requirements <del>of mutex types 
(30.4.1.2 [thread.mutex.requirements.mutex]), and additionally shall meet the 
requirements</del> set out below. In this description, <tt>m</tt> denotes an object of a shared mutex type.
<p/>
<ins>-?- The shared mutex types shall meet the <tt>MutexType</tt> requirements (30.4.1.2 [thread.mutex.requirements.mutex]).</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.4.1.4.1 [thread.sharedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_mutex</tt> shall satisfy all of the <ins><tt>SharedMutexType</tt></ins> requirements 
<del>for shared mutexes</del> (30.4.1.4 [thread.sharedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.5 [thread.sharedtimedmutex.requirements] as indicated: [<i>Drafting note</i>: The reference to the
timed mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedTimedMutexType</tt> <em>refines</em> <tt>TimedMutexType</tt> and <tt>SharedMutexType</tt>.]</p>

<blockquote>
<p>
-1- The standard library type <tt>std::shared_timed_mutex</tt> is a <em>shared timed mutex type</em>. Shared timed mutex
types shall meet the <ins><tt><em>SharedTimedMutexType</em></tt></ins> requirements <del>of timed mutex types 
(30.4.1.3 [thread.timedmutex.requirements]), shared mutex types (30.4.1.4 [thread.sharedmutex.requirements]), 
and additionally shall meet the requirements</del> set out below. In this description, <tt>m</tt> denotes an object of 
a shared timed mutex type, <tt>rel_type</tt> denotes an object of an instantiation of <tt>duration</tt> (20.12.5), and 
<tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
<p/>
<ins>-?- The shared timed mutex types shall meet the <tt>TimedMutexType</tt> requirements (30.4.1.3 [thread.timedmutex.requirements])
and the <tt>SharedMutexType</tt> requirements (30.4.1.4 [thread.sharedmutex.requirements]).</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.4.1.5.1 [thread.sharedtimedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_timed_mutex</tt> shall satisfy all of the <ins><tt>SharedTimedMutexType</tt></ins> requirements 
<del>for shared timed mutexes</del> (30.4.1.5 [thread.sharedtimedmutex.requirements]). It shall be a standard-layout 
class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.2.3 [thread.lock.shared] as indicated:</p>

<blockquote><p>
-1- [&hellip;] The supplied <tt>Mutex</tt> type shall meet the <del>shared mutex</del><ins><tt>SharedMutexType</tt></ins> requirements 
(<del>30.4.1.5 [thread.sharedtimedmutex.requirements]</del><ins>30.4.1.4 [thread.sharedmutex.requirements]</ins>).
<p/>
-2- [<i>Note</i>: <tt>shared_lock&lt;Mutex&gt;</tt> meets the <tt>TimedLockable</tt> requirements 
(30.2.5.4). &mdash; <i>end note</i>]
</p></blockquote>
</li>

<li><p>Change 30.4.2.3.1 [thread.lock.shared.cons] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
-14- <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins> 
The calling thread does not own the mutex for any ownership mode.
<p/>
-15- <i>Effects</i>: Constructs an object of type <tt>shared_lock</tt> and calls <tt>m.try_lock_shared_until(abs_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class Rep, class Period&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
-17- <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins> 
The calling thread does not own the mutex for any ownership mode.
<p/>
-18- <i>Effects</i>: Constructs an object of type <tt>shared_lock</tt> and calls <tt>m.try_lock_shared_for(rel_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Change 30.4.2.3.2 [thread.lock.shared.locking] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration&gt;
  bool
  try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins>
<p/>
-8- <i>Effects</i>: <tt>pm-&gt;try_lock_shared_until(abs_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins>
<p/>
-12- <i>Effects</i>: <tt>pm-&gt;try_lock_shared_for(rel_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2366" href="#2366">2366.</a> <tt>istreambuf_iterator</tt> end-of-stream equality</h3>
<p><b>Section:</b> 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2014-02-19 <b>Last modified:</b> 2014-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given the following code,
</p>
<blockquote><pre>
#include &lt;sstream&gt;

std::stringbuf buf;
std::istreambuf_iterator&lt;char&gt; begin(&amp;buf);
std::istreambuf_iterator&lt;char&gt; end;
</pre></blockquote>
<p>
it is not clear from the wording of the Standard whether <tt>begin.equal(end)</tt>
must be true. In at least one implementation it is not (CC: Sun C++ 5.10 SunOS_sparc Patch 128228-25 2013/02/20) and in at least
one implementation it is (gcc version 4.3.2 x86_64-unknown-linux-gnu).
<p/>
24.6.3 [istreambuf.iterator] says that <tt>end</tt> is an end-of-stream iterator since it was default
constructed. It also says that an iterator becomes equal to an end-of-stream
iterator when end of stream is reached by <tt>sgetc()</tt> having returned <tt>eof()</tt>.
24.6.3.5 [istreambuf.iterator::equal] says that <tt>equal()</tt> returns true iff both iterators are end of stream
or not end of stream. But there seems to be no requirement that <tt>equal</tt> check for end-of-stream by calling <tt>sgetc()</tt>. 
<p/>
Jiahan Zi at BloombergLP discovered this issue through his code failing to
work correctly. Dietmar K&uuml;hl has opined in a private communication that
the iterators should compare equal.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2368" href="#2368">2368.</a> Replacing global <tt>operator new</tt></h3>
<p><b>Section:</b> 18.6.2 [new.delete] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephen Clamage <b>Opened:</b> 2014-02-20 <b>Last modified:</b> 2016-03-09</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete">issues</a> in [new.delete].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 18.6.2 [new.delete] and subsections shows:
</p>
<blockquote><pre>
void* operator new(std::size_t size);
void* operator new[](std::size_t size);
</pre></blockquote>
<p>
That is, without exception-specifications. (Recall that C++03 specified these functions with <tt>throw(std::bad_alloc)</tt>.)
<p/>
Section 17.6.5.12 [res.on.exception.handling] the end of paragraph 4 says:
</p>
<blockquote><p>
Any other functions defined in the C++ standard library that do not have an exception-specification may throw implementation-defined 
exceptions unless otherwise specified. An implementation may strengthen this implicit exception-specification by adding an explicit one.
</p></blockquote>
<p>
For example, an implementation could provide C++03-compatible declarations of <tt>operator new</tt>.
<p/>
Programmers are allowed to replace these <tt>operator new</tt> functions. But how can you write the definition of these functions when 
the exception specification can vary among implementations? For example, the declarations
</p>
<blockquote><pre>
void* operator new(std::size_t size) throw(std::bad_alloc);
void* operator new(std::size_t size);
</pre></blockquote>
<p>
are not compatible.
<p/>
From what I have been able to determine, gcc has a hack for the special case of <tt>operator new</tt> to ignore the differences in 
(at least) the two cases I show above. But can users expect all compilers to quietly ignore the incompatibility?
<p/>
The blanket permission to add any explicit exception specification could cause a problem for any user-overridable function. 
Different implementations could provide incompatible specifications, making portable code impossible to write.
</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>
STL: Core changes to remove dynamic exception specs would make this moot<br/>
Room: This is on track to be resolved by <a href="http://wg21.link/P0003">P0003</a>, or may be moot.<br/>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2375" href="#2375">2375.</a> Is [iterator.requirements.general]/9 too broadly applied?</h3>
<p><b>Section:</b> 24.2.1 [iterator.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-03-25 <b>Last modified:</b> 2014-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.2.1 [iterator.requirements.general] p9 says:
</p>
<blockquote><p>
Destruction of an iterator may invalidate pointers and references previously obtained from that iterator.
</p></blockquote>
<p>
But the resolution of LWG issue <a href="lwg-defects.html#2360">2360</a> specifically advocates returning <tt>*--temp;</tt> where <tt>temp</tt> is a 
local variable.
<p/>
And 24.2.5 [forward.iterators] p6 says:
</p>
<blockquote><p>
If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and <tt>*b</tt> are bound 
to the same object.
</p></blockquote>
<p>
which disallows "stashing" iterators (i.e, iterators that refer to data inside themselves).
<p/>
So, I suspect that the restriction in p9 should only apply to input iterators, and can probably be moved into 
24.2.3 [input.iterators] instead of 24.2.1 [iterator.requirements.general].
</p>

<p><i>[2014-05-22, Daniel comments]</i></p>


<p>
Given that forward iterators (and beyond) are refinements of input iterator, moving this constraint to input iterators won't help
much because it would still hold for all refined forms. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2381" href="#2381">2381.</a> Inconsistency in parsing floating point numbers</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-04-30 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.4.2.1.2 [facet.num.get.virtuals] we have:
</p>
<blockquote><p>
Stage 3: The sequence of chars accumulated in stage 2 (the field) is converted to a numeric value by the
rules of one of the functions declared in the header <tt>&lt;cstdlib&gt;</tt>:
</p>
<ul>
<li><p>For a signed integer value, the function <tt>strtoll</tt>.</p></li>
<li><p>For an unsigned integer value, the function <tt>strtoull</tt>.</p></li>
<li><p>For a floating-point value, the function <tt>strtold</tt>.</p></li>
</ul>
</blockquote>
<p>
This implies that for many cases, this routine should return true:
</p>
<blockquote><pre>
bool is_same(const char* p) 
{
  std::string str{p};
  double val1 = std::strtod(str.c_str(), nullptr);
  std::stringstream ss(str);
  double val2;
  ss &gt;&gt; val2;
  return std::isinf(val1) == std::isinf(val2) &amp;&amp;                 // either they're both infinity
         std::isnan(val1) == std::isnan(val2) &amp;&amp;                 // or they're both NaN
         (std::isinf(val1) || std::isnan(val1) || val1 == val2); // or they're equal
}
</pre></blockquote>
<p>
and this is indeed true, for many strings:
</p>
<blockquote><pre>
assert(is_same("0"));
assert(is_same("1.0"));
assert(is_same("-1.0"));
assert(is_same("100.123"));
assert(is_same("1234.456e89"));
</pre></blockquote>
<p>
but not for others
</p>
<blockquote><pre>
assert(is_same("0xABp-4")); // hex float
assert(is_same("inf"));
assert(is_same("+inf"));
assert(is_same("-inf"));
assert(is_same("nan"));
assert(is_same("+nan"));
assert(is_same("-nan"));

assert(is_same("infinity"));
assert(is_same("+infinity"));
assert(is_same("-infinity"));
</pre></blockquote>
<p>
These are all strings that are correctly parsed by <tt>std::strtod</tt>, but not by the stream extraction operators.
They contain characters that are deemed invalid in stage 2 of parsing.
<p/>
If we're going to say that we're converting by the rules of <tt>strtold</tt>, then we should accept all the things that 
<tt>strtold</tt> accepts.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
People are much more interested in round-tripping hex floats than handling <tt>inf</tt> and <tt>nan</tt>. Priority changed to P2.
</p>
<p>
Marshall says he'll try to write some wording, noting that this is a very closely specified part of the standard, and has remained unchanged for a long time. Also, there will need to be a sample implementation.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Zhihao provides wording</p>
<p>The <tt>src</tt> array in Stage 2 does narrowing only.  The actual
input validation is delegated to <tt>strtold</tt> (independent from
the parsing in Stage 3 which is again being delegated
to <tt>strtold</tt>) by saying:</p>

<p>  [...] If it is not discarded, then a check is made to determine
  if c is allowed as the next character of an input field of the
  conversion specifier returned by Stage 1.</p>

<p>So a conforming C++11 <tt>num_get</tt> is supposed to magically
accept an hexfloat without an exponent</p>

<p>  0x3.AB</p>

<p>because we refers to C99, and the fix to this issue should be
just expanding the <tt>src</tt> array.</p>

<p>Support for Infs and NaNs are not proposed because of the
complexity of nan(n-chars).</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Tues PM: Move to Open</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<blockquote>
<p>Change 22.4.2.1.2/3 [facet.num.get.virtuals] Stage 2 as indicated:</p>

<p><tt>static const char src[] = "0123456789abcdef<ins>p</ins>xABCDEF<ins>P</ins>X+-";</tt></p>
</blockquote>





<hr>
<h3><a name="2383" href="#2383">2383.</a> Overflow cannot be ill-formed for chrono::duration integer literals</h3>
<p><b>Section:</b> 20.17.5.8 [time.duration.literals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-05-16 <b>Last modified:</b> 2014-11-08</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.17.5.8 [time.duration.literals] p3 says:
</p>
<blockquote><p>
If any of these suffixes are applied to an integer literal and the
resulting <tt>chrono::duration</tt> value cannot be represented in the result
type because of overflow, the program is ill-formed.
</p></blockquote>
<p>
Ill-formed requires a diagnostic at compile-time, but there is no way
to  detect the overflow from <tt>unsigned long long</tt> to the <tt>signed
duration&lt;&gt;::rep</tt> type.
<p/>
Overflow could be detected if the duration integer literals were
literal operator templates, otherwise overflow can either be undefined
or a run-time error, not ill-formed.
</p>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2392" href="#2392">2392.</a> "character type" is used but not defined</h3>
<p><b>Section:</b> 17.3.16 [defns.ntcts], 22.3.1.1.1 [locale.category], 27.2.2 [iostreams.limits.pos], 27.7.3.6.1 [ostream.formatted.reqmts], 27.7.3.6.4 [ostream.inserters.character] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-06-01 <b>Last modified:</b> 2015-09-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The term "character type" is used in 17.3.16 [defns.ntcts], 22.3.1.1.1 [locale.category],
27.2.2 [iostreams.limits.pos], 27.7.3.6.1 [ostream.formatted.reqmts], and
27.7.3.6.4 [ostream.inserters.character], but the core language only defines
"narrow character types" (3.9.1 [basic.fundamental]).
<p/>
"wide-character type" is used in 22.5 [locale.stdcvt], but the core
language only defines a "wide-character set" and "wide-character literal".
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2394" href="#2394">2394.</a> <tt>locale::name</tt> specification unclear &mdash; what is implementation-defined?</h3>
<p><b>Section:</b> 22.3.1.3 [locale.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-06-09 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.3.1.3 [locale.members] p5 says:
</p>
<blockquote><p>
<i>Returns</i>: The name of <tt>*this</tt>, if it has one; otherwise, the string <tt>"*"</tt>. If <tt>*this</tt> has a name, then
<tt>locale(name().c_str())</tt> is equivalent to <tt>*this</tt>. Details of the contents of the resulting string are
otherwise implementation-defined.
</p></blockquote>
<p>
So&hellip; what is implementation-defined here, exactly? The first sentence <em>completely</em> defines the behavior of this function 
in all cases.
<p/>
Also, the second sentence says (effectively) that all locales with the same name are equivalent: given <tt>L1</tt> and <tt>L2</tt> 
that have the same name <tt>N</tt>, they are both equivalent to <tt>locale(N)</tt>, and since there is no definition of 
"equivalent" specific to <tt>locale</tt>, I assume it's the normal transitive equivalence property, which would imply that 
<tt>L1</tt> is equivalent to <tt>L2</tt>. I'm not sure why this central fact is in the description of <tt>locale::name</tt>, nor 
why it's written in this roundabout way.
</p>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 22.3.1.3 [locale.members] as indicated:</p>

<blockquote>
<pre>
basic_string&lt;char&gt; name() const;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> The name of <tt>*this</tt>, if it has one; otherwise, the string <tt>"*"</tt>. 
<del>If <tt>*this</tt> has a name, then <tt>locale(name().c_str())</tt> is equivalent to <tt>*this</tt>. 
Details of the contents of the resulting string are
otherwise implementation-defined.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2398" href="#2398">2398.</a> <tt>type_info</tt>'s destructor shouldn't be required to be virtual</h3>
<p><b>Section:</b> 18.7.2 [type.info] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#type.info">issues</a> in [type.info].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>type_info</tt>'s destructor is depicted as being <tt>virtual</tt>, which is nearly unobservable to users (since they can't construct 
or copy this class, they can't usefully derive from it). However, it's technically observable (via <tt>is_polymorphic</tt> and 
<tt>has_virtual_destructor</tt>). It also imposes real costs on implementations, requiring them to store one vptr per 
<tt>type_info</tt> object, when RTTI space consumption is a significant concern.
<p/>
Making this implementation-defined wouldn't affect users (who can observe this only if they're specifically looking for it) and 
wouldn't affect implementations who need <tt>virtual</tt> here, but it would allow other implementations to drop <tt>virtual</tt> 
and improve their RTTI space consumption.
<p/>
Richard Smith:
<p/>
It's observable in a few other ways.
</p>
<blockquote><pre>
std::map&lt;void*, something&gt; m;
m[dynamic_cast&lt;void*&gt;(&amp;typeid(blah))] = stuff;
</pre></blockquote>
<p>
... is broken by this change, because you can't <tt>dynamic_cast</tt> a non-polymorphic class type to <tt>void*</tt>.
</p>
<blockquote><pre>
type_info&amp; f();
typeid(f());
</pre></blockquote>
<p>
... evaluates <tt>f()</tt> at runtime without this change, and might not do so with this change.
<p/>
These are probably rare things, but I can imagine at least some forms of the latter being used in SFINAE tricks.
</p>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Marshall to poll LEWG for their opinion</p>

<p><i>[June 2016]</i></p>
 <p>On the <a href="http://lists.isocpp.org/lib-ext/2016/06/2451.php">reflector</a>, STL wrote:<br/>
&gt; We'll prototype this change and report back with data in the future.</p>

<p><i>[08-16 - Chicago]</i></p>

<p>No update from STL. Set priority to P3</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 18.7.2 [type.info] as indicated:</p>

<blockquote>
<pre>
namespace std {
  class type_info {
  public:
    <del>virtual</del><ins><i>see below</i></ins> ~type_info();
    [&hellip;]
  };
}
</pre>
<p>
-1- The class <tt>type_info</tt> describes type information generated by the implementation. Objects of this class
effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for
equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified
and may differ between programs. <ins>Whether <tt>~type_info()</tt> is <tt>virtual</tt> is implementation-defined.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2413" href="#2413">2413.</a> <tt>assert</tt> macro is overconstrained</h3>
<p><b>Section:</b> 19.3 [assertions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-06-25 <b>Last modified:</b> 2014-11-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#assertions">issues</a> in [assertions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <tt>NDEBUG</tt> is defined, <tt>assert</tt> must expand exactly to the token sequence <tt>((void)0)</tt>, with no 
whitespace (C99 &sect;7.2/1 and also C11 &sect;7.2/1). This is a lost opportunity to pass the condition along to the optimizer.
<p/>
The user may observe the token sequence using the stringize operator or discriminate it by making a matching <tt>#define</tt> 
directive. There is little chance of practical code doing such things. It's reasonable to allow any expansion that is a <tt>void</tt> 
expression with no side effects or semantic requirements, for example, an extension keyword or an attribute-specifier finagled 
into the context.
<p/>
Conforming optimizations would still be limited to treating the condition as hint, not a requirement. Nonconformance on this 
point is quite reasonable though, given user preferences. Anyway, it shouldn't depend on preprocessor quirks.
<p/>
As for current practice, Darwin OS <tt>&lt;assert.h&gt;</tt> provides a GCC-style compiler hint <tt>__builtin_expect</tt> but only in 
debug mode. Shouldn't release mode preserve hints?
<p/>
Daniel:
<p/>
The corresponding resolution should take care not to conflict with the intention behind LWG <a href="lwg-defects.html#2234">2234</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2414" href="#2414">2414.</a> Member function reentrancy should be implementation-defined</h3>
<p><b>Section:</b> 17.6.5.8 [reentrancy] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-07-01 <b>Last modified:</b> 2015-09-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reentrancy">issues</a> in [reentrancy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3936 17.6.5.8 [reentrancy]/1 talks about "functions", but that doesn't address the scenario of calling different member 
functions of a single object. Member functions often have to violate and then re-establish invariants. For example, vectors 
often have "holes" during insertion, and element constructors/destructors/etc. shouldn't be allowed to observe the vector 
while it's in this invariant-violating state. The [reentrancy] Standardese should be extended to cover member functions, 
so that implementers can either say that member function reentrancy is universally prohibited, or selectively allowed for 
very specific scenarios.
<p/>
(For clarity, this issue has been split off from LWG <a href="lwg-closed.html#2382">2382</a>.)
</p>

<p><i>[2014-11-03 Urbana]</i></p>

<p>
AJM confirmed with SG1 that they had no special concerns with this issue, and LWG should retain ownership.
<p/>
AM: this is too overly broad as it also covers calling the exact same member function on a different object<br/>
STL: so you insert into a map, and copying the value triggers another insertion into a different map of the same type<br/>
GR: reentrancy seems to imply the single-threaded case, but needs to consider the multi-threaded case
<p/>
Needs more wording.
</p>
<p>
Move to Open
</p>

<p><i>[2015-07 Telecom Urbana]</i></p>

<p>
Marshall to ping STL for updated wording.<br/>
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 17.6.5.8 [reentrancy] p1 as indicated:</p>
<blockquote>
<p>
-1- Except where explicitly specified in this standard, it is implementation-defined which functions <ins>(including different 
member functions called on a single object)</ins> in the Standard C++ library may be recursively reentered.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2421" href="#2421">2421.</a> Non-specification of handling zero size in <tt>std::align</tt> [ptr.align]</h3>
<p><b>Section:</b> 20.10.5 [ptr.align] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Melissa Mears <b>Opened:</b> 2014-08-06 <b>Last modified:</b> 2014-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.align">issues</a> in [ptr.align].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>std::align</tt> does not appear to specify what happens when the value of the <tt>size</tt> 
parameter is 0. (The question of what happens when <tt>alignment</tt> is 0 is mentioned in another Defect Report, <a href="lwg-defects.html#2377">2377</a>; 
it would change the behavior to be undefined rather than potentially implementation-defined.)
<p/>
The case of <tt>size</tt> being 0 is interesting because the result is ambiguous. Consider the following code's output:
</p>
<blockquote>
<pre>
#include &lt;cstdio&gt;
#include &lt;memory&gt;

int main()
{
  alignas(8) char buffer[8];
  void *ptr = &amp;buffer[1];
  std::size_t space = sizeof(buffer) - sizeof(char[1]);

  void *result = std::align(8, 0, ptr, space);

  std::printf("%d %td\n", !!result, result ? (static_cast&lt;char*&gt;(result) - buffer) : std::ptrdiff_t(-1));
}
</pre>
</blockquote>
<p>
There are four straightforward answers as to what the behavior of <tt>std::align</tt> with size 0 should be:
</p>
<ol>
<li><p>The behavior is undefined because the size is invalid.</p></li>
<li><p>The behavior is implementation-defined. This seems to be the status quo, with current implementations using #3.</p></li>
<li><p>Act the same as <tt>size == 1</tt>, except that if <tt>size == 1</tt> would fail but would be defined and succeed 
if space were exactly 1 larger, the result is a pointer to the byte past the end of the <tt>ptr</tt> buffer. That is, the 
"aligned" version of a 0-byte object can be one past the end of an allocation. Such pointers are, of course, valid when not 
dereferenced (and a "0-byte object" shouldn't be), but whether that is desired is not specified in the Standard's definition 
of <tt>std::align</tt>, it appears. The output of the code sample is "<tt>1 8</tt>" in this case.</p></li>
<li><p>Act the same as <tt>size == 1</tt>; this means that returning "one past the end" is not a possible result. In this case, 
the code sample's output is "<tt>0 -1</tt>".</p></li>
</ol>
<p>
The two compilers I could get working with <tt>std::align</tt>, Visual Studio 2013 and Clang 3.4, implement #3. (Change <tt>%td</tt> to 
<tt>%Id</tt> on Visual Studio 2013 and earlier. 2014 and later will have <tt>%td</tt>.)
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2423" href="#2423">2423.</a> Missing specification <tt>slice_array</tt>, <tt>gslice_array</tt>, <tt>mask_array</tt>, <tt>indirect_array</tt> copy constructor</h3>
<p><b>Section:</b> 26.7.5 [template.slice.array], 26.7.7 [template.gslice.array], 26.7.8 [template.mask.array], 26.7.9 [template.indirect.array] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Akira Takahashi <b>Opened:</b> 2014-08-12 <b>Last modified:</b> 2014-11-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I found a missing specification of the copy constructor of the following class templates:
</p>
<ul>
<li><p><tt>slice_array</tt> (26.7.5 [template.slice.array])</p></li>
<li><p><tt>gslice_array</tt> (26.7.7 [template.gslice.array])</p></li>
<li><p><tt>mask_array</tt> (26.7.8 [template.mask.array])</p></li>
<li><p><tt>indirect_array</tt> (26.7.9 [template.indirect.array])</p></li>
</ul>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Before 26.7.5.2 [slice.arr.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>slice_array</tt> constructors [slice.arr.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>slice_array(const slice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 26.7.7.2 [gslice.array.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>gslice_array</tt> constructors [gslice.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>gslice_array(const gslice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 26.7.8.2 [mask.array.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>mask_array</tt> constructors [mask.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>mask_array(const mask_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 26.7.9.2 [indirect.array.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>indirect_array</tt> constructors [indirect.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>indirect_array(const indirect_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2431" href="#2431">2431.</a> Missing regular expression traits requirements</h3>
<p><b>Section:</b> 28.3 [re.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2014-11-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the traits class in 28.3 [re.req] do not say whether a
regular expression traits class is required to be <tt>DefaultConstructible</tt>, 
<tt>CopyConstructible</tt>, <tt>CopyAssignable</tt> etc.
<p/>
The <tt>std::regex_traits</tt> class appears to be all of the above, but can
<tt>basic_regex</tt> assume that for user-defined traits classes?
<p/>
Should the following statements all leave <tt>u</tt> in equivalent states?
</p>
<blockquote><pre>
X u{v};
X u; u = v;
X u; u.imbue(v.getloc();
</pre></blockquote>
<p>
Whether they are equivalent has implications for <tt>basic_regex</tt> copy construction and 
assignment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2432" href="#2432">2432.</a> <tt>initializer_list</tt> assignability</h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="lwg-active.html#EWG">EWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2015-05-23</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::initializer_list::operator=</tt> 18.9 [support.initlist] is horribly broken and it needs deprecation:
</p>
<blockquote><pre>
std::initializer_list&lt;foo&gt; a = {{1}, {2}, {3}};
a = {{4}, {5}, {6}};
// New sequence is already destroyed.
</pre></blockquote>
<p>
Assignability of <tt>initializer_list</tt> isn't explicitly specified, but most implementations supply a default assignment 
operator. I'm not sure what 17.5 [description] says, but it probably doesn't matter.
</p>

<p><i>[Lenexa 2015-05-05: Send to EWG as discussed in Telecon]</i></p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Edit 18.9 [support.initlist] p1, class template <tt>initializer_list</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class E&gt; class initializer_list {
  public:
    [&hellip;]
    constexpr initializer_list() noexcept;
  
    <ins>initializer_list(const initializer_list&amp;) = default;</ins>
    <ins>initializer_list(initializer_list&amp;&amp;) = default;</ins>
    <ins>initializer_list&amp; operator=(const initializer_list&amp;) = delete;</ins>
    <ins>initializer_list&amp; operator=(initializer_list&amp;&amp;) = delete;</ins>
    
    constexpr size_t size() const noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2444" href="#2444">2444.</a> Inconsistent complexity for <tt>std::sort_heap</tt></h3>
<p><b>Section:</b> 25.5.6.4 [sort.heap] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Fran&ccedil;ois Dumont <b>Opened:</b> 2014-10-07 <b>Last modified:</b> 2015-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While creating complexity tests for the GNU libstdc++ implementation <a href="https://gcc.gnu.org/ml/libstdc++/2014-10/msg00048.html">I 
stumbled</a> across a surprising requirement for the <tt>std::sort_heap</tt> algorithm.
<p/>
In 25.5.6.4 [sort.heap] p3 the Standard states:
</p>
<blockquote><p>
<i>Complexity</i>: At most <tt><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>
<p>
As stated on the libstdc++ mailing list by Marc Glisse <tt>sort_heap</tt> can be implemented by <tt><i>N</i></tt> calls to 
<tt>pop_heap</tt>. As max number of comparisons of <tt>pop_heap</tt> is <tt>2 * log(<i>N</i>)</tt> then <tt>sort_heap</tt> 
max limit should be <tt>2 * log(1) + 2 * log(2) + .... + 2 * log(<i>N</i>)</tt> that is to say <tt>2 * log(<i>N</i>!)</tt>. 
In terms of <tt>log(<i>N</i>)</tt> we can also consider that this limit is also cap by <tt>2 * <i>N</i> * log(<i>N</i>)</tt> 
which is surely what the Standard wanted to set as a limit.
<p/>
This is why I would like to propose to replace paragraph 3 by:
</p>
<blockquote><p>
<i>Complexity</i>: At most <tt><ins>2</ins><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Marshall will research the maths and report back in Lenexa.
</p>

<p><i>[2015-05-06 Lenexa]</i></p>

<p>STL: I dislike exact complexity requirements, they prevent one or two extra checks in debug mode. Would it be better to say O(N log(N)) not at most?</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol><li>
<p>
In 25.5.6.4 [sort.heap] p3 the Standard states:
</p>
<blockquote>
<pre>
template&lt;class RandomAccessIterator&gt;
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
</pre>
<blockquote><p>
[&hellip;]
<p/>
-3- <i>Complexity</i>: At most <tt><ins>2</ins><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2449" href="#2449">2449.</a> <tt>vector::insert</tt> invalidates <tt>end()</tt>?</h3>
<p><b>Section:</b> 23.3.11.5 [vector.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2014-10-21 <b>Last modified:</b> 2014-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in [vector.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
this issue is based on the discussion <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/oYvKscnl280/discussion">here</a>.
<p/>
23.3.11.5 [vector.modifiers] says about <tt>vector::insert</tt>: "If no reallocation happens, all the iterators and references 
before the insertion point remain valid." This doesn't seem to guarantee anything about the iterator <em>at</em> the point of insertion.
<p/>
The question comes from people asking if the following is valid, assuming a sufficient call to <tt>reserve()</tt> was done first:
</p>
<blockquote><pre>
v.insert(v.end(), v.begin(), v.end());
</pre></blockquote>
<p>
It could fail for an implementation using a sentinel for the end of the vector, but I don't know of any (it would be quite 
inconvenient). And for any implementation using a simple position as iterator (pointer (possibly in a wrapper), or base+offset), 
this is needlessly restrictive. The fact that this alternative:
</p>
<blockquote><pre>
v.insert(v.end(), &amp;v[0], &amp;v[0]+v.size())
</pre></blockquote>
<p>
is arguably valid (again assuming a large enough <tt>reserve()</tt>) makes it a bit confusing that the first version isn't 
(23.2.3 [sequence.reqmts] has a precondition that iterator arguments to <tt>insert()</tt> do not point into the sequence, 
but <tt>vector::insert</tt> is more refined and seems to give enough guarantees that it cannot fail).
<p/>
Then we might as well say that <tt>vector</tt> iterators act as positions, and that after a reallocation-free operation an 
iterator points to the same position, whatever may be there now&hellip;
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2452" href="#2452">2452.</a> <tt>is_constructible</tt>, etc. and default arguments</h3>
<p><b>Section:</b> 20.15 [meta] <b>Status:</b> <a href="lwg-active.html#Core">Core</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2014-11-04 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>Discussion:</b></p>
<p>
The <tt>BaseCharacteristic</tt> for <tt>is_constructible</tt> is defined in terms of the well-formedness 
of a declaration for an invented variable. The well-formedness of the described declaration itself may 
change for the same set of arguments because of the introduction of default arguments.
<p/>
In the following program, there appears to be conflicting definitions of a specialization of 
<tt>std::is_constructible</tt>; however, it seems that this situation is caused without a user violation 
of the library requirements or the ODR. There is a similar issue with <tt>is_convertible</tt>, <tt>result_of</tt>
and others.
<p/>
a.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };
const std::false_type&amp; x1 = std::is_constructible&lt;A, int&gt;();

int main() { }
</pre></blockquote>
<p>
b.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };

inline A::A(int, int = 0) { }

const std::true_type&amp; x2 = std::is_constructible&lt;A, int&gt;();
</pre></blockquote>
<p>
Presumably this program should invoke undefined behaviour, but the Library specification doesn't
say that.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Core wording should say "this kind of thing is ill-formed, no diagnostic required"
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2453" href="#2453">2453.</a> &sect;[iterator.range] and now [iterator.container] aren't available via <tt>&lt;initializer_list&gt;</tt></h3>
<p><b>Section:</b> 18.9 [support.initlist], 24.7 [iterator.range], 24.8 [iterator.container] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These sections define helper functions, some of which apply to <tt>initializer_list&lt;T&gt;</tt>. And they're 
available if you include one of a long list of header files, many of which include <tt>&lt;initializer_list&gt;</tt>. 
But they are not available if you include <tt>&lt;initializer_list&gt;</tt>. This seems very odd.
</p>
<blockquote><pre>
#include &lt;initializer_list&gt;
auto x = {1, 2, 3};
const int *p = data(x); // error, undeclared
#include &lt;vector&gt;
const int *q = data(x); // ok
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2457" href="#2457">2457.</a> <tt>std::begin()</tt> and <tt>std::end()</tt> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 24.7 [iterator.range] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2015-02-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<tt>begin</tt>, <tt>end</tt>, <tt>rbegin</tt>, and <tt>rend</tt> to 24.7 [iterator.range], 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2461" href="#2461">2461.</a> Interaction between allocators and container exception safety guarantees</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], 23.3.11.3 [vector.capacity], 23.3.11.5 [vector.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> dyp <b>Opened:</b> 2014-12-06 <b>Last modified:</b> 2015-09-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When resizing a <tt>vector</tt>, the accessibility and exception specification of the value type's 
constructors determines whether the elements are copied or moved to the new buffer.
However, the copy/move is performed via the allocator's <tt>construct</tt> member function, which is 
assumed, but not required, to call the copy/move constructor and propagate only exceptions 
from the value type's copy/move constructor. The issue might also affect other classes. 
<p/>
The current wording in N4296 relevant here is from Table 28 &mdash; "Allocator requirements" in 
17.6.3.5 [allocator.requirements]: 
</p>
<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.construct(c, args)</tt>
</td>
<td>
(not used)
</td>
<td>
<i>Effect</i>: Constructs an object of type <tt>C</tt> at <tt>c</tt>
</td>
<td>
<tt>::new ((void*)c) C(forward&lt;Args&gt;(args)...)</tt>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
<p>
and from 17.6.3.5 [allocator.requirements] p9:
</p>
<blockquote><p>
An allocator may constrain the types on which it can be instantiated and the arguments for which its
<tt>construct</tt> member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to <tt>construct</tt> may fail to instantiate.
</p></blockquote>
<p>
I conclude the following from the wording:
</p>
<ol>
<li><p>The allocator is not required to call the copy constructor if the
arguments (args) is a single (potentially const) lvalue of the value
type. Similarly for a non-const rvalue + move constructor. See also
23.2.1 [container.requirements.general] p15 which seems to try to require
this, but is not sufficient:
That paragraph specifies the semantics of the allocator's operations,
but not which constructors of the value type are used, if any.
</p></li>
<li>
<p>The allocator may throw exceptions in addition to the exceptions propagated by
the constructors of the value type; it can also propagate exceptions from constructors
other than a copy/move constructor.
</p>
</li>
</ol>
<p>
This leads to an issue with the wording of the exception safety guarantees for vector modifiers in
23.3.11.5 [vector.modifiers] p1:
</p>
<blockquote>
<p>
[&hellip;]
</p>
<pre>
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. If no 
reallocation happens, all the iterators and references before the insertion point remain valid. 
If an exception is thrown other than by the copy constructor, move constructor, assignment 
operator, or move assignment operator of <tt>T</tt> or by any InputIterator operation there are 
no effects.
<span  style="color:#C80000;font-weight:bold">
If an exception is thrown while inserting a single element at the end and <tt>T</tt> 
is <tt>CopyInsertable</tt> or <tt>is_nothrow_move_constructible&lt;T&gt;::value</tt>
is true, there are no effects. Otherwise, if an exception is thrown by the move constructor of a
non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
</span>
</p>
</blockquote>
</blockquote>
<p>
The wording leads to the following problem:
Copy and move assignment are invoked directly from <tt>vector</tt>.
For intermediary objects (see <a href="lwg-active.html#2164">2164</a>),
<tt>vector</tt> also directly invokes the copy and move constructor of the value type.
However, construction of the actual element within the buffer is invoked via the allocator abstraction.
As discussed above, the allocator currently is not required to call a copy/move constructor.
If <tt>is_nothrow_move_constructible&lt;T&gt;::value</tt> is <tt>true</tt> for some value type <tt>T</tt>,
but the allocator uses modifying operations for <tt>MoveInsertion</tt> that do throw,
the implementation is required to ensure that "there are no effects",
even if the source buffer has been modified.
<p/>
Similarly, the <tt>vector</tt> capacity functions specify exception safety guarantees
referring to the move constructor of the value type. For example, <tt>vector::resize</tt> in 23.3.11.3 [vector.capacity] p14:
</p>
<blockquote>
<i>Remarks</i>: If an exception is thrown other than by the move constructor of a
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.
</blockquote>
<p>
The wording leads to the same issue as described above.
<p/>
Code example:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
class allocator;

class pot_reg_type // a type which creates
                   // potentially registered instances
{
private:
  friend class allocator&lt;pot_reg_type&gt;;
  struct register_t {};

  static std::set&lt;pot_reg_type*&gt;&amp; get_registry()
  {
    static std::set&lt;pot_reg_type*&gt; registry;
    return registry;
  }
  void enregister() noexcept(false)
  {
    get_registry().insert(this);
  }
  void deregister()
  {
    get_registry().erase(this);
  }

public:
  pot_reg_type(void               ) noexcept(true) {}
  pot_reg_type(pot_reg_type const&amp;) noexcept(true) {}
  pot_reg_type(pot_reg_type&amp;&amp;     ) noexcept(true) {}

private:
  pot_reg_type(register_t                     ) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type const&amp;) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type&amp;&amp;     ) noexcept(false)
  { enregister(); }
};

template&lt;class T&gt;
class allocator
{
public:
  using value_type = T;

  value_type* allocate(std::size_t p)
  { return (value_type*) ::operator new(p); }

  void deallocate(value_type* p, std::size_t)
  { ::operator delete(p); }

  void construct(pot_reg_type* pos)
  {
    new((void*)pos) pot_reg_type((pot_reg_type::register_t()));
  }
  void construct(pot_reg_type* pos, pot_reg_type const&amp; source)
  {
    new((void*)pos) pot_reg_type(pot_reg_type::register_t(), source);
  }

  template&lt;class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args)
  {
    new((void*)p) T(std::forward&lt;Args&gt;(args)...);
  }
}; 
</pre>
</blockquote>
<p>
The <tt>construct</tt> member function template is only required for rebinding,
which can be required e.g. to store additional debug information in
the allocated memory (e.g. VS2013).
<p/>
Even though the value type has an accessible and <tt>noexcept(true)</tt> move
constructor, this allocator won't call that constructor for rvalue arguments.
In any case, it does not call a constructor for which vector has formulated its 
requirements. An exception thrown by a constructor called by this allocator is not
covered by the specification in 23.3.11.5 [vector.modifiers] and therefore is
guaranteed not to have any effect on the vector object when resizing.
<p/>
For an example how this might invalidate the exception safety
guarantees, see <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/BcM7ya8JeqY/discussion">this post on the std-discussion mailing list</a>.
<p/>
Another problem arises for value types whose constructors are private,
but may be called by the allocator e.g. via friendship.
Those value types are not <tt>MoveConstructible</tt> 
(<tt>is_move_constructible</tt> is false), yet they can be <tt>MoveInsertable</tt>.
It is not possible for <tt>vector</tt> to create intermediary objects (see <a href="lwg-active.html#2164">2164</a>) of such a type
by directly using the move constructor.
Current implementations of the single-element forms of <tt>vector::insert</tt> and <tt>vector::emplace</tt>
do create intermediary objects by directly calling one of the value type's constructors,
probably to allow inserting objects from references that alias other elements of the container.
As far as I can see, Table 100 &mdash; "Sequence container requirements" in 23.2.3 [sequence.reqmts]
does not require that the creation of such intermediare objects can be performed
by containers using the value type's constructor directly.
It is unclear to me if the allocator's construct function could be used to create those
intermediary objects, given that they have not been allocated by the allocator.
<p/>
Two possible solutions:
</p>
<ol>
<li><p>
Add the following requirement to the <tt>allocator_traits::construct</tt> function:
If the parameter pack <tt>args</tt> consists of a single parameter of the type
<tt>value_type&amp;&amp;</tt>,
the function may only propagate exceptions if <tt>is_nothrow_move_constructible&lt;value_type&gt;::value</tt>
is <tt>false</tt>.
<p/>
Requiring <tt>alloctor_traits::construct</tt> to call a true copy/move constructor
of the value type breaks <tt>std::scoped_allocator_adapter</tt>,
as pointed out by <a href="https://groups.google.com/a/isocpp.org/d/msg/std-discussion/0yxikZInp-E/Lxj-msFT22cJ">Casey Carter in a post on the std-discussion mailing list</a>.
</p></li>
<li>
<p>
Change vector's criterion whether to move or copy when resizing:
<p/>
Instead of testing the value type's constructors via
<tt>is_move_constructible</tt>, check the value of
<tt>noexcept( allocator_traits&lt;Allocator&gt;::construct(alloc, ptr, rval) )</tt>
where
<tt>alloc</tt> is an lvalue of type <tt>Allocator</tt>,
<tt>ptr</tt> is an expression of type <tt>allocator_traits&lt;Allocator&gt;::pointer</tt>
and
<tt>rval</tt> is a non-const rvalue of type <tt>value_type</tt>.
</p>
</li>
</ol>
<p>
A short discussion of the two solutions:
<p/>
Solution 1 allows keeping <tt>is_nothrow_move_constructible&lt;value_type&gt;</tt>
as the criterion for <tt>vector</tt> to decide between copying and moving when resizing.
It restricts what can be done inside the <tt>construct</tt> member function of allocators,
and requires implementers of allocators to pay attention to the value types used.
One could conceive allocators checking the following with a <tt>static_assert</tt>:
If the value type <tt>is_nothrow_move_constructible</tt>,
then the constructor actually called for <tt>MoveInsertion</tt> within the <tt>construct</tt>
member function is also declared as noexcept.
<p/>
Solution 2 requires changing both the implementation of the default
allocator (add a conditional <tt>noexcept</tt>) and <tt>vector</tt> (replace
<tt>is_move_constructible</tt> with an allocator-targeted check).
It does not impose additional restrictions on the allocator (other than
23.2.1 [container.requirements.general] p15),
and works nicely even if the move constructor of a <tt>MoveInsertable</tt> type is private or deleted
(the allocator might be a friend of the value type).
<p/>
In both cases, an addition might be required to provide the basic exception safety guarantee.
A short discussion on this topic can be found
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/yZLnYy_y2z0/discussion">
in the std-discussion mailing list</a>.
Essentially, if <tt>allocator_traits&lt;Allocator&gt;::construct</tt> throws an exception,
the object may or may not have been constructed.
Two solutions are mentioned in that discussion:
</p>
<ol>
<li><p>
<tt>allocator_traits&lt;Allocator&gt;::construct</tt> needs to tell its caller
whether or not the construction was successful, in case of an exception.
</p></li>
<li><p>
If <tt>allocator_traits&lt;Allocator&gt;::construct</tt> propagates an exception,
it shall either not have constructed an object at the specified location,
or that object shall have been destroyed
(or it shall ensure otherwise that no resources are leaked).
</p></li>
</ol>

<p><i>[2015-05-23, Tomasz Kami&nacute;ski comments]</i></p>

<p>
Solution 1 discussed in this issue also breaks support for the <tt>polymorphic_allocator</tt> proposed in the part 
of the Library Fundamentals TS v1, in addition to already mentioned <tt>std::scoped_allocator_adapter</tt>. Furthermore 
there is unknown impact on the other user-defined state-full allocators code written in the C++11.
<p/>
In addition the library resolution proposed in the LWG issues <a href="lwg-active.html#2089">2089</a> and 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a>, 
will break the relation between the <tt>std::allocator_trait::construct</tt> method and 
copy/move constructor even for the standard <tt>std::allocator</tt>. As example please consider following class:
</p>
<blockquote><pre>
struct NonCopyable
{
  NonCopyable() = default;
  NonCopyable(NonCopyable const&amp;) = delete;
  NonCopyable(NonCopyable&amp;&amp;) = delete;
};

struct InitListConstructor : NonCopyable
{
  InitListConstructor() = default;
  InitListConstructor(std::initializer_list&lt;int&gt;);
  operator int() const;
};
</pre></blockquote>
<p>
For the above declarations following expression are ill-formed:
</p>
<blockquote><pre>
InitListConstructor copy(std::declval&lt;InitListConstructor const&amp;&gt;());
InitListConstructor move(std::declval&lt;InitListConstructor&amp;&amp;&gt;());
</pre></blockquote>
<p>
So the class is not <tt>CopyConstructible</tt> nor <tt>MoveConstructible</tt>. However the following are well formed:
</p>
<blockquote><pre>
InitListConstructor copy{std::declval&lt;InitListConstructor const&amp;&gt;()};
InitListConstructor move{std::declval&lt;InitListConstructor&amp;&amp;&gt;()};
</pre></blockquote>
<p>
And will be used by <tt>std::allocator&lt;InitListConstructor&gt;::construct</tt> in case of move-insertion 
and copy-insertion, after appliance of the resolution proposed in mentioned papers:
</p>
<blockquote>
<p>
The gist of the proposed library fix is simple:
</p>
<ul>
<li><p>if <tt>is_constructible_v&lt;TargetType, Args...&gt;</tt>, use direct-nonlist-initialization</p></li>
<li><p>otherwise, use brace-initialization.</p></li>
</ul>
</blockquote>
<p>
As consequence the requirement proposed in the Solution 1:
</p>
<blockquote><p>
If the parameter pack <tt>args</tt> consists of a single parameter of the type <tt>value_type&amp;&amp;</tt>, 
the function may only propagate exceptions if <tt>is_nothrow_move_constructible&lt;value_type&gt;::value</tt> is false. 
</p></blockquote>
<p>
Will no longer hold for the <tt>std::allocator</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2465" href="#2465">2465.</a> SFINAE-friendly <tt>common_type</tt> is nearly impossible to specialize
correctly and regresses key functionality</h3>
<p><b>Section:</b> 20.15.7.6 [meta.trans.other] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2015-01-12 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think there's a defect regarding <tt>common_type</tt> and its specializations.
Unless I've missed it, there is nothing preventing folks from
instantiating <tt>common_type</tt> with <i>cv</i>-qualified types or reference types. In
fact, the wording in N3797 explicitly mentions <i>cv</i> <tt>void</tt>, so presumably at
least <i>cv</i> qualifications are allowed.
<p/>
Users are given license to specialize <tt>common_type</tt> when at least of of
the types is user-defined. (A separate issue is the meaning of
user-defined. In core, I believe this is any class/struct/union/enum,
but in lib, I think it means any type not defined in std, right?) There
is at least one place in the standard that specializes <tt>common_type</tt>
(time.traits.specializations) on time_point and duration. But the
specializations are only for non-<i>cv</i>-qualified and non-reference
specializations of <tt>time_point</tt> and <tt>duration</tt>.
<p/>
If the user uses, say, <tt>common_type&lt;duration&lt;X,Y&gt; const, duration&lt;A,B&gt;
const&gt;</tt>, they're not going to get the behavior they expect.
<p/>
Suggest we clarify the requirements of <tt>common_type</tt>'s template
parameters. Also, perhaps we can add blanket wording that <tt>common_type&lt;A
[<i>cv</i>][&amp;], B [<i>cv</i>][&amp;]&gt;</tt> is required to be equivalent to 
<tt>common_type&lt;A,B&gt;</tt> (if that is in fact the way we intent this to work).
<p/>
Also, the change to make <tt>common_type</tt> SFINAE-friendly regressed key
functionality, as noted by Agust&iacute;n K-ballo Berg&eacute; in 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=37178">c++std-lib-37178</a>.
Since <tt>decay_t</tt> is not applied until the very end of the type computation,
user specializations are very likely to to be found.
<p/>
Agust&iacute;n says:
</p>
<blockquote class="note">
<p>
Consider the following snippet:
</p>
<blockquote>
<pre>
struct X {};
struct Y { explicit Y(X){} };

namespace std {
  template&lt;> struct common_type&lt;X, Y> { typedef Y type; };
  template&lt;> struct common_type&lt;Y, X> { typedef Y type; };
}

static_assert(is_same&lt;common_type_t&lt;X, Y>, Y>()); // (A)
static_assert(is_same&lt;common_type_t&lt;X, Y, Y>, Y>()); // (B)
static_assert(is_same&lt;common_type_t&lt;X, X, Y>, Y>()); // (C)
</pre>
</blockquote>
<p>
Under the original wording, all three assertion holds. Under the current wording,
</p>
<ul>
<li><p>(A) picks the user-defined specialization, so the assertion holds.</p></li>

<li><p>(B) goes to the third bullet and, ignoring the user-defined specialization, looks for 
<tt>decltype(true ? declval&lt;X&gt;() : declval&lt;Y&gt;())</tt>; since it is ill-formed 
there is no common type.</p></li>

<li><p>(C) goes to the third bullet and yields <tt>common_type_t&lt;X&amp;&amp;, Y&gt;</tt>, which again misses 
the user-defined specialization.</p></li>
</ul>
</blockquote>
<p>
The discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=35636">c++std-lib-35636</a> 
seemed to cohere around the idea that the primary <tt>common_type</tt> specialization should have the effect
of stripping top-level ref and <i>cv</i> qualifiers by applying <tt>std::decay_t</tt> to its arguments and, 
if any of them change as a result of that transformation, re-dispatching to <tt>common_type</tt> on those transformed
arguments, thereby picking up any user-defined specializations. This change to <tt>common_type</tt> would make 
the specializations in time.traits.specializations sufficient.
<p/>
<b>Suggested wording</b>:
<p/>
I'm afraid I don't know enough to suggest wording. But for exposition,
the following is my best shot at implementing the suggested resolution.
I believe it also fixes the regression noted by Agust&iacute;n K-ballo Berg&eacute; in
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=37178">c++std-lib-37178</a>.
</p>
<blockquote>
<pre>
namespace detail
{
    template&lt;typename T, typename U&gt;
    using default_common_t =
        decltype(true? std::declval&lt;T&gt;() : std::declval&lt;U&gt;());

    template&lt;typename T, typename U, typename Enable = void&gt;
    struct common_type_if
    {};

    template&lt;typename T, typename U&gt;
    struct common_type_if&lt;T, U,
      void_t&lt;default_common_t&lt;T, U&gt;&gt;&gt;
    {
      using type = decay_t&lt;default_common_t&lt;T, U&gt;&gt;;
    };

    template&lt;typename T, typename U,
       typename TT = decay_t&lt;T&gt;, typename UU = decay_t&lt;U&gt;&gt;
    struct common_type2
      : common_type&lt;TT, UU&gt; // Recurse to catch user specializations
    {};

    template&lt;typename T, typename U&gt;
    struct common_type2&lt;T, U, T, U&gt;
      : common_type_if&lt;T, U&gt;
    {};

    template&lt;typename Meta, typename Enable = void&gt;
    struct has_type
      : std::false_type
    {};

    template&lt;typename Meta&gt;
    struct has_type&lt;Meta, void_t&lt;typename Meta::type&gt;&gt;
      : std::true_type
    {};

    template&lt;typename Meta, typename...Ts&gt;
    struct common_type_recurse
      : common_type&lt;typename Meta::type, Ts...&gt;
    {};

    template&lt;typename Meta, typename...Ts&gt;
    struct common_type_recurse_if
      : std::conditional&lt;
          has_type&lt;Meta>::value,
          common_type_recurse&lt;Meta, Ts...&gt;,
          empty
        >::type
    {};
}

template&lt;typename ...Ts&gt;
struct common_type
{};

template&lt;typename T>
struct common_type&lt;T>
{
  using type = std::decay_t&lt;T&gt;;
};

template&lt;typename T, typename U&gt;
struct common_type&lt;T, U&gt;
  : detail::common_type2&lt;T, U&gt;
{};

template&lt;typename T, typename U, typename... Vs&gt;
struct common_type&lt;T, U, Vs...&gt;
  : detail::common_type_recurse_if&lt;common_type&lt;T, U&gt;, Vs...&gt;
{};
</pre>
</blockquote>
<p><i>[2016-08 Chicago]</i></p>

<p>Walter and Nevin provide wording.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p><i>[This also resolves the first part of <a href="lwg-active.html#2460">2460</a>]</i></p>


<p>In Table 46 of N4604, entry for <tt>common_type</tt>:</p>

<blockquote><p>
... may specialize this trait if at least one template parameter in the specialization is a user-defined type <ins>and no template parameter is cv-qualified</ins>.
</p></blockquote>

<p>In [meta.trans.other] bullet 3.3:</p>

<blockquote><p>
... whose second operand is an xvalue of type <del><tt>T1</tt></del><ins><tt>decay_t&lt;T1&gt;</tt></ins>, and whose third operand is an xvalue of type <del><tt>T2</tt></del><ins><tt>decay_t&lt;T2&gt;</tt></ins>.  If ...
</p></blockquote>
</blockquote>

<p><i>[2016-08-02, Chicago: Walt, Nevin, Rob, and Hal provide revised wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<p><i>[This also resolves the first part of LWG <a href="lwg-active.html#2460">2460</a>]</i></p>


<ol>
<li><p>In Table 46 &mdash; "Other transformations" edit the entry for <tt>common_type</tt>:</p>

<blockquote>
<table border="1">
<caption>Table 46 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td>
The member typedef <tt>type</tt> shall be defined or omitted as specified below.<br/>
If it is omitted, there shall be no member <tt>type</tt>. All types in the<br/>
parameter pack <tt>T</tt> shall be complete or (possibly <i>cv</i>) <tt>void</tt>.<br/> 
A program may specialize this trait <ins>for two <i>cv</i>-unqualified non-reference types</ins><br/> 
if at least one <del>template parameter in the specialization</del><ins>of them</ins><br/> 
is a user-defined type. [<i>Note:</i> Such specializations are<br/>
needed when only explicit conversions are desired among the template<br/>
arguments. &mdash; <i>end note</i>]
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit 20.15.7.6 [meta.trans.other] p3 (and its subbullets) as shown below</p>

<blockquote>
<p>
For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the member <tt>type</tt> 
shall be either defined or not present as follows:
</p>
<ul>
<li><p>If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p><ins>If <tt>sizeof...(T)</tt> is two, let <code>T1</code> and <code>T2</code>, respectively,
denote the first and second types comprising <code>T</code>, and let <code>D1</code> and <code>D2</code>, 
respectively, denote <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>.</ins></p>
<ul>
<li><p><ins>If <code>is_same_v&lt;T1, D1&gt;</code>
and <code>is_same_v&lt;T2, D2&gt;</code>,
and if there is no specialization
<code>common_type&lt;T1, T2&gt;</code>,
let <code>C</code> denote the type, if any,
of an unevaluated conditional expression (5.16 [expr.cond])
whose first operand is an arbitrary value of type <code>bool</code>,
whose second operand is an xvalue of type <code>D1</code>,
and whose third operand is an xvalue of type <code>D2</code>.
If there is such a type <code>C</code>,
the member typedef <code>type</code>
shall denote <code>C</code>.
Otherwise, there shall be no member <code>type</code>.</ins></p></li>
<li><p><ins>If <code>not is_same_v&lt;T1, D1&gt;</code>
or <code>not is_same_v&lt;T2, D2&gt;</code>,
the member typedef <code>type</code>
shall denote the same type, if any, as <tt>common_type_t&lt;D1, D2&gt;</tt>.
Otherwise, there shall be no member <code>type</code>.</ins></p></li>
</ul>
</li>
<li><p>If <tt>sizeof...(T)</tt> is greater than <del>one</del><ins>two</ins>, let <tt>T1</tt>, <tt>T2</tt>, and <tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
<del>[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is an xvalue of type <tt>T1</tt>, and whose third operand is 
an xvalue of type <tt>T2</tt>.</del> <ins>Let <code>C</code> denote <code>common_type_t&lt;T1, T2&gt;</code>.</ins> 
If there is such a type <tt>C</tt>, the member typedef <tt>type</tt> 
shall denote the same type, if any, as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall 
be no member <tt>type</tt>.</p></li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
LWG asks for minor wording tweaks and for an added Note.
Walter revises the Proposed Resolution accordingly.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<p><i>[This also resolves the first part of LWG <a href="lwg-active.html#2460">2460</a>]</i></p>


<ol>
<li><p>In Table 46 &mdash; "Other transformations" edit the entry for <tt>common_type</tt>:</p>

<blockquote>
<table border="1">
<caption>Table 46 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td>
The member typedef <tt>type</tt> shall be defined or omitted as specified below.<br/>
If it is omitted, there shall be no member <tt>type</tt>. All types in the<br/>
parameter pack <tt>T</tt> shall be complete or (possibly <i>cv</i>) <tt>void</tt>.<br/> 
A program may specialize this trait <ins>for two <i>cv</i>-unqualified non-reference types</ins><br/> 
if at least one <del>template parameter in the specialization</del><ins>of them</ins><br/> 
is a user-defined type. [<i>Note:</i> Such specializations are<br/>
needed when only explicit conversions are desired among the template<br/>
arguments. &mdash; <i>end note</i>]
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit 20.15.7.6 [meta.trans.other] p3 (and its subbullets) as shown below</p>

<blockquote>
<p>
For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the member <tt>type</tt> 
shall be either defined or not present as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>(3.2) &mdash; If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p>(3.3) &mdash; <ins>If <tt>sizeof...(T)</tt> is two, let <code>T1</code> and <code>T2</code>, respectively,
denote the first and second types comprising <code>T</code>, and let <code>D1</code> and <code>D2</code>, 
respectively, denote <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>.</ins></p>
<ol style="list-style-type: none">
<li><p>(3.3.1) &mdash; <ins>If <code>is_same_v&lt;T1, D1&gt;</code> and <code>is_same_v&lt;T2, D2&gt;</code>,
let <code>C</code> denote the type of an unevaluated conditional expression (5.16 [expr.cond])
whose first operand is an arbitrary value of type <code>bool</code>,
whose second operand is an xvalue of type <code>D1</code>,
and whose third operand is an xvalue of type <code>D2</code>.
[<i>Note:</i> This will not apply if there is a specialization <code>common_type&lt;D1, D2&gt;</code>. &mdash; 
<i>end note</i>]</ins></p></li>
<li><p>(3.3.2) &mdash; <ins>Otherwise, let <code>C</code> denote the type
<code>common_type_t&lt;D1, D2&gt;</code>.</ins></p></li>
</ol>
<p><ins> In either case, if there is such a type <code>C</code>,
the member typedef <code>type</code> shall denote <code>C</code>.
Otherwise, there shall be no member <code>type</code>.</ins></p>
</li>
<li><p>(3.4) &mdash; If <tt>sizeof...(T)</tt> is greater than <del>one</del><ins>two</ins>, let <tt>T1</tt>, <tt>T2</tt>, and <tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
<del>[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is an xvalue of type <tt>T1</tt>, and whose third operand is 
an xvalue of type <tt>T2</tt>.</del> <ins>Let <code>C</code> denote <code>common_type_t&lt;T1, T2&gt;</code>.</ins> 
If there is such a type <tt>C</tt>, the member typedef <tt>type</tt> 
shall denote the same type, if any, as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall 
be no member <tt>type</tt>.</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2472" href="#2472">2472.</a> Heterogeneous comparisons in the standard library can result in ambiguities</h3>
<p><b>Section:</b> 20.5.2.8 [tuple.rel], 20.10.9.2 [allocator.globals], 20.11.1.5 [unique.ptr.special], 20.11.2.2.7 [util.smartptr.shared.cmp], 20.17.5.6 [time.duration.comparisons], 20.17.6.6 [time.point.comparisons], 20.13.5 [scoped.adaptor.operators], 24.5.1.3.13 [reverse.iter.op==], 24.5.3.3.13 [move.iter.op.comp] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-02-07 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library specifies a lot of heterogeneous comparison operators. For instance:
</p>
<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre>
</blockquote>
<p>
This has an unfortunate consequence:
</p>
<blockquote>
<pre>
#include &lt;tuple&gt;
#include &lt;utility&gt;

using namespace std::rel_ops;
std::tuple&lt;int&gt; a(0);
bool b = a != a;
</pre>
</blockquote>
<p>
The last line here is ill-formed due to ambiguity: it might be <tt>rel_ops::operator!=</tt>, and it might be the 
heterogeneous tuple <tt>operator!=</tt>. These are not partially ordered, because they have different constraints: 
<tt>rel_ops</tt> requires the types to match, whereas the tuple comparison requires both types to be tuples (but not 
to match). The same thing happens for user code that defines its own unconstrained 
'<tt>template&lt;typename T&gt; operator!=(const T&amp;, const T&amp;)</tt>' rather than using <tt>rel_ops</tt>.
<p/>
One straightforward fix would be to add a homogeneous overload for each heterogeneous comparison:
</p>
<blockquote>
<pre>
template&lt;class... TTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;TTypes...&gt;&amp;);
</pre>
<p>
This is then unambiguously chosen over the other options in the preceding case. FWIW, libstdc++ already does this 
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.4/libstdc++/api/a01065_source.html#l00788">in some cases</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2475" href="#2475">2475.</a> Allow overwriting of <tt>std::basic_string</tt> terminator with <tt>charT()</tt> to allow 
cleaner interoperation with legacy APIs</h3>
<p><b>Section:</b> 21.3.1.5 [string.access] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Weber <b>Opened:</b> 2015-02-21 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.access">issues</a> in [string.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is often desirable to use a <tt>std::basic_string</tt> object as a buffer when interoperating with libraries 
that mutate null-terminated arrays of characters. In many cases, these legacy APIs write a null terminator at 
the specified end of the provided buffer. Providing such a function with an appropriately-sized 
<tt>std::basic_string</tt> results in undefined behavior when the <tt>charT</tt> object at the <tt>size()</tt> 
position is overwritten, even if the value remains unchanged.
<p/>
Absent the ability to allow for this, applications are forced into pessimizations such as: providing 
appropriately-sized <tt>std::vectors</tt> of <tt>charT</tt> for interoperating with the legacy API, and then 
copying the <tt>std::vector</tt> to a <tt>std::basic_string</tt>; providing an oversized <tt>std::basic_string</tt> 
object and then calling <tt>resize()</tt> later.
<p/>
A trivial example:
</p>
<blockquote>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

void legacy_function(char *out, size_t count) {
  for (size_t i = 0; i &lt; count; ++i) {
    *out++ = '0' + (i % 10);
  }
  *out = '\0'; // <span style="color:#C80000;font-weight:bold">if size() == count, this results in undefined behavior</span>
}

int main() {
  std::string s(10, '\0');
  legacy_function(&amp;s[0], s.size()); // <span style="color:#C80000;font-weight:bold">undefined behavior</span>

  std::vector&lt;char&gt; buffer(11);
  legacy_function(&amp;buffer[0], buffer.size() - 1);
  std::string t(&amp;buffer[0], buffer.size() - 1); // potentially expensive copy

  std::string u(11, '\0');
  legacy_function(&amp;u[0], u.size() - 1);
  u.resize(u.size() - 1); // needlessly complicates the program's logic
}
</pre>
</blockquote>
<p>
A slight relaxation of the requirement on the returned object from the element access operator would 
allow for this interaction with no semantic change to existing programs.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Tues PM: This should also apply to non-const <tt>data()</tt>. Billy to update wording.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit 21.3.1.5 [string.access] as indicated:</p>
<blockquote>
<pre>
const_reference operator[](size_type pos) const;
reference operator[](size_type pos);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: [&hellip;]
<p/>
-2- <i>Returns</i>: <tt>*(begin() + pos) if pos &lt; size()</tt>. Otherwise, returns a reference to an object of type
<tt>charT</tt> with value <tt>charT()</tt>, where modifying the object <ins>to any value other than <tt>charT()</tt></ins> 
leads to undefined behavior.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2478" href="#2478">2478.</a> Unclear how <tt>wstring_convert</tt> uses <tt>cvtstate</tt></h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How do <tt>wstring_convert::from_bytes</tt> and <tt>wstring_convert::to_bytes</tt> use
the <tt>cvtstate</tt> member?
<p/>
Is it passed to the <tt>codecvt</tt> member functions? Is a copy of it passed
to the member functions? "Otherwise it shall be left unchanged"
implies a copy is used, but if that's really what's intended there are
simpler ways to say so.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2479" href="#2479">2479.</a> Unclear how <tt>wbuffer_convert</tt> uses <tt>cvtstate</tt></h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.buffer">active issues</a> in [conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.buffer">issues</a> in [conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How does <tt>wbuffer_convert</tt> use the <tt>cvtstate</tt> member?
<p/>
Is the same conversion state object used for converting both the get
and put areas? That means a read which runs out of bytes halfway 
through a multibyte character will leave some shift state in cvtstate, 
which would then be used by a following write, even though the shift 
state of the get area is unrelated to the put area.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2480" href="#2480">2480.</a> Error handling of <tt>wbuffer_convert</tt> unclear</h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.buffer">active issues</a> in [conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.buffer">issues</a> in [conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If a <tt>codecvt</tt> conversion returns <tt>codecvt_base::error</tt> should that be
treated as <tt>EOF</tt>? An exception? Should all the successfully converted
characters before a conversion error be available to the users of the
<tt>wbuffer_convert</tt> and/or the internal <tt>streambuf</tt>, or does a conversion
error lose information?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2481" href="#2481">2481.</a> <tt>wstring_convert</tt> should be more precise regarding "byte-error string" etc.</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 4 of 22.3.3.2.2 [conversions.string] introduces <tt>byte_err_string</tt> 
as "a byte string to display on errors". What does display mean? The string is returned 
on error, it's not displayed anywhere.
<p/>
Paragraph 14 says "Otherwise, if the object was constructed with a
byte-error string, the member function shall return the byte-error
string." The term byte-error string is not used anywhere else.
<p/>
Paragraph 17 talks about storing "default values in <tt>byte_err_string</tt>".
What default value? Is "Hello, world!" allowed? If it means
default-construction it should say so. If paragraph 14 says it won't
be used what does it matter how it's initialized? The end of the
paragraph refers to storing "<tt>byte_err</tt> in <tt>byte_err_string</tt>". This should
be more clearly related to the wording in paragraph 14.
<p/>
It might help if the constructor (and destructor) was specified before
the other member functions, so it can more formally define the
difference between being "constructed with a byte-error string" and
not.
<p/>
All the same issues apply to the <tt>wide_err_string</tt> member.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2490" href="#2490">2490.</a> <tt>&lt;regex&gt;</tt> needs lots of <tt>noexcept</tt></h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2015-03-27 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Only 4 functions are marked <tt>noexcept</tt> in all of Clause 28. Many more need to be marked &mdash; for example, 
<tt>regex_error::code()</tt>, <tt>basic_regex::swap()</tt>, and <tt>sub_match::length()</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2491" href="#2491">2491.</a> <tt>std::less&lt;T*&gt;</tt> in constant expression</h3>
<p><b>Section:</b> 20.14.6 [comparisons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-04-01 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not entirely clear if and when the specializations of <tt>std::less</tt> (and friends) for pointer types 
can be used in a constant expression. Consider the following code:
</p>
<blockquote><pre>
#include &lt;functional&gt;

struct foo {};
foo x, y;
constexpr bool b = std::less&lt;foo*&gt;{}(&amp;x, &amp;y); // [1]

foo z[] = {{}, {}};
constexpr bool ba = std::less&lt;foo*&gt;{}(&amp;z[0], &amp;z[1]); // [2]
</pre></blockquote>
<p>
Comparing the address of unrelated objects is not a constant expression since the result is unspecified, so 
it could be expected for [1] to fail and [2] to succeed. However, <tt>std::less</tt> specialization for pointer 
types is well-defined and yields a total order, so it could just as well be expected for [1] to succeed. Finally, 
since the implementation of such specializations is not mandated, [2] could fail as well (This could happen, if
an implementation would provide such a specialization and if that would use built-in functions that would not be
allowed in constant expressions, for example). In any case, the standard should be clear so as to avoid 
implementation-defined <tt>constexpr</tt>-ness.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2493" href="#2493">2493.</a> <tt>initializer_list</tt> supports incomplete classes</h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-04-27 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The typical use-case of <tt>std::initializer_list&lt;T&gt;</tt> is for a pass-by-value parameter of <tt>T</tt>'s constructor. 
However, this contravenes 17.6.4.8 [res.on.functions]/2.5 because <tt>initializer_list</tt> doesn't specifically allow 
incomplete types (as do for example <tt>std::unique_ptr</tt> (20.11.1 [unique.ptr]/5) and 
<tt>std::enable_shared_from_this</tt> (20.11.2.5 [util.smartptr.enab]/2)).
<p/>
A resolution would be to copy-paste the relevant text from such a paragraph.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2496" href="#2496">2496.</a> Certain hard-to-avoid errors not in the immediate context are not allowed to be triggered by 
the evaluation of type traits</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-07 <b>Last modified:</b> 2015-08-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I do not believe that the wording in 20.15.4.3 [meta.unary.prop] paragraph 3 allows for the following program to be ill-formed:
</p>
<blockquote>
<pre>
#include &lt;type_traits&gt;

template &lt;typename T&gt; struct B : T { };
template &lt;typename T&gt; struct A { A&amp; operator=(const B&lt;T&gt;&amp;); };

std::is_assignable&lt;A&lt;int&gt;, int&gt; q;
</pre>
</blockquote>
<p>
In particular, I do not see where the wording allows for the "compilation of the expression" 
<tt>declval&lt;T&gt;() = declval&lt;U&gt;()</tt> to occur as a consequence of instantiating <tt>std::is_assignable&lt;T, U&gt;</tt> 
(where <tt>T</tt> and <tt>U</tt> are, respectively, <tt>A&lt;int&gt;</tt> and <tt>int</tt> in the example code).
<p/>
Instantiating <tt>A&lt;int&gt;</tt> as a result of requiring it to be a complete type does not trigger the instantiation of 
<tt>B&lt;int&gt;</tt>; however, the "compilation of the expression" in question does.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2497" href="#2497">2497.</a> Use of <tt>uncaught_exception()</tt></h3>
<p><b>Section:</b> 27.7.3.4 [ostream::sentry] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Roger Orr <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2015-09-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current 27.7.3.4 [ostream::sentry], p4 refers to the now deprecated <tt>std::uncaught_exception()</tt>: 
D.9 [depr.uncaught].
</p>
<blockquote>
<p>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception() &amp;&amp; os.good())</tt> is true, calls
<tt>os.rdbuf()->pubsync()</tt>.
</p>
</blockquote>
<p>
This needs to be changed, for example to use <tt>std::uncaught_exceptions()</tt> and to capture the value on entry and 
compare with the saved value on exit.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
JW: I already added an 's' here to make it use the new function, but that doesn't resolve Roger's suggestion to capture the value on entry and check it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2498" href="#2498">2498.</a> <tt>operator&gt;&gt;(basic_istream&amp;&amp;, T&amp;&amp;)</tt> returns <tt>basic_istream&amp;</tt>, but should probably return 
<tt>basic_istream&amp;&amp;</tt></h3>
<p><b>Section:</b> 27.7.2.6 [istream.rvalue] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2015-09-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.rvalue">issues</a> in [istream.rvalue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote>
<pre>
auto&amp; is = make_istream() &gt;&gt; x; // oops, istream object is already gone
</pre>
</blockquote>
<p>
With a <tt>basic_istream&amp;&amp;</tt> return type, the above would be ill-formed, and generally we'd 
preserve the value category properly.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
JW: think this needs proper consideration, it would make <pre>stream() &gt;&gt; x &gt;&gt; y &gt;&gt; z</pre> go from 3 operator&gt;&gt; calls to 6 operator&gt;&gt; calls, and wouldn't prevent dangling references (change the example to auto&amp;&amp;) <br/>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2499" href="#2499">2499.</a> <tt>operator&gt;&gt;(basic_istream&amp;, CharT*)</tt> makes it hard to avoid buffer overflows</h3>
<p><b>Section:</b> 27.7.2.2.3 [istream::extractors] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We removed <tt>gets()</tt> (due to an NB comment and C11 &mdash; bastion of backwards compatibility &mdash; doing the same). 
Should we remove this too?
<p/>
Unlike <tt>gets()</tt>, there are legitimate uses:
</p>
<blockquote>
<pre>
char buffer[32];
char text[32] = // ...
ostream_for_buffer(text) &gt;&gt; buffer; // ok, can't overrun buffer
</pre>
</blockquote>
<p>
&hellip; but the risk from constructs like "<tt>std::cin &gt;&gt; buffer</tt>" seems to outweigh the benefit.
<p/>
The issue had been discussed on the library reflector starting around 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=35541">c++std-lib-35541</a>.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>VV: Request a paper to deprecate / remove anything<br/></p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: This overload is evil and should probably die. </p>
<p>VV: I agree with that, even though I don't care.</p>
<p>STL: Say that we either remove it outright following the gets() rationale, or at least deprecate it.</p>
<p>Move to Open; needs a paper.</p>

<p><i>[2016-08, Chicago: Zhihao Yuan comments and provides wording]</i></p>

<p>
Rationale:
</p>
<ol>
<li><p>I would like to keep some reasonable code working;</p></li>
<li><p>Reasonable code includes two cases:</p>
<ol style="list-style-type:lower-alpha">
<li><p><tt>width() &gt; 0</tt>, any pointer argument</p></li>
<li><p><tt>width() &gt;= 0</tt>, array argument</p></li>
</ol>
</li>
<li><p>For a), banning bad code will become a silent behavior change at runtime; 
for b), it breaks at compile time.</p></li>
</ol>
<p>
I propose to replace these signatures with references to arrays.
An implementation may want to ship the old instantiatations in the
binary without exposing the old signatures.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Tues PM: General agreement on deprecating the unsafe call, but no consensus for the P/R.</p>
<p>General feeling that implementation experience would be useful.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 27.7.2.2.3 [istream::extractors] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; in,
                                           <del>charT* s</del><ins>charT (&amp;s)[N]</ins>);
template&lt;class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;char, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char, traits&gt;&amp; in,
                                          <del>unsigned char* s</del><ins>unsigned char (&amp;s)[N]</ins>);
template&lt;class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;char, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char, traits&gt;&amp; in,
                                          <del>signed char* s</del><ins>signed char (&amp;s)[N]</ins>);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Behaves like a formatted input member (as described in 27.7.2.2.1 [istream.formatted.reqmts]) 
of <tt>in</tt>. After a <tt>sentry</tt> object is constructed, <tt>operator&gt;&gt;</tt> extracts characters and 
stores them into <del>successive locations of an array whose first element is designated by</del> <tt>s</tt>. If <tt>width()</tt> 
is greater than zero, <tt>n</tt> is <tt><del>width()</del><ins>min(size_t(width()), N)</ins></tt>. Otherwise 
<tt>n</tt> is <del>the number of elements of the largest 
array of <tt>char_type</tt> that can store a terminating <tt>charT()</tt></del><ins><tt>N</tt></ins>. <tt>n</tt> is the 
maximum number of characters stored.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2504" href="#2504">2504.</a> <tt>basic_streambuf</tt> is not an abstract class</h3>
<p><b>Section:</b> 27.6.3 [streambuf] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2015-08-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#streambuf">active issues</a> in [streambuf].</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.6.3 [streambuf] p1 says:
</p>
<blockquote><p>
The class template <tt>basic_streambuf&lt;charT, traits&gt;</tt> serves as an abstract base class for deriving various
stream buffers whose objects each control two character sequences: [&hellip;]
</p></blockquote>
<p>
The term "abstract base class" is not defined in the standard, but "abstract class" is (10.4 [class.abstract]).
<p/>
According to the synopsis <tt>basic_streambuf</tt> has no pure virtual
functions so is not an abstract class and none of libstdc++, libc++, or
dinkumware implement it as an abstract class. I don't believe the wording was
ever intended to require it to be an abstract class, but it could be
read that way.
<p/>
I suggest the wording be changed to "polymorphic base class" or
something else that can't be seen to imply a normative requirement to
make it an abstract class.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2505" href="#2505">2505.</a> <tt>auto_ptr_ref</tt> creation requirements underspecified</h3>
<p><b>Section:</b> 99 [auto.ptr.conv] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr.conv">issues</a> in [auto.ptr.conv].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++14 sub-clause 99 [auto.ptr.conv], there appears to be no requirement that the formation of an 
<tt>auto_ptr_ref&lt;Y&gt;</tt> from an <tt>auto_ptr&lt;X&gt;</tt> is done only when <tt>X*</tt> can be implicitly 
converted to <tt>Y*</tt>.
<p/>
For example, I expect formation of the <tt>auto_ptr_ref&lt;A&gt;</tt> from the prvalue of type <tt>auto_ptr&lt;B&gt;</tt> 
to be invalid in the case below (but the wording does not seem to be there):
</p>
<blockquote><pre>
#include &lt;memory&gt;

struct A { };
struct B { } b;

std::auto_ptr&lt;B&gt; apB() { return std::auto_ptr&lt;B&gt;(&amp;b); }
int main() {
  std::auto_ptr&lt;A&gt; apA(apB());
  apA.release();
}
</pre></blockquote>
<p>
The behaviour of the implementation in question on the case presented above is to compile and execute it successfully 
(which is what the C++14 wording implies). The returned value from <tt>apA.release()</tt> is essentially 
<tt>reinterpret_cast&lt;A*&gt;(&amp;b)</tt>.
<p/>
There is nothing in the specification of
</p>
<blockquote><pre>
template &lt;class X&gt;
template &lt;class Y&gt; operator auto_ptr&lt;X&gt;::auto_ptr_ref&lt;Y&gt;() throw();
</pre></blockquote>
<p>
which implies that <tt>X*</tt> should be implicitly convertible to <tt>Y*</tt>.
<p/>
The implementation in question uses the <tt>reinterpret_cast</tt> interpretation even when <tt>Y</tt> is an accessible, 
unambiguous base class of <tt>X</tt>; the result thereof is that no offset adjustment is performed.
</p>

<p><i>[2015-07, Telecon]</i></p>

<p>
Marshall to resolve.
</p>

<p><i>[2016-03-16, Alisdair Meredith comments]</i></p>

<p>
This issue is a defect in a component we have actively removed
from the standard. I can't think of a clearer example of something
that is no longer a defect!
</p>

<p><i>[2016-08-03, Alisdair Meredith comments]</i></p>

<p>
As C++17 removes <tt>auto_ptr</tt>, I suggest closing this issue as closed by paper 
<a href="http://wg21.link/n4190">N4190</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to ISO/IEC 14882:2014(E).
</p>

<ol>
<li><p>Change 99 [auto.ptr.conv] as indicated:</p>

<blockquote>
<pre>
template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>X*</tt> can be implicitly converted to <tt>Y*</tt>.</ins>
<p/>
-3- <i>Returns</i>: An <tt>auto_ptr_ref&lt;Y&gt;</tt> that holds <tt>*this</tt>.
<p/>
<ins>-?- <i>Notes</i>: Because <tt>auto_ptr_ref</tt> is present for exposition only, the only way to invoke this function 
is by calling one of the <tt>auto_ptr</tt> conversions which take an <tt>auto_ptr_ref</tt> as an argument. Since all 
such conversions will call <tt>release()</tt> on <tt>*this</tt> (in the form of the <tt>auto_ptr</tt> that the 
<tt>auto_ptr_ref</tt> holds a reference to), an implementation of this function may cause instantiation of said 
<tt>release()</tt> function without changing the semantics of the program.</ins>
</p>
</blockquote>
<pre>
template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>X*</tt> can be implicitly converted to <tt>Y*</tt>.</ins>
<p/>
-4- <i>Effects</i>: Calls <tt>release()</tt>.
<p/>
-5- <i>Returns</i>: An <tt>auto_ptr&lt;Y&gt;</tt> that holds the pointer returned from <tt>release()</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2506" href="#2506">2506.</a> Underspecification of atomics</h3>
<p><b>Section:</b> 1.10 [intro.multithread], 29.5 [atomics.types.generic], 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2015-05-29 <b>Last modified:</b> 2015-09-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#intro.multithread">issues</a> in [intro.multithread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The concurrency libraries specified in clauses 29 and 30 do not adequately specify how they relate to the concurrency model 
specified in 1.10 [intro.multithread]. In particular:
<p/>
1.10 [intro.multithread] specifies "atomic objects" as having certain properties. I can only assume that instances 
of the classes defined in Clause 29 are intended to be "atomic objects" in this sense, but I can't find any wording to 
specify that, and it's genuinely unclear whether Clause 30 objects are atomic objects. In fact, on a literal reading the 
C++ Standard doesn't appear to provide <em>any</em> portable way to create an atomic object, or even determine whether an 
object is an atomic object.
<p/>
(It's not clear if the term "atomic object" is actually needed, given that atomic objects can have non-atomic operations, 
and non-atomic objects can have atomic operations. But even if the term itself goes away, there still needs to be some 
indication that Clause 29 objects have the properties currently attributed to atomic objects).
<p/>
Similarly, 1.10 [intro.multithread] uses "atomic operation" as a term of art, but the standard never unambiguously 
identifies any operation as an "atomic operation" (although in one case it unambiguously identifies an operation that is 
<em>not</em> atomic). It does come close in a few cases, but not close enough:
</p>
<ul>
<li><p>1.10 [intro.multithread]/p7 could be read to imply that "synchronization operations" in Clauses 29 and 30 
are also atomic operations. However, that's vague and indirect, and somewhat belied by 30.4.1.2 [thread.mutex.requirements.mutex]/p5, 
which specifies that mutex lock and unlock operations "behave as atomic operations", but only "for purposes of determining 
the existence of a data race". Furthermore, not a single operation in Clause 29 explicitly identifies itself as a 
"synchronization operation".</p></li>
<li><p>29.5 [atomics.types.generic]/p4 states in part that "There shall be a specialization <tt>atomic&lt;bool&gt;</tt> 
which provides the general atomic operations as specified in 29.6.1", but read in context, "general atomic operations" 
appears to be a loose synonym for "general operations on atomic types" as defined in 29.6.1 [atomics.types.operations.general], 
rather than a use of "atomic object" as Words of Power. Incidentally, "atomic type" is never satisfactorily defined either 
(although the <tt>&lt;atomic&gt;</tt> synopsis comes close).</p></li>
<li><p>18.10 [support.runtime]/p10 specifies exactly which operations are "plain lock-free atomic operations", but 
in a standard where an "integral constant expression" isn't necessarily a "constant expression", I do not feel safe assuming 
that a "plain lock-free atomic operation" is an "atomic operation".</p></li>
<li><p>Hans Boehm tells me the operations with "atomically" in the Effects element are intended to be atomic operations, 
but since "atomic operation" is a term of art (e.g. in 1.10 [intro.multithread]/p27.4), I think this needs to be 
spelled out rather than assumed. Furthermore, this does not help with 29.8 [atomics.fences], or anything in Clause 30.</p></li>
</ul>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2507" href="#2507">2507.</a> <tt>codecvt_mode</tt> should be a bitmask type</h3>
<p><b>Section:</b> 22.5 [locale.stdcvt] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-08 <b>Last modified:</b> 2015-08-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.stdcvt">issues</a> in [locale.stdcvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The enumeration type <tt>codecvt_mode</tt> is effectively a bitmask type
(17.5.2.1.3 [bitmask.types]) with three elements, but isn't defined as
such.
<p/>
This harms usability because bitmask types are required to work well
with bitwise operators, but <tt>codecvt_mode</tt> doesn't have overloaded
operators, making it very inconvenient to combine values:
</p>
<blockquote><pre>
std::codecvt_utf16&lt;char32_t, 0x10FFFF,
  static_cast&lt;std::codecvt_mode&gt;(std::little_endian|std::generate_header)&gt;
cvt;
</pre></blockquote>
<p>
The <tt>static_cast</tt> harms readability and should not be necessary.
<p/>
I suggest that either <tt>codecvt_mode</tt> is specified to be a bitmask type,
or as a minimal fix we provide an overloaded <tt>operator|</tt> that returns
the right type.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2508" href="#2508">2508.</a> &sect;[new.delete.dataraces] wording needs to be updated</h3>
<p><b>Section:</b> 18.6.2.4 [new.delete.dataraces] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2015-06-09 <b>Last modified:</b> 2016-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.dataraces">issues</a> in [new.delete.dataraces].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.6.2.4 [new.delete.dataraces] uses obsolete wording.
<p/>
It should introduce a "synchronizes with" relationship. "Happens before" is too weak, since that may not composes 
with sequenced before.
<p/>
The "shall not introduce a data race" wording is probably not technically correct either. These may race with other 
(non-allocation/deallocation) concurrent accesses to the object being allocated or deallocated.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2511" href="#2511">2511.</a> <tt>scoped_allocator_adaptor</tt> piecewise construction does not require <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 20.13.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-06-16 <b>Last modified:</b> 2015-08-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.13.4 [allocator.adaptor.members]/10 requires that the argument types in the piecewise-construction tuples 
all be <tt>CopyConstructible</tt>. These tuples are typically created by <tt>std::forward_as_tuple</tt>, such as in 
&para;13. So they will be a mix of lvalue and rvalue references, the latter of which are not <tt>CopyConstructible</tt>.
<p/>
My guess is that <tt>CopyConstructible</tt> was specified to feed the <tt>tuple_cat</tt>, before that function could 
handle rvalues. Since the argument tuple is already moved in &para;11, the requirement is obsolete. It should either 
be changed to <tt>MoveConstructible</tt>, or perhaps better, convert the whole tuple to references (i.e. form 
<tt>tuple&lt;Args1&amp;&amp;...&gt;</tt>) so nothing needs to be moved. After all, this is a facility for handling non-movable 
types.
<p/>
It appears that the resolution of DR <a href="lwg-defects.html#2203">2203</a>, which added <tt>std::move</tt> to &para;11, simply omitted the 
change to &para;10.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2512" href="#2512">2512.</a> Y2K bites; what is an "unambiguous year identifier"?</h3>
<p><b>Section:</b> 22.4.5.1.2 [locale.time.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-19 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.time.get.virtuals">issues</a> in [locale.time.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recently encountered a failure related to questionable use of <tt>do_get_year</tt>. The platform where the code happened 
to work had an implementation which handled certain three-digit "year identifiers" as the number of years since 
1900 (<a href="http://www.drdobbs.com/cpp/remembering-y2k/228701726">this article</a> describes such an implementation).
<p/>
22.4.5.1.2 [locale.time.get.virtuals] makes it implementation defined whether two-digit years are accepted, etc., but does not 
say anything specifically about three-digit years.
<p/>
The implementation freedom to not report errors in 22.4.5.1 [locale.time.get] paragraph 1 also seems to be too broad.
<p/>
See also the discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=38042">c++std-lib-38042</a>.
</p>

<p><i>[08-2016 - Chicago]</i></p>

<p>Wed PM: This has been this way since C++98. Don't think it's a P2.</p>
<p>Change to P4, and move to Open.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2513" href="#2513">2513.</a> Missing requirements for <tt>basic_string::value_type</tt></h3>
<p><b>Section:</b> 21.1 [strings.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-26 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings.general">issues</a> in [strings.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The allocator-aware container requirements in Table 98 impose no
<tt>MoveAssignable</tt> requirements on the <tt>value_type</tt> when
<tt>propagate_on_container_move_assignment</tt> is true, because typically the
container's storage would be moved by just exchanging some pointers.
<p/>
However for a <tt>basic_string</tt> using the small string optimization move
assignment may need to assign individual characters into the small
string buffer, even when the allocator propagates.
<p/>
The only requirement on the char-like objects stored in a <tt>basic_string</tt>
are that they are non-array POD types and <tt>Destructible</tt>, which means
that a POD type with a deleted move assignment operator should be
usable in a <tt>basic_string</tt>, despite it being impossible to move assign:
</p>
<blockquote><pre>
#include &lt;string&gt;

struct odd_pod 
{
  odd_pod() = default;
  odd_pod&amp; operator=(odd_pod&amp;&amp;) = delete;
};

static_assert(std::is_pod&lt;odd_pod&gt;::value, "POD");

int main()
{
  using S = std::basic_string&lt;odd_pod&gt;;
  S s;
  s = S{};       // fails
}
</pre></blockquote>
<p>
Using libstdc++ <tt>basic_string&lt;odd_pod&gt;</tt> cannot even be
default-constructed because the constructor attempts to assign the
null terminator to the first element of the small string buffer.
<p/>
Similar problems exist with POD types with a deleted default constructor.
<p/>
I believe that <tt>basic_string</tt> should require its <tt>value_type</tt> to be at
least <tt>DefaultConstructible</tt> and <tt>MoveAssignable</tt>.
</p>

<p><i>[2016-06, Oulu]</i></p>

<p>This should be resolved by <a href="http://wg21.link/P0178">P0178</a></p>
<p>Note: P0178 was sent back to LEWG in Oulu.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2514" href="#2514">2514.</a> Type traits must not be <tt>final</tt></h3>
<p><b>Section:</b> 20.15.1 [meta.rqmts] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-07-03 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We should make it clear that all standard <tt>UnaryTypeTraits</tt>,
<tt>BinaryTypeTraits</tt> and <tt>TransformationTraits</tt> are not <tt>final</tt>.
<p/>
Otherwise it is not safe to use them as arguments to a template like this:
</p>
<blockquote><pre>
template&lt;typename C1, typename C2&gt;
struct conjunction
  : conditional_t&lt;C1::value, C2, C1&gt;
{ };
</pre></blockquote>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.15.1 [meta.rqmts] as indicated:</p>

<blockquote>
<p>
-1- A <em>UnaryTypeTrait</em> describes a property of a type. It shall be a <ins>non-<code>final</code></ins> 
class template [&hellip;]
<p/>
-2- A <em>BinaryTypeTrait</em> describes a relationship between two types. It shall be a 
<ins>non-<code>final</code></ins> class template [&hellip;]
<p/>
-3- A <em>TransformationTrait</em> modifies a property of a type. It shall be a 
<ins>non-<code>final</code></ins> class template [&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04 Chicago LWG]</i></p>

<p>
LWG discusses and expresses preference for a more general, Library-wide, resolution. Walter and Nevin 
provide a new Proposed Resolution consistent with such guidance.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add a new paragraph add the end of 17.6.5.11 [derivation] as indicated:</p>

<blockquote>
<p>
<ins>-?- All types specified in the C++ standard library shall be non-<code>final</code>
types unless otherwise specified.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2518" href="#2518">2518.</a> [fund.ts.v2] Non-member <tt>swap</tt> for <tt>propagate_const</tt> should call member <tt>swap</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::propagate_const.algorithms] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-08 <b>Last modified:</b> 2016-02-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
For consistency with the rest of the standard library, the non-member <tt>swap</tt> for <tt>propagate_const</tt> should 
call member <tt>swap</tt>.
</p>

<p><i>[2015-07, Telecom]</i></p>

<p>
Both P3 and NAD were suggested.
</p>

<p><i>[2016-02-20, Ville comments]</i></p>

<p>
Feedback from an implementation:
<p/>
The implementation of <tt>propagate_const</tt> in libstdc++ calls <tt>propagate_const</tt>'s
member <tt>swap</tt> from the non-member <tt>swap</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit [propagate_const.algorithms] as indicated:</p>
<blockquote>
<pre>
-1- template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>)
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt>noexcept(<del>swap(pt1.t_, pt2.t_)</del><ins>pt1.swap(pt2)</ins>)</tt>.
<p/>
-3- <i>Effects</i>: <tt><del>swap(pt1.t_, pt2.t_)</del><ins>pt1.swap(pt2)</ins></tt>. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2521" href="#2521">2521.</a> [fund.ts.v2] <tt>weak_ptr</tt>'s converting move constructor should be modified as well for array support</h3>
<p><b>Section:</b> 99 [fund.ts.v2::memory.smartptr.weak.const] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-25 <b>Last modified:</b> 2015-12-13</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
[memory.smartptr.weak.const] altered the constraints on <tt>weak_ptr</tt>'s constructor from <tt>const weak_ptr&lt;Y&gt;&amp;</tt> 
and <tt>const shared_ptr&lt;Y&gt;&amp;</tt>. The constraints on the converting move constructor from <tt>weak_ptr&lt;Y&gt;&amp;&amp;</tt> 
was not, but should be, similarly modified.
</p>

<p><i>[2015-10-26]</i></p>

<p>
Daniel adjusts wording to lib. fund. v2. As link to the originating proposal: The discussion in this issue refers to 
wording changes that were requested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3920.html">N3920</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>At the end of [memory.smartptr.weak.const], add:<br/>
[<i>Drafting note</i>: The current paragraph [memory.smartptr.weak.const] p2 is incorrectly declared as <i>Requires</i> element,
but it does not describe a requirement, instead it describes a "template constraint" which are elsewhere always
specified within a <i>Remarks</i> element because it describes constraints that an implementation (and not the user) has to meet. 
See LWG <a href="lwg-active.html#2292">2292</a> for a suggestion to introduce a separate new specification element for this situation.
This has also been fixed in the current working draft. &mdash; 
<i>end drafting note</i>] 
</p>
<blockquote>
<pre>
<ins>weak_ptr(weak_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remark</i>: The second constructor shall not participate in overload resolution unless <tt>Y*</tt> is <i>compatible with</i> 
<tt>T*</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>: Move-constructs a <tt>weak_ptr</tt> instance from <tt>r</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>*this</tt> shall contain the old value of <tt>r</tt>. <tt>r</tt> shall be <i>empty</i>. 
<tt>r.use_count() == 0</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2524" href="#2524">2524.</a> <tt>generate_canonical</tt> can occasionally return 1.0</h3>
<p><b>Section:</b> 26.6.8.4.2 [rand.dist.pois.exp] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Michael Pr&auml;hofer <b>Opened:</b> 2015-08-20 <b>Last modified:</b> 2015-11-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Original title was: <tt>exponential_distribution&lt;float&gt;</tt> sometimes returns inf.</p>

<p>
The random number distribution class template <tt>exponential_distribution&lt;float&gt;</tt> may return "inf" as can be 
seen from the following example program:
</p>
<blockquote>
<pre>
// compiled with
// g++ -std=c++11 Error_exp_distr.cpp

#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;

int main(){
  unsigned long long h;
  std::mt19937_64 mt1(1);
  std::mt19937_64 mt2(1);
  mt1.discard(517517);
  mt2.discard(517517);
  std::exponential_distribution&lt;float&gt; dis(1.0);
  h = mt2();
  std::cout &lt;&lt; std::bitset&lt;64&gt;(h) &lt;&lt; " " &lt;&lt; (float) -log(1 - h/pow(2, 64)) &lt;&lt; " " 
            &lt;&lt; -log(1 - (float) h/pow(2, 64)) &lt;&lt; " " &lt;&lt; dis(mt1) &lt;&lt; std::endl;
  h = mt2();
  std::cout &lt;&lt; std::bitset&lt;64&gt;(h) &lt;&lt; " " &lt;&lt; (float) -log(1 - h/pow(2, 64)) &lt;&lt; " " 
            &lt;&lt; -log(1 - (float) h/pow(2, 64)) &lt;&lt; " " &lt;&lt; dis(mt1) &lt;&lt; std::endl;
}
</pre>
</blockquote>
<p>
output:
</p>
<blockquote>
<pre>
0110010110001001010011000111000101001100111110100001110011100001 0.505218 0.505218 0.505218
1111111111111111111111111101010011000110011110011000110101100110 18.4143 inf inf
</pre>
</blockquote>
<p>
The reason seems to be that converting a <tt>double x</tt> in the range <tt>[0, 1)</tt> to <tt>float</tt> may result in <tt>1.0f</tt> 
if <tt>x</tt> is close enough to <tt>1</tt>. I see two possibilities to fix that:
</p>
<ol>
<li><p>use internally <tt>double</tt> (or <tt>long double</tt>?) and then convert the result at the very end to <tt>float</tt>.</p></li>
<li><p>take only 24 random bits and convert them to a <tt>float x</tt> in the range <tt>[0, 1)</tt> and then return <tt>-log(1 - x)</tt>.</p></li>
</ol>

<p>
I have not checked if <tt>std::exponential_distribution&lt;double&gt;</tt> has the same problem:
For <tt>float</tt> on the average 1 out of 2<sup>24</sup> (~10<sup>7</sup>) draws returns "inf", which is easily confirmed.
For <tt>double</tt> on the average 1 out of 2<sup>53</sup> (~10<sup>16</sup>) draws might return "inf", which I have not tested.
</p>

<p><b>Marshall:</b><br/>
I don't think the problem is in <tt>std::exponential_distribution</tt>; but rather in <tt>generate_canonical</tt>.
</p>

<p>Consider:
<blockquote><pre>
std::mt19937_64 mt2(1);
mt2.discard(517517);
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
</pre></blockquote>
<p/>
which outputs:
<p/>
<blockquote><pre>
0x1.962532p-2
0x1p+0
0x1.20d0cap-3
</pre></blockquote>

but <tt>generate_canonical</tt> is defined to return a result in the range [0, 1).
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Options: </p>
<ul>
<li>1) NAD, make it work. E.g. nudge slightly, making the hightest result return the highest allowable value (next_after). This might change the distribution slightly.</li>
<li>2) Re-run the algorithm when you get a 1. This changes the specification in that it makes extra calls to the random engine.</li>
<li>3) Something else</li>
</ul>

<p>WEB: The one thing we cannot tolerate is any output range other than [0, 1).</p>
<p>WEB: I believe there may be a documented algorithm for the generator, and perhaps it's possible to discover en-route that the algorithm produces the wrong result and fix it.</p>
<p>MC: No. I analyzed this once, and here it is: the algorithm is in [rand.util.canonical], and it's all fine until p5. The expression <tt>S/R^k</tt> is mathematically less than one, but it may round to one.</p>
<p>GR: Could we change the rounding mode for the computation? </p>
<p>HH: No, because the rounding mode is global, not thread-local.</p>
<p>AM: SG1 wants to get rid of the floating point environment. </p>
<p>STL: The problem is that the standard specifies the implementation, and the implementation doesn't work.</p>
<p>MC: I'm not sure if nudging it down will introduce a subtle bias.</p>
<p>EF: I worry about how the user's choice of floating point environment affects the behaviour.</p>
<p>MS offers to run the topic past colleagues.</p>
<p>MC: Will set the status to open. STL wants to rename the issue. WEB wants to be able to find the issue by its original name still.</p>

<p>Mike Spertus to run the options past his mathematical colleagues, and report back.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2525" href="#2525">2525.</a> [fund.ts.v2] <tt>get_memory_resource</tt> should be <tt>const</tt> and <tt>noexcept</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func], 99 [fund.ts.v2::futures.promise], 99 [fund.ts.v2::futures.task] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-08-04 <b>Last modified:</b> 2015-10-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::func.wrap.func">active issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func">issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
There doesn't seem to be any reason why this member function cannot be called on a <tt>const</tt> object, 
or why it would ever throw. I discussed this with Pablo Halpern, the author of N3916, and he agrees that 
this appears to have been an oversight.
</p>

<p><i>[2015-10-26]</i></p>

<p>
Daniel adjusts wording to lib. fund. v2.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit each of the synposes in 99 [func.wrap.func], 99 [futures.promise], and 
99 [futures.task] as indicated:</p>
<blockquote>
<pre>
pmr::memory_resource* get_memory_resource() <ins>const noexcept</ins>;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2527" href="#2527">2527.</a> [fund.ts.v2] <tt><i>ALLOCATOR_OF</i></tt> for <tt>function::operator=</tt> has incorrect default</h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func.con] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-08-04 <b>Last modified:</b> 2015-10-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func.con">issues</a> in [fund.ts.v2::func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
According to the table in  [memory.type.erased.allocator], if no allocator argument is specified at the time 
of construction, the memory resource pointer used is the value of <tt>experimental::pmr::get_default_resource()</tt> at 
the time of construction.
</p>
<p>
Yet in 99 [func.wrap.func.con], <tt><i>ALLOCATOR_OF</i></tt> is specified to return <tt>allocator&lt;char&gt;()</tt> 
if no allocator was specified at the time of construction, which seems incorrect, especially as the user can change the default
memory resource pointer to something other than <tt>new_delete_resource()</tt>.
</p>

<p><i>[2015-10-26]</i></p>

<p>
Daniel adjusts wording to lib. fund. v2.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit 99 [func.wrap.func.con]/p2 as indicated:</p>
<blockquote>
<p>
-2- In the following descriptions, let <tt><i>ALLOCATOR_OF</i>(f)</tt> be the allocator specified in the construction of 
<tt>function</tt> <tt>f</tt>, or <del><tt>allocator&lt;char&gt;()</tt></del><ins>the value of <tt>experimental::pmr::get_default_resource()</tt> 
at the time of the construction of <tt>f</tt></ins> if no allocator was specified.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2528" href="#2528">2528.</a> Order of <tt>std::tuple</tt> construction unspecified</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Rodriguez <b>Opened:</b> 2015-08-25 <b>Last modified:</b> 2015-09-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>std::tuple</tt> order of element construction is unspecified. It is either in the same order of the type list or in reverse. 
<p/>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct X 
{
  X(int) { std::cout &lt;&lt; "X constructor\n"; }
};

struct Y 
{
  Y(int) { std::cout &lt;&lt; "Y constructor\n"; }
};

int main()
{
  std::tuple&lt;X, Y&gt; t(1, 2);
}
</pre></blockquote>
<p>
Here is a <a href="http://coliru.stacked-crooked.com/a/764d0477523ba249">link</a> to two sample compilations. The first uses 
libstdc++ and constructs in reverse order, and the second uses libc++ and constructs in in-order. 
<p/>
A <tt>std::tuple</tt> mimics both a struct and type-generic container and should thus follow their standards. Construction is 
fundamentally different from a function call, and it has been historically important for a specific order to be guaranteed; 
namely: whichever the developer may decide. Mandating construction order will allow developers to reference younger elements 
later on in the chain as well, much like a struct allows you to do with its members.
<p/>
There are implementation issues as well. Reversed lists will require unnecessary overhead for braced-initializer-list initialization.  
Since lists are evaluated from left to right, the initializers must be placed onto the stack to respect the construction order. 
This issue could be significant for large tuples, deeply nested tuples, or tuples with elements that require 
many constructor arguments.
<p/>
I propose that the <tt>std::tuple&lt;A, B, ..., Y, Z&gt;</tt>'s constructor implementation be standardized, and made to construct 
in the same order as its type list e.g. <tt>A{}, B{}, ..., Y{}, Z{}</tt>.
</p>

<p>
<b>Daniel:</b>
<p/>
When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">N3140</a> became accepted, wording had been
added that gives at least an indication of requiring element initialization in the order of the declaration of the template
parameters. This argumentation can be based on 20.5.2.1 [tuple.cnstr] p3 (emphasize mine):
</p>
<blockquote><p>
-3- In the constructor descriptions that follow, let <tt><i>i</i></tt> be in the range <tt>[0,sizeof...(Types))</tt> 
<span style="color:#C80000;font-weight:bold">in order</span>, 
<tt><i>Ti</i></tt> be the <tt><i>i<sup>th</sup></i></tt> type in <tt>Types</tt>, and <tt><i>Ui</i></tt> be the 
<tt><i>i<sup>th</sup></i></tt> type in a template parameter pack named <tt>UTypes</tt>, where indexing is
zero-based.
</p></blockquote>
<p>
But the current wording needs to be improved to make that intention clearer and an issue like this one is necessary to be sure that
the committee is agreeing (or disagreeing) with that intention, especially because N3140 didn't really point out the relevance of the element
construction order in the discussion, and because not all constructors explicitly refer to the ordered sequence of numbers generated
by the variable <tt><i>i</i></tt> (The move constructor does it right, but most other don't do that). 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2530" href="#2530">2530.</a> Clarify observable side effects of releasing a shared state</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When a shared-state is released, it may be necessary to execute user defined code for the destructor of a 
stored value or exception. It is unclear whether the execution of said destructor constitutes an observable side effect.
</p>
<p>
While discussing N4445 in Lenexa, Nat Goodspeed pointed out that 30.6.4 [futures.state]/5.1 does not explicitly 
mention the destruction of the result, so implementations should be allowed to release (or reuse) a shared state ahead 
of time under the "as-if" rule.
<p/>
The standard should clarify whether the execution of destructors is a visible side effect of releasing a shared state.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2531" href="#2531">2531.</a> <tt>future::get</tt> should explicitly state that the shared state is released</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.unique_future">active issues</a> in [futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard is usually very explicit on when a shared state is released, except for <tt>future::get</tt> 
for which it only states <tt>valid() == false</tt> as a postcondition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Modify 30.6.6 [futures.unique_future] as indicated:</p>
<blockquote><pre>
R future::get();
R&amp; future&lt;R&amp;&gt;::get();
void future&lt;void&gt;::get();
</pre>
<blockquote>
<p>
-14- <i>Note</i>: as described above, the template and its two required specializations differ only in the return
type and return value of the member function <tt>get</tt>.
<p/>
-15- <i>Effects</i>:
</p>
<ul>
<li><p><tt>wait()</tt>s until the shared state is ready, then retrieves the value stored in the shared state<del>.</del><ins>;</ins></p></li>
<li><p><ins>releases any shared state (30.6.4 [futures.state]).</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2532" href="#2532">2532.</a> Satisfying a <tt>promise</tt> at thread exit</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>promise::set_value_at_thread_exit</tt> and <tt>promise::set_exception_at_thread_exit</tt> operate on a shared state 
at thread exit, without making the thread participate in the ownership of such shared state.
<p/>
Consider the following snippet:
</p>
<blockquote><pre>
std::promise&lt;int&gt;{}.set_value_at_thread_exit(42);
</pre></blockquote>
<p>
Arguably, since the <tt>promise</tt> abandons its shared state without actually making it ready, a <tt>broken_promise</tt> 
error condition should be stored in the shared state. Implementations diverge, they either crash at thread exit by 
dereferencing an invalid pointer, or keep the shared state around until thread exit.
</p>

<p><i>[2016-08-03, Billy O'Neal suggests concrete wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 30.6.4 [futures.state] p7 as indicated:</p>

<blockquote>
<p>
-7- When an asynchronous provider is said to abandon its shared state, it means:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; first, if that state is not ready <ins>or scheduled to be made ready at thread exit</ins>, the provider</p>
<ol style="list-style-type: none">
<li><p>(7.1.1) &mdash; stores an exception object of type <tt>future_error</tt> with an error condition of 
<tt>broken_promise</tt> within its shared state; and then</p></li>
<li><p>(7.1.2) &mdash; makes its shared state ready;</p></li>
</ol>
</li>
</ol>
</blockquote>
</li>

<li><p>Change 30.6.4 [futures.state] p10 as indicated:</p>

<blockquote>
<p>
-10- Some functions (e.g., <tt>promise::set_value_at_thread_exit</tt>) <del>delay making the shared state ready 
until</del><ins>schedule the shared state to be made ready when</ins> the
calling thread exits. <ins>This associates a reference to the shared state with the calling thread.</ins> The 
destruction of each of that thread's objects with thread storage duration 
(3.7.2 [basic.stc.thread]) is sequenced before making that shared state ready. <ins>When the calling 
thread makes the shared state ready, if the thread holds the last reference to the shared state, the shared state 
is destroyed. [<i>Note:</i> This means that the shared state may not become ready until after the <em>asynchronous 
provider</em> has been destroyed. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2534" href="#2534">2534.</a> Constrain rvalue stream operators</h3>
<p><b>Section:</b> 27.7.3.9 [ostream.rvalue], 27.7.2.6 [istream.rvalue] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2015-09-08 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ostream.rvalue">active issues</a> in [ostream.rvalue].</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.rvalue">issues</a> in [ostream.rvalue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The rvalue stream insertion and extraction operators should be constrained to not participate in overload 
resolution unless the expression they evaluate is well-formed. Programming code that tests the validity of 
stream insertions (or extractions) using SFINAE can result in false positives, as the present 
declarations accept virtually any right-hand side argument. Moreover, there is no need for pollution of 
the candidate set with ill-formed specializations.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Modify 27.7.3.9 [ostream.rvalue] as indicated:</p>
<blockquote>
<pre>
template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <tt>os &lt;&lt; x</tt>
<p/>
-2- <i>Returns</i>: <tt>os</tt>
<p/>
<ins>-?- <i>Remarks</i>: This function shall not participate in overload resolution unless the expression 
<tt>os &lt;&lt; x</tt> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.7.2.6 [istream.rvalue] as indicated:</p>
<blockquote>
<pre>
template &lt;class charT, class traits, class T&gt;
  basic_istream&lt;charT, traits&gt;&amp;
  operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <tt>is &gt;&gt; x</tt>
<p/>
-2- <i>Returns</i>: <tt>is</tt>
<p/>
<ins>-?- <i>Remarks</i>: This function shall not participate in overload resolution unless the expression 
<tt>is &gt;&gt; x</tt> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2536" href="#2536">2536.</a> What should <tt>&lt;complex.h&gt;</tt> do?</h3>
<p><b>Section:</b> D.4 [depr.c.headers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-09-10 <b>Last modified:</b> 2015-09-15</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.c.headers">issues</a> in [depr.c.headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="lwg-defects.html#1134">1134</a> removed the resolution of LWG <a href="lwg-defects.html#551">551</a>, leaving an incorrect specification for 
the behavior of <tt>&lt;complex.h&gt;</tt>. This header is currently required to make <tt>std::complex</tt> (and 
associated functions) visible in the global namespace, but should not be so required.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Add a new paragraph <em>before</em> D.4 [depr.c.headers]/2:</p>
<blockquote><p>
<ins>-?- The header <tt>&lt;complex.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ccomplex&gt;</tt>.</ins>
</p></blockquote>
</li>

<li><p>Change in D.4 [depr.c.headers]/2:</p>
<blockquote><p>
-2- Every <ins>other</ins> C header, each of which has a name of the form <tt>name.h</tt>, behaves as if each name placed 
in the standard library namespace by the corresponding <tt>cname</tt> header is placed within the global namespace scope. 
It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace
<tt>std</tt> and are then injected into the global namespace scope by explicit <i>using-declarations</i> (7.3.3).
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2540" href="#2540">2540.</a> <tt>unordered_multimap::insert</tt> hint iterator</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Isaac Hier <b>Opened:</b> 2015-09-16 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have been wondering about the C++ standard requirements regarding the hint iterator for insertion into an 
<tt>unordered_multimap</tt> (and I imagine a similar question could be asked of <tt>unordered_map</tt>, but 
I have not researched that topic). As far as I can tell, it seems perfectly valid for an implementation to 
allow only valid dereferencable iterators to be used as the hint argument for this member function. If that 
is correct, it means that one could not expect the end iterator to be used as a valid hint nor could one use 
the begin iterator of an empty <tt>unordered_multimap</tt> as the hint. However, this essentially precludes 
all uses of inserter on an empty <tt>unordered_multimap</tt> seeing as the inserter functor requires that a 
hint iterator be passed to its constructor.
<p/>
Howard Hinnant:
</p>
<blockquote class="note">
<p>
The intent of the standard is that the iterator produced from container <tt>c</tt> by <tt>c.end()</tt> is a 
valid (but non-dereferenceable) iterator into container <tt>c</tt>. It is reachable by every other iterator 
into <tt>c</tt>.
<p/>
It appears to me that you and the Bloomberg implementation have fallen victim to a type-o in the Unordered 
associative container requirements, Table 102.  The row containing:
</p>
<blockquote><pre>
a.insert(q, t);
</pre></blockquote>
<p>
should read instead:
</p>
<blockquote><pre>
a.insert(p, t);
</pre></blockquote>
<p>
The distinction is that <tt>p</tt> is valid, and <tt>q</tt> is both valid and dereferenceable.
The correction of this type-o would make unordered container <tt>insert</tt> consistent with unordered <tt>emplace_hint</tt>, 
associative <tt>insert</tt>, and associative <tt>emplace_hint</tt>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the insert-with-hint row in Table 102
Unordered associative container requirements like so:
</p>
<blockquote>
<table border="1" cellpadding="4"><tr>
<td><tt>a.insert(<del>q</del><ins>p</ins>, t);</tt><br/></td>
<td><tt>iterator</tt><br/></td>
<td><i>Requires:</i> If <tt>t</tt> is a non-const<br/>...</td>
<td>Average Case<br/>...</td>
</tr></table>
</blockquote>





<hr>
<h3><a name="2541" href="#2541">2541.</a> [parallel.ts] Headers for <tt>ExecutionPolicy</tt> algorithm overloads</h3>
<p><b>Section:</b> 99 [parallel.ts::parallel.alg.overloads] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-09-26 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: parallel.ts</b></p>
<p>
99 [parallel.alg.overloads] provides parallel algorithm overloads for many algorithms in the standard library, 
but I can't find any normative wording specifying which headers these new overloads live in. Presumably, if the original 
algorithm is in <tt>&lt;meow&gt;</tt>, the new overloads should be in <tt>&lt;experimental/meow&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2543" href="#2543">2543.</a> LWG 2148 (hash support for enum types) seems under-specified</h3>
<p><b>Section:</b> 20.14.14 [unord.hash] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-09-27 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The rationale in issue <a href="lwg-defects.html#2148">2148</a> says:
</p>
<blockquote class="note"><p>
This proposed resolution doesn't specify anything else about the
primary template, allowing implementations to do whatever they want
for non-enums: <tt>static_assert</tt> nicely, explode horribly at compiletime
or runtime, etc.
</p></blockquote>
<p>
libc++ seems to implement it by defining the primary template and
<tt>static_assert</tt>ing <tt>is_enum</tt> inside it. However, that brings forth
a problem; there are reasonable SFINAE uses broken by it:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
#include &lt;functional&gt;

class S{}; // No hash specialization

template&lt;class T&gt;
auto f(int) -&gt; decltype(std::hash&lt;T&gt;(), std::true_type());

template&lt;class T&gt;
auto f(...) -&gt; decltype(std::false_type());

static_assert(!decltype(f&lt;S&gt;(0))::value, "");
</pre></blockquote>
<p>
MSVC doesn't seem to accept that code either.
<p/>
There <em>is</em> a way to implement LWG <a href="lwg-defects.html#2148">2148</a> so that <tt>hash</tt> for enums is supported
without breaking that sort of SFINAE uses:
</p>
<ol>
<li><p>Derive the main <tt>hash</tt> template from a library-internal uglified-named
base template that takes a type and a <tt>bool</tt>, pass as argument for the base
the result of <tt>is_enum</tt>.</p></li>
<li><p>Partially specialize that base template so that the false-case has
a suitable set of private special member function declarations so that it's not
an aggregate nor usable in almost any expression.</p></li>
</ol>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>EricWF to come back with wording; move to Open</p>

<p><i>[2016-05-08, Eric Fiselier &amp; Ville provide wording]</i></p>


<p><i>[2016-05-25, Tim Song comments]</i></p>

<p>
I see two issues with this P/R:
</p>
<ol>
<li><p>
"for which neither the library nor the user provides an explicit specialization" should probably be "for which neither 
the library nor the user provides an explicit or partial specialization".
</p></li>
<li><p>
Saying that the specialization "is not <tt>DefaultConstructible</tt> nor <tt>MoveAssignable</tt>" is not enough to 
guarantee that common SFINAE uses will work. Both of those requirements have several parts, and it's not too hard 
to fail only some of them. For instance, not meeting the assignment postcondition breaks <tt>MoveAssignable</tt>, 
but is usually not SFINAE-detectible. And for <tt>DefaultConstructible</tt>, it's easy to write something in a way 
that breaks <tt>T()</tt> but not <tt>T{}</tt> (due to aggregate initialization in the latter case).
</p></li>
</ol>

<p><i>[2016-06-14, Daniel comments]</i></p>

<p>
The problematic part of the P/R is that it describes constraints that would be suitable if they were constraints 
for user-code, but they are not suitable as requirements imposed on implementations to provide certain guarantees 
for clients of the Library. The guarantees should be written in terms of testable compile-time expressions, e.g. based on 
negative results of <tt>is_default_constructible&lt;hash&lt;X&gt;&gt;::value</tt>, 
<tt>std::is_copy_constructible&lt;hash&lt;X&gt;&gt;::value</tt>, and possibly also 
<tt>std::is_destructible&lt;hash&lt;X&gt;&gt;::value</tt>. <em>How</em> an implementation realizes these negative 
results shouldn't be specified, though, but the expressions need to be well-formed and well-defined.

<p><i>[2016-08-03, Ville provides revised wording as response to Daniel's previous comment]</i></p>

</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Insert a new paragraph after 20.14.14 [unord.hash]/2</p>

<blockquote>
<p>
-2- The template specializations shall meet the requirements of class template <tt>hash</tt> (20.12.14).
<p/>
<ins>-?- For any type that is not of integral or enumeration type, or for
which neither the library nor the user provides an explicit
specialization of the class template <tt>hash</tt>, the specialization of <tt>hash</tt> does not meet
any of the <tt>Hash</tt> requirements, and is not <tt>DefaultConstructible</tt> nor
<tt>MoveAssignable</tt>.
[<i>Note</i>: this means that the specialization of <tt>hash</tt> exists, but any
attempts to use it as a Hash will be ill-formed. &mdash; <i>end note</i>]
</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Insert a new paragraph after 20.14.14 [unord.hash]/2</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I see no reason to specify whether <tt>H&lt;T&gt;</tt> is
destructible. There's no practical use case for which that would need to be covered. 
libstdc++ makes it so that <tt>H&lt;T&gt;</tt> is destructible.]
</p>
</blockquote>

<blockquote>
<p>
-2- The template specializations shall meet the requirements of class template <tt>hash</tt> (20.12.14).
<p/>
<ins>-?- For any type <tt>T</tt> that is not of integral or enumeration type, or for
which neither the library nor the user provides an explicit or partial specialization of the class
template hash, the specialization of <tt>hash&lt;T&gt;</tt> has the following properties:
</ins>
</p>
<ul>
<li><ins><tt>is_default_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_copy_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_move_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_copy_assignable_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_move_assignable_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_callable_v&lt;hash&lt;T&gt;, T&amp;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_callable_v&lt;hash&lt;T&gt;, const T&amp;&gt;</tt> is <tt>false</tt></ins></li>
</ul>
<p>
<ins>[<i>Note:</i> this means that the specialization of <tt>hash</tt> exists, but any
attempts to use it as a <tt>Hash</tt> will be ill-formed. &mdash; end note]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2544" href="#2544">2544.</a> <tt>istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s)</tt> effects unclear when <tt>s</tt> is <tt>0</tt></h3>
<p><b>Section:</b> 24.6.3.2 [istreambuf.iterator.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2015-10-05 <b>Last modified:</b> 2015-10-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4527 24.6.3.2 [istreambuf.iterator.cons] does not mention what the effect of calling 
<tt>istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s)</tt> is when <tt>s</tt> is a null pointer. 
It should be made clear that this case is well-formed and the result is a end-of-stream iterator.
<p/>
Daniel:
<p/>
According to 24.6.3 [istreambuf.iterator] p1:
</p>
<blockquote><p>
[&hellip;] The default constructor <tt>istreambuf_iterator()</tt> and the constructor <tt>istreambuf_iterator(0)</tt> both 
construct an end-of-stream iterator object suitable for use as an end-of-range. [&hellip;]
</p></blockquote>
<p>
This indicates that the described constructor creates an end-of-stream iterator, but this wording is part of the introductory 
wording and I recommend to make 24.6.3.2 [istreambuf.iterator.cons] clearer, because the existing specification is already
flawed, e.g. it never specifies when and how the exposition-only-member <tt>sbuf_</tt> is initialized. The proposed wording 
below attempts to solve these problems as well.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N4527.</p>

<ol>
<li>
<p>Change 24.6.3.2 [istreambuf.iterator.cons] as indicated:
<p/>
[<i>Editorial note</i>: The proposed wording changes also performs some editorial clean-up of the existing mismatches
of the declarations in the class template synopsis and the individual member specifications. The below wording intentionally
does not say anything about the concrete value of <tt>sbuf_</tt> for end-of-stream iterator values, because that
was never specified before; in theory, this could be some magic non-null pointer that can be used in constant expressions. 
But the wording could be drastically simplified by requiring <tt>sbuf_</tt> to be a null pointer for an end-of-stream iterator value, 
since I have not yet seen any implementation where this requirement does not hold. &mdash; <i>end editorial note</i>]
</p>
<blockquote>
<pre>
constexpr istreambuf_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs the end-of-stream iterator.
</p>
</blockquote>
<pre>
istreambuf_iterator(<del>basic_istream&lt;charT,traits&gt;</del><ins>istream_type</ins>&amp; s) noexcept;
<del>istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s) noexcept;</del>
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: <ins>If <tt>s.rdbuf()</tt> is a null pointer, constructs an end-of-stream iterator; otherwise 
initializes  <tt>sbuf_</tt> with <tt>s.rdbuf()</tt> and constructs an <tt>istreambuf_iterator</tt> that uses the 
<tt>streambuf_type</tt> object <tt>*sbuf_</tt></ins><del>Constructs an <tt>istreambuf_iterator&lt;&gt;</tt> that 
uses the <tt>basic_streambuf&lt;&gt;</tt> object <tt>*(s.rdbuf())</tt>, or <tt>*s</tt>, respectively. Constructs 
an end-of-stream iterator if <tt>s.rdbuf()</tt> is null</del>.
</p>
</blockquote>
<pre>
<ins>istreambuf_iterator(streambuf_type* s) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <tt>s</tt> is a null pointer, constructs an end-of-stream iterator; otherwise initializes 
<tt>sbuf_</tt> with <tt>s</tt> and constructs an <tt>istreambuf_iterator</tt> that uses the <tt>streambuf_type</tt> 
object <tt>*sbuf_</tt>.</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator(const proxy&amp; p) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>p.sbuf_</tt> and constructs an <tt>istreambuf_iterator</tt> 
that uses the <tt>streambuf_type</tt> object <tt>*sbuf_</tt></ins><del>Constructs a <tt>istreambuf_iterator&lt;&gt;</tt> 
that uses the <tt>basic_streambuf&lt;&gt;</tt> object pointed to by the <tt>proxy</tt> object's constructor argument 
<tt>p</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-10-20, Daniel provides alternative wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li>
<p>Change 24.6.3.2 [istreambuf.iterator.cons] as indicated:
<p/>
[<i>Editorial note</i>: The proposed wording changes also performs some editorial clean-up of the existing mismatches
of the declarations in the class template synopsis and the individual member specifications. The below wording is 
simplified by requiring <tt>sbuf_</tt> to be a null pointer for an end-of-stream iterator value, 
since I have not yet seen any implementation where this requirement does not hold. Even if there <em>were</em> such an 
implementation, this would still be conforming, because concrete exposition-only member values are not part of public 
API. &mdash; <i>end editorial note</i>]
</p>
<blockquote>
<p>
<ins>For each <tt>istreambuf_iterator</tt> constructor in this section, an end-of-stream iterator is 
constructed if and only if the exposition-only member <tt>sbuf_</tt> is initialized with a null 
pointer value.</ins>
</p>
<pre>
constexpr istreambuf_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>nullptr</tt></ins><del>Constructs the end-of-stream iterator</del>.
</p>
</blockquote>
<pre>
istreambuf_iterator(<del>basic_istream&lt;charT,traits&gt;</del><ins>istream_type</ins>&amp; s) noexcept;
<del>istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s) noexcept;</del>
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>s.rdbuf()</tt></ins><del>Constructs 
an <tt>istreambuf_iterator&lt;&gt;</tt> that uses the <tt>basic_streambuf&lt;&gt;</tt> object 
<tt>*(s.rdbuf())</tt>, or <tt>*s</tt>, respectively. Constructs 
an end-of-stream iterator if <tt>s.rdbuf()</tt> is null</del>.
</p>
</blockquote>
<pre>
<ins>istreambuf_iterator(streambuf_type* s) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes <tt>sbuf_</tt> with <tt>s</tt>.</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator(const proxy&amp; p) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>p.sbuf_</tt></ins><del>Constructs a <tt>istreambuf_iterator&lt;&gt;</tt> 
that uses the <tt>basic_streambuf&lt;&gt;</tt> object pointed to by the <tt>proxy</tt> object's constructor argument 
<tt>p</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2546" href="#2546">2546.</a> Implementability of locale-sensitive <em>UnicodeEscapeSequence</em> matching</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.13 [re.grammar] paragraph 2:
</p>
<blockquote><p>
<tt>basic_regex</tt> member functions shall not call any locale dependent C or C++ API, including the formatted 
string input functions. Instead they shall call the appropriate traits member function to achieve the required effect.
</p></blockquote>
<p>
Yet, the required interface for a regular expression traits class (28.3 [re.req]) does not appear to have 
any reliable method for determining whether a character as encoded for the locale associated with the traits 
instance is the same as a character represented by a <em>UnicodeEscapeSequence</em>, e.g., assuming a sane 
<tt>ru_RU.koi8r</tt> locale:
</p>
<blockquote><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;regex&gt;

const char data[] = "\xB3";
const char matchCyrillicCaptialLetterYo[] = R"(\u0401)";

int main(void) 
{
  try {
    std::regex myRegex;
    myRegex.imbue(std::locale("ru_RU.koi8r"));

    myRegex.assign(matchCyrillicCaptialLetterYo, std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());

    myRegex.assign("[[:alpha:]]", std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());
  } catch (std::regex_error&amp; e) {
    abort();
  }
  return 0;
}
</pre></blockquote>
<p>
The implementation I tried prints:
</p>
<blockquote><pre>
(&#x401;)
(E)
</pre></blockquote>
<p>
Which means that the character class matching worked, but not the matching to the <em>UnicodeEscapeSequence</em>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2547" href="#2547">2547.</a> Container requirements (and other library text) should say "strict total order", not just "total order"</h3>
<p><b>Section:</b> 20.14.6 [comparisons], 23.2.1 [container.requirements.general], 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2015-10-31</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of places in the library, including 20.14.6 [comparisons]/14, the Optional container requirements in 
23.2.1 [container.requirements.general], and 30.3.1.1 [thread.thread.id]/8, use the phrase "total order". 
Unfortunately, that phrase is ambiguous. In mathematics, the most common definition is that a relation <tt>&le;</tt> is 
a total order if it's total, transitive, and antisymmetric in the sense that <tt>x&le;y &#x2227; y&le;x &rArr; x=y</tt>. 
What we really want is a strict total order: a relation <tt>&lt;</tt> is a strict total order if it's total, transitive, and 
antisymmetric in the sense that exactly one of <tt>x&lt;y</tt>, <tt>y&lt;x</tt>, and <tt>x=y</tt> holds.
</p>
<p>
The non-normative note in 25.5 [alg.sorting]/4 correctly uses the phrase "strict total ordering" rather than 
simply "total ordering".
</p>
<p>
We could address this issue by replacing "total order" with "strict total order" everywhere it appears, since I 
think there are no cases where we actually want a non-strict total order, or we could add something in Clause 17 saying 
that we always mean strict total order whenever we say total order.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2548" href="#2548">2548.</a> Missing <tt>vfscanf</tt> from <tt>&lt;cstdio&gt;</tt></h3>
<p><b>Section:</b> 27.11 [c.files] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith  <b>Opened:</b> 2015-10-09 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.files">issues</a> in [c.files].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C's <tt>vfscanf</tt> function is not present in C++'s <tt>&lt;cstdio&gt;</tt>, and presumably should be. 
It looks like this is the only missing member of C's <tt>[v]{f,s,sn}[w]{printf,scanf}</tt> family.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<p>Modify Table 133 as follows:</p>
<p>
<tt>ungetc</tt><br/>
<tt>vfprintf</tt><br/>
<ins><tt>vfscanf</tt></ins><br/>
<tt>vprintf</tt><br/>
<tt>vscanf</tt><br/>
</p>





<hr>
<h3><a name="2556" href="#2556">2556.</a> Wide contract for <tt>future::share()</tt></h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-11-05 <b>Last modified:</b> 2016-03-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.unique_future">active issues</a> in [futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>future::share()</tt> is not <tt>noexcept</tt>, it has a narrow contact requiring <tt>valid()</tt> as per the blanket 
wording in 30.6.6 [futures.unique_future] p3. Its effects, however, are <tt>return shared_future&lt;R&gt;(std::move(*this))</tt>, 
which is <tt>noexcept</tt> as it has a wide contract. If the source <tt>future</tt> isn't valid then the target 
<tt>shared_future</tt> simply won't be valid either. There appears to be no technical reason preventing <tt>future::share()</tt> 
from having a wide contract, and thus being <tt>noexcept</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 30.6.6 [futures.unique_future] as indicated:</p>

<blockquote>
<p>
-3- The effect of calling any member function other than the destructor, the move-assignment operator, <ins><tt>share</tt>,</ins> 
or <tt>valid</tt> on a <tt>future</tt> object for which <tt>valid() == false</tt> is undefined. [<i>Note</i>: Implementations 
are encouraged to detect this case and throw an object of type <tt>future_error</tt> with an error condition of 
<tt>future_errc::no_state</tt>. &mdash; <i>end note</i>]
</p>
<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class future {
  public:
    [&hellip;]
    shared_future&lt;R&gt; share() <ins>noexcept</ins>;
    [&hellip;]
  };
}
</pre></blockquote>
<p>
[&hellip;]
</p>
<pre>
shared_future&lt;R&gt; share() <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-12- <i>Returns</i>: <tt>shared_future&lt;R&gt;(std::move(*this))</tt>.
<p/>
-13- <i>Postcondition</i>: <tt>valid() == false</tt>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2561" href="#2561">2561.</a> [fund.ts.v2] Incorrect exception specifications for 'swap' in C++ Extensions for Library Fundamentals</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object.swap], 99 [fund.ts.v2::propagate_const.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2015-11-14 <b>Last modified:</b> 2016-03-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
As pointed out in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html#Related_Issues">N4511</a>,
the Library fundamentals are affected by a similar problem as described in LWG <a href="lwg-defects.html#2456">2456</a>. First, it is caused
by <tt>optional</tt>'s member <tt>swap</tt> (99 [optional.object.swap]):
</p>
<blockquote><pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre></blockquote>
<p>
with 
</p>
<blockquote>
<p>
The expression inside <tt>noexcept</tt> is equivalent to: 
</p>
<blockquote><pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))
</pre></blockquote>
</blockquote>
<p>
Again, the unqualified lookup for <tt>swap</tt> finds the member <tt>swap</tt> instead of the result of a normal argument-depending 
lookup, making this ill-formed.
<p/>
A second example of such a problem recently entered the arena with the addition of the <tt>propagate_const</tt> template
with another member <tt>swap</tt> (99 [propagate_const.modifiers]):
</p>
<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt>noexcept(swap(t_, pt.t_))</tt>.
</p>
</blockquote>
</blockquote>
<p>
A working approach is presented in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html#Proposed_resolution">N4511</a>. By adding a new
trait to the standard library and referencing this by the library fundamentals (A similar approach had been applied in the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3940.html#path-inserter-extractor">file system specification</a>
where the <tt>quoted</tt> manipulator from C++14 had been referred to, albeit the file system specification is generally based on the
C++11 standard), <tt>optional</tt>'s member <tt>swap</tt> exception specification could be rephrased as follows:
</p>
<blockquote>
<p>
The expression inside <tt>noexcept</tt> is equivalent to: 
</p>
<blockquote><pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre></blockquote>
</blockquote>
<p>
and <tt>propagate_const</tt>'s member <tt>swap</tt> exception specification could be rephrased as follows:
</p>
<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt><ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(t_, pt.t_))</del></tt>.
</p>
</blockquote>
</blockquote>

<p><i>[2016-02-20, Ville comments]</i></p>

<p>
Feedback from an implementation:
<p/>
libstdc++ already applies the proposed resolution for <tt>propagate_const</tt>,
but not for <tt>optional</tt>.
</p>

<p><i>[2016-02-20, Daniel comments]</i></p>

<p>
A recent paper update has been provided: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r0.html#Proposed_resolution">P0185R0</a>.
</p>

<p><i>[2016-03, Jacksonville]</i></p>

Add a link to <a href="lwg-defects.html#2456">2456</a>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2562" href="#2562">2562.</a> Consistent total ordering of pointers by comparison functors</h3>
<p><b>Section:</b> 20.14.6 [comparisons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2015-11-18 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4567 20.14.6 [comparisons]/14 specifies that the comparison functors provide a total ordering for pointer types:
</p>
<blockquote><p>
For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the specializations for 
any pointer type yield a total order, even if the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt> 
do not.
</p></blockquote>
<p>
It notably does not specify:
</p>
<ul>
<li><p>whether the specializations of all of the named templates for a given pointer type yield the <em>same</em> total order</p></li>
<li><p>whether the total order imposed respects the partial order imposed by the built-in operators</p></li>
<li><p>whether the total order imposed is consistent with the partition induced by <tt>==</tt></p></li>
</ul>
<p>
All of which are important for sane semantics and provided by common implementations, since the built-in operators provide 
a total order and the comparison functors yield that same order.
<p/>
It would be extremely confusing &mdash; if not outright insane &mdash; for e.g.:
</p>
<ul>
<li><p><tt>less&lt;int*&gt;</tt> and <tt>greater&lt;int*&gt;</tt> to yield different orders</p></li>
<li><p><tt>less&lt;int*&gt;</tt> to disagree with <tt>&lt;</tt> on the relative order of two pointers for which <tt>&lt;</tt> 
is defined</p></li>
<li><p><tt>less&lt;int*&gt;</tt> to order <tt>a</tt> before <tt>b</tt> when <tt>a == b</tt>, i.e., not preserve equality.</p></li>
</ul>
<p>
Consistent semantics for the various comparison functors and the built-in operators is so intuitive as to be assumed by most programmers.
<p/>
Related issues: <a href="lwg-defects.html#2450">2450</a>, <a href="lwg-active.html#2547">2547</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Alter 20.14.6 [comparisons]/14 to read:</p>
<blockquote><p>
For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the specializations for any pointer type
yield <del>a</del><ins>the same</ins> total order, even if the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, 
<tt>&gt;=</tt> do not. <ins>The total order shall respect the partial order imposed by the built-in operators.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-05-20, Casey Carter comments and suggests revised wording]</i></p>

<p>
The new proposed wording is attempting to address the issue raised in the 2016-02-04 telecon.
<p/>
The real issue I'm trying to address here is ensure that "weird" implementations provide the same kind of consistency 
for pointer orderings as "normal" implementations that use a flat address spaces and have totally ordered <tt>&lt;</tt>. 
If <tt>a &lt; b</tt> is true for <tt>int</tt> pointers <tt>a</tt> and <tt>b</tt>, then <tt>less&lt;int*&gt;(a, b)</tt>, 
<tt>less_equal&lt;int*&gt;(a, b)</tt>, <tt>less&lt;char*&gt;(a, b)</tt>, <tt>less&lt;void*&gt;(a, b)</tt>, and 
<tt>greater&lt;int*&gt;(b, a)</tt> should all hold. I <em>think</em> this wording is sufficient to provide that.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>

<ol>
<li><p>Alter 20.14.6 [comparisons] to read:</p>
<blockquote><p>
-14- For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the 
specializations for any pointer type yield <del>a</del><ins>the same</ins> total order<ins>. That total order is 
consistent with the partial order imposed by</ins><del>, even if</del> the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, 
<tt>&le;</tt>, <ins>and</ins> <tt>&gt;</tt> <del>do not</del>. <ins>[<i>Note</i>: When <tt>a &lt; b</tt> is 
well-defined for pointers <tt>a</tt> and <tt>b</tt> of type <tt>P</tt>, this implies <tt>(a &lt; b) == 
less&lt;P&gt;(a, b)</tt>, <tt>(a &gt; b) == greater&lt;P&gt;(a, b)</tt>, and so forth. &mdash; <i>end note</i>]</ins> 
For template specializations <tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, <tt>greater_equal&lt;void&gt;</tt>, 
and <tt>less_equal&lt;void&gt;</tt>, if the call operator calls a built-in operator comparing pointers, the 
call operator yields a total order.
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04 Chicago LWG]</i></p>

<p>
LWG discusses and concludes that we are trying to accomplish the following:
</p>
<ol>
<li>
<blockquote><pre>
T* a = /* ... */;
T* b = /* ... */;
</pre></blockquote>
<p>
 if <tt>a &lt; b</tt> is valid, <tt>a &lt; b == less&lt;T*&gt;(a, b)</tt>, and analogously for <tt>&gt;</tt>, 
 <tt>&lt;=</tt>, <tt>&gt;=</tt>.
</p>
</li>
<li>
<blockquote><pre>
less&lt;void&gt;(a, b) == less&lt;T*&gt;(a, b);
less&lt;T*&gt;(a, b) == greater&lt;T*&gt;(b, a);
</pre></blockquote>
<p>
etc.
</p>
</li>
<li><p>
<tt>less&lt;T*&gt;</tt> produces a strict total ordering with which the other three
function objects are consistent
</p></li>
<li><p>
<tt>less&lt;void&gt;</tt> when applied to pointers produces a strict total ordering with
which the other three are consistent
</p></li>
<li><p>
<tt>less&lt;void&gt;</tt> when applied to pointers of the same type produces the same
strict total ordering as <tt>less&lt;T*&gt;</tt>, and analogously for the other three
</p></li>
<li><p>
we are not addressing <tt>less&lt;void&gt;</tt> (and the other three) when applied to
pointers of differing types
</p></li>
</ol>
<p>
Walter and Nevin revise Proposed Wording accordingly.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.14.6 [comparisons] p14 as indicated:</p>
<blockquote><p>
-14- For templates <del><tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and 
<tt>less_equal</tt></del><ins><ins><tt>less</tt>, <tt>greater</tt>, <tt>less_equal</tt>,
and <tt>greater_equal</tt></ins></ins>, 
the specializations for any pointer type yield a <ins>strict</ins> total order<ins>
that strict total order is consistent among those specializations
and is also consistent with the partial order imposed by</ins>
<del>, even if</del> the built-in operators 
<tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt> <del>do not</del><ins>[<i>Note:</i>
When <tt>a &lt; b</tt> is well-defined for pointers <tt>a</tt> and <tt>b</tt> of type <tt>P</tt>,
this implies <tt>(a &lt; b) == less&lt;P&gt;(a, b)</tt>, <tt>(a &gt; b) == greater&lt;P&gt;(a, b)</tt>,
and so forth. &mdash; <i>end note</i>]</ins>. For template specializations 
<del><tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, <tt>greater_equal&lt;void&gt;</tt>, and 
<tt>less_equal&lt;void&gt;</tt></del><ins><tt>less&lt;void&gt;</tt>, <tt>greater&lt;void&gt;</tt>,
<tt>less_equal&lt;void&gt;</tt>, and <tt>greater_equal&lt;void&gt;</tt></ins>, if the call operator 
calls a built-in operator comparing pointers, the call operator yields a <ins>strict</ins> total 
order <ins>that is consistent among those specializations and is also consistent
with the partial order imposed by those built-in operators</ins>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2563" href="#2563">2563.</a> LWG 2259 relaxes requirements, perhaps unintentionally</h3>
<p><b>Section:</b> 17.6.5.5 [member.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-11-29 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in [member.functions].</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The combination of 17.6.5.5 [member.functions], paragraphs 2 and 3 that LWG 
<a href="lwg-defects.html#2259">2259</a> does seems to drop a requirement that any call behaves as if 
no overloads were added. Paragraph 3 used to say
"A call to a member function signature described in the C ++ standard
library behaves as if the implementation
declares no additional member function signatures."
whereas the new wording says
"provided that any call to the member function that would select an
overload from the set of declarations described in this standard
behaves as if that overload were selected."
<p/>
This can be read as meaning that if there's no default constructor
specified, like for instance for <tt>std::ostream</tt>, an implementation is free to
add it. It can also be read as meaning that an implementation is free to
add any overloads that wouldn't change the overload resolution result
of any call expression that would select a specified overload. That's
vastly different from allowing extensions that add new functions rather
than new overloads.
<p/>
Was this relaxation intentional?
</p>
<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Ville provides a motivating example.
</p>

<p>
<blockquote>
<pre>
#include &lt;iostream&gt;

class my_stream : std::ostream
{
};

int main()
{
    my_stream ms;
}
</pre>
</blockquote>
</p>

<p>This example is accepted by libstdc++, msvc rejects it, and clang+libc++
segfault on melpon.org/wandbox o_O. An earlier clang+libc++ just accepts
it. I don't think the implementation divergence is caused by the acceptance
of the referred-to <a href="lwg-defects.html#2259">2259</a>, but it certainly seems to increasingly bless
the implementation divergence.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to issue <a href="lwg-active.html#2695">2695</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2564" href="#2564">2564.</a> [fund.ts.v2] <tt>std::experimental::function</tt> constructors taking allocator arguments may throw exceptions</h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song  <b>Opened:</b> 2015-12-05 <b>Last modified:</b> 2016-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::func.wrap.func">active issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func">issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
[This is essentially LWG <a href="lwg-active.html#2370">2370</a>, but deals with the fundamentals TS version rather than the one in the standard]
<p/>
In 99 [func.wrap.func] of library fundamentals TS, the constructors
</p>
<blockquote><pre>
template&lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) noexcept;
</pre></blockquote>
<p>
must type-erase and store the provided allocator, since the <tt>operator=</tt> specification requires using the "allocator 
specified in the construction of" the <tt>std::experimental::function</tt> object. This may require a dynamic allocation 
and so cannot be noexcept. Similarly, the following constructors
</p>
<blockquote><pre>
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, const function&amp;); 
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, function&amp;&amp;);
template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);
</pre></blockquote>
<p>
cannot satisfy the C++14 requirement that they "shall not throw exceptions if [the <tt>function</tt> object to be stored] 
is a callable object passed via <tt>reference_wrapper</tt> or a function pointer" if they need to type-erase and store the 
allocator.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>.
</p>

<ol>
<li><p> Edit 99 [func.wrap.func], class template <tt>function</tt> synopsis, as follows:</p>

<blockquote>
<pre>
namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    [&hellip;]

    template&lt;class R, class... ArgTypes&gt;
    class function&lt;R(ArgTypes...)> {
    public:    
      [&hellip;]
      template&lt;class A> function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
      template&lt;class A> function(allocator_arg_t, const A&amp;,
        nullptr_t) <del>noexcept</del>;
      [&hellip;]
    };

    [&hellip;]

  } // namespace fundamentals_v2
  } // namespace experimental

  [&hellip;]

} // namespace std
</pre>
</blockquote>
</li>

<li><p>Insert the following paragraphs after 99 [func.wrap.func.con]/1:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: This just reproduces the wording from C++14 with the "shall not throw exceptions for 
<tt>reference_wrapper</tt>/function pointer" provision deleted. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<p>
-1- When a <tt>function</tt> constructor that takes a first argument of type <tt>allocator_arg_t</tt> is invoked, 
the second argument is treated as a <em>type-erased allocator</em> (8.3). If the constructor moves or makes a copy 
of a function object (C++14 &sect;20.9), including an instance of the <tt>experimental::function</tt> class template, 
then that move or copy is performed by <em>using-allocator construction</em> with allocator <tt>get_memory_resource()</tt>. 
</p>
<blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, nullptr_t);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Postconditions</i>: <tt>!*this if !f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: May throw <tt>bad_alloc</tt> or any exception thrown by the copy constructor of the stored callable object. 
[<i>Note</i>: Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, 
for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to an object and a member function pointer. 
&mdash; <i>end note</i>]</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- Effects: If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move-constructs the target of <tt>f</tt> into the 
target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an unspecified value.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>F</tt> shall be <tt>CopyConstructible</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless <tt>f</tt> is Callable 
(C++14 &sect;20.9.11.2) for argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt> if any of the following hold:</ins>
<ul>
<li><p><ins><tt>f</tt> is a null function pointer value.</ins></p></li>
<li><p><ins><tt>f</tt> is a null member pointer value.</ins></p></li>
<li><p><ins><tt>F</tt> is an instance of the <tt>function</tt> class template, and <tt>!f</tt>.</ins></p></li>
</ul>
<p/>
<ins>-?- Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> initialized with <tt>std::move(f)</tt>. [<i>Note</i>: 
Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, for example, 
where <tt>f</tt>'s target is an object holding only a pointer or reference to an object and a member function pointer. &mdash; 
<i>end note</i>]</ins>
<p/>
<ins>-?- <i>Throws</i>: May throw <tt>bad_alloc</tt> or any exception thrown by <tt>F</tt>'s copy or move constructor.</ins>
</p>
</blockquote>
</blockquote>
<p>
-2- In the following descriptions, let <tt><i>ALLOCATOR_OF</i>(f)</tt> be the allocator specified in the construction 
of <tt>function f</tt>, or <tt>allocator&lt;char&gt;()</tt> if no allocator was specified.
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2567" href="#2567">2567.</a> Specification of logical operator traits uses <tt>BaseCharacteristic</tt>, which is defined only for <tt>UnaryTypeTraits</tt> 
and <tt>BinaryTypeTraits</tt></h3>
<p><b>Section:</b> 20.15.8 [meta.logical] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-10 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in [meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in [meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> uses the term <tt>BaseCharacteristic</tt>, which 
is problematic in several ways:
</p>
<ul>
<li><p>That term is defined in 20.15.1 [meta.rqmts], but only for <tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt>. 
<tt>conjunction</tt> and <tt>disjunction</tt> seem to be neither.</p></li>
<li><p>20.15.1 [meta.rqmts] also requires the <tt>BaseCharacteristic</tt> for both <tt>UnaryTypeTraits</tt> and 
<tt>BinaryTypeTraits</tt> to be a specialization of <tt>integral_constant</tt>, which is inconsistent with the current design of 
<tt>conjunction</tt> and <tt>disjunction</tt>.</p></li>
<li><p>The requirement in 20.15.1 [meta.rqmts] that "member names of the <tt>BaseCharacteristic</tt> shall not be hidden 
and shall be unambiguously available" seems impossible to meet in every case, since the arbitrary base class from which a 
specialization of <tt>conjunction</tt> or <tt>disjunction</tt> derives may contain members called <tt>conjunction</tt> or 
<tt>disjunction</tt> that will necessarily be hidden.</p></li>
</ul>
<p><i>[08-2016 - Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2567">2567</a> and <a href="lwg-active.html#2568">2568</a></p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>In [meta.logical]/3, edit as follows:</p>

<p>The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that</ins>
is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
<ins>aforementioned base</ins><del>BaseCharacteristic</del> is
the last type in the list.
[ Note: This means a specialization of conjunction does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type. — end note ]</p>

<p>In [meta.logical]/6, edit as follows:</p>

<p>The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that</ins>
is the first type <tt>Bi</tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
<ins>aforementioned base</ins><del>BaseCharacteristic</del> is
the last type in the list.
[ Note: This means a specialization of disjunction does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type. — end note ]</p>
</blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>In [meta.logical]/3, edit as follows:</p>

<p>The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either<br/>
* the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or<br/>
* if there is no such <tt>Bi</tt>, the last type in the list.</ins><br/>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
BaseCharacteristic is the last type in the list.</del><br/>
[ Note: This means a specialization of <tt>conjunction</tt> does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type. — end note ]</p>

<p>In [meta.logical]/6, edit as follows:</p>
<p>The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either<br/>
* the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or<br/>
* if there is no such <tt>Bi</tt>, the last type in the list.</ins><br/>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
BaseCharacteristic is the last type in the list.</del><br/>
[ Note: This means a specialization of <tt>disjunction</tt> does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type. — end note ]</p></blockquote>

Merged the resolution of <a href="lwg-active.html#2587">2587</a> with this issue. This proposed resolution
resolves both, and includes fixes from Daniel for negation.


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>
<ol>
<li>
<p>In 20.15.8 [meta.logical] p3, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct conjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>-3- The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ul style="list-style-type: none">
<li><ins>&mdash; the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>false</tt>, or</ins></li>
<li><ins>&mdash; if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ul>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
BaseCharacteristic is the last type in the list.</del></p>
<p><ins>-?- The member names of the base class, other than <tt>conjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>conjunction</tt>. [<em>Note: </em>
This means a specialization of <tt>conjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p6, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct disjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>-6- The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ul style="list-style-type: none">
<li><ins>&mdash; the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>true</tt>, or,</ins></li>
<li><ins>&mdash; if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ul>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
BaseCharacteristic is the last type in the list.</del></p>
<p><ins>-?- The member names of the base class, other than <tt>disjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>disjunction</tt>. [<em>Note: </em>This
means a specialization of <tt>disjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p8, edit as follows</p>
<pre>
template&lt;class B&gt; struct negation : bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt; { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="2568" href="#2568">2568.</a> [fund.ts.v2] Specification of logical operator traits uses <tt>BaseCharacteristic</tt>, which is defined only for 
<tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::meta.logical] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-10 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::meta.logical">active issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::meta.logical">issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> uses the term <tt>BaseCharacteristic</tt>, which 
is problematic in several ways:
</p>
<ul>
<li><p>That term is defined in 20.15.1 [meta.rqmts], but only for <tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt>. 
<tt>conjunction</tt> and <tt>disjunction</tt> seem to be neither.</p></li>
<li><p>20.15.1 [meta.rqmts] also requires the <tt>BaseCharacteristic</tt> for both <tt>UnaryTypeTraits</tt> and 
<tt>BinaryTypeTraits</tt> to be a specialization of <tt>integral_constant</tt>, which is inconsistent with the current design of 
<tt>conjunction</tt> and <tt>disjunction</tt>.</p></li>
<li><p>The requirement in 20.15.1 [meta.rqmts] that "member names of the <tt>BaseCharacteristic</tt> shall not be hidden 
and shall be unambiguously available" seems impossible to meet in every case, since the arbitrary base class from which a 
specialization of <tt>conjunction</tt> or <tt>disjunction</tt> derives may contain members called <tt>conjunction</tt> or 
<tt>disjunction</tt> that will necessarily be hidden.</p></li>
</ul>
<p><i>[08-2016 - Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2567">2567</a> and <a href="lwg-active.html#2568">2568</a></p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2578" href="#2578">2578.</a> Iterator requirements should reference iterator traits</h3>
<p><b>Section:</b> 24.2 [iterator.requirements], 24.4.1 [iterator.traits] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-01-05 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=38504">this reflector discussion</a>
for background.
<p/>
24.2 [iterator.requirements] attempts to establish requirements for iterators,
but 24.4.1 [iterator.traits]/1 establishes further requirements that must be met
in order to author a portable iterator that works with existing implementations.
Failing to meet the requirements of the latter will fail to work in practice.
The former requirements should reference the latter, normatively.
</p>


<p><b>Proposed resolution:</b></p>
After [iterator.requirements.general]/5, insert the following new paragraph:

<blockquote>
<p>
<ins>
-?- In addition to these requirements, the nested typedefs specified
in ([iterator.traits]) shall be provided for the iterator type. [<i>Note:</i>
Either the iterator type must provide the typedefs directly (in which
case iterator_traits pick them up automatically), or an iterator_traits
specialization must provide them. <i>-end note</i>]
</ins>
</p>
</blockquote>





<hr>
<h3><a name="2587" href="#2587">2587.</a> "Convertible to <tt>bool</tt>" requirement in <tt>conjunction</tt> and <tt>disjunction</tt></h3>
<p><b>Section:</b> 20.15.8 [meta.logical] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-01-18 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in [meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in [meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> in 20.15.8 [meta.logical] p2 and p5 requires 
<tt>Bi::value</tt> to be convertible to <tt>bool</tt>, but nothing in the specification of the actual behavior of the 
templates, which instead uses the expressions <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt> instead, 
actually requires this conversion.
<p/>
If the intention of this requirement is to allow implementations to pass <tt>Bi::value</tt> directly to <tt>std::conditional</tt>, 
like the sample implementation in P0013R1:
</p>
<blockquote><pre>
template&lt;class B1, class B2&gt;
struct and_&lt;B1, B2&gt; : conditional_t&lt;B1::value, B2, B1&gt; { };
</pre></blockquote>
<p>
then it's insufficient in at least two ways:
</p>
<ol>
<li><p>Nothing in the specification requires the result of comparing <tt>Bi::value</tt> with <tt>false</tt> to be consistent 
with the result of the implicit conversion. This is similar to LWG <a href="lwg-active.html#2114">2114</a>, though I don't think the 
<tt>BooleanTestable</tt> requirements in that issue's P/R covers <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt>.</p></li>
<li><p>More importantly, the above implementation is ill-formed for, e.g., 
<tt>std::conjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;</tt>, because converting 2 
to <tt>bool</tt> is a narrowing conversion that is not allowed for non-type template arguments (see 5.20 [expr.const]/4). 
(Note that GCC currently doesn't diagnose this error at all, and Clang doesn't diagnose it inside system headers.) It's not clear 
whether such constructs are intended to be supported, but if they are not, the current wording doesn't prohibit it.</p></li> 
</ol>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>

<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.15.8 [meta.logical] as indicated:</p>

<blockquote>
<pre>
template&lt;class... B&gt; struct conjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- The BaseCharacteristic of a specialization <tt>conjunction&lt;B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub>&gt;</tt>
is the first type <tt>B<sub><i>i</i></sub></tt> in the list <tt>true_type, B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub></tt>
for which <tt><del>B<sub><i>i</i></sub>::value == false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>,
or if every <tt><del>B<sub><i>i</i></sub>::value != false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, the
BaseCharacteristic is the last type in the list. [&hellip;]
<p/>
-4- For a specialization <tt>conjunction&lt;B<sub>1</sub>, ..., B<sub><i>N</i></sub>&gt;</tt>, if there is a template
type argument <tt>B<sub><i>i</i></sub></tt> with <tt><del>B<sub><i>i</i></sub>::value ==
false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>, then instantiating [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... B&gt; struct disjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- The BaseCharacteristic of a specialization <tt>disjunction&lt;B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub>&gt;</tt>
is the first type <tt>B<sub><i>i</i></sub></tt> in the list <tt>false_type, B<sub><i>1</i></sub>, ...,
B<sub><i>N</i></sub></tt> for which <tt><del>B<sub><i>i</i></sub>::value !=
false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, or if every
<tt><del>B<sub><i>i</i></sub>::value == false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>, the
BaseCharacteristic is the last type in the list. [&hellip;]
<p/>
-7- For a specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>, if there is a template type argument <tt>Bi</tt> with
<tt><del>B<sub><i>i</i></sub>::value != false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, then instantiating
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class B&gt; struct negation : bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt; { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
The resolution for this issue was combined with the resolution for LWG <a href="lwg-active.html#2567">2567</a>.





<hr>
<h3><a name="2588" href="#2588">2588.</a> [fund.ts.v2] "Convertible to <tt>bool</tt>" requirement in <tt>conjunction</tt> and <tt>disjunction</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::meta.logical] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-01-18 <b>Last modified:</b> 2016-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::meta.logical">active issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::meta.logical">issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> in 99 [meta.logical] p2 and p5 requires 
<tt>Bi::value</tt> to be convertible to <tt>bool</tt>, but nothing in the specification of the actual behavior of the 
templates, which instead uses the expressions <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt> instead, 
actually requires this conversion.
<p/>
If the intention of this requirement is to allow implementations to pass <tt>Bi::value</tt> directly to <tt>std::conditional</tt>, 
like the sample implementation in P0013R1:
</p>
<blockquote><pre>
template&lt;class B1, class B2&gt;
struct and_&lt;B1, B2&gt; : conditional_t&lt;B1::value, B2, B1&gt; { };
</pre></blockquote>
<p>
then it's insufficient in at least two ways:
</p>
<ol>
<li><p>Nothing in the specification requires the result of comparing <tt>Bi::value</tt> with <tt>false</tt> to be consistent 
with the result of the implicit conversion. This is similar to LWG <a href="lwg-active.html#2114">2114</a>, though I don't think the 
<tt>BooleanTestable</tt> requirements in that issue's P/R covers <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt>.</p></li>
<li><p>More importantly, the above implementation is ill-formed for, e.g., 
<tt>std::conjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;</tt>, because converting 2 
to <tt>bool</tt> is a narrowing conversion that is not allowed for non-type template arguments (see 5.20 [expr.const]/4). 
(Note that GCC currently doesn't diagnose this error at all, and Clang doesn't diagnose it inside system headers.) It's not clear 
whether such constructs are intended to be supported, but if they are not, the current wording doesn't prohibit it.</p></li> 
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2589" href="#2589">2589.</a> <tt>match_results</tt> can't satisfy the requirements of a container</h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2016-01-24 <b>Last modified:</b> 2016-05-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results">active issues</a> in [re.results].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4567 28.10 [re.results] p2 mentions
</p>
<blockquote>
<p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specifed in 23.2.3, except that only operations defined for const-qualified sequence
containers are supported.
</p>
</blockquote>
<p>
However, this is impossible because <tt>match_results</tt> has a <tt>operator==</tt> whose semantics differs from the one 
required in Table 95 &mdash; "Container requirements".
<p/>
Table 95 requires that <tt>a == b</tt> is an equivalence relation and means <tt>equal(a.begin(), a.end(), b.begin(), b.end())</tt>. 
But for <tt>match_results</tt>, <tt>a == b</tt> and <tt>equal(a.begin(), a.end(), b.begin(), b.end())</tt> can give different 
results. For example:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

int main()
{
  std::regex re("a*");
  std::string target("baaab");
  std::smatch a;

  std::regex_search(target, a, re);

  std::string target2("raaau");
  std::smatch b;

  std::regex_search(target2, b, re);

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; (a == b) &lt;&lt; '\n'; // false
  std::cout &lt;&lt; std::equal(a.begin(), a.end(), b.begin(), b.end()) &lt;&lt; '\n'; // true
}
</pre></blockquote>
<p><i>[2016-02, Issues Telecon]</i></p>

Marshall: The submitter is absolutely right, but the proposed resolution is insufficient. We should avoid "shall", for once.<br/>
Jonathan: This is NAD, because the container comparison functions say "unless otherwise stated", 23.3.1p14 and table 97.<br/>
Ville: wrong, table 95 is relevant for ==.<br/>
Jonathan: good point<br/>

<p>2016-05: Marshall cleans up the wording around the change</p>



<p><b>Proposed resolution:</b></p>
<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
-2- The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 23.2.3, except that only operations defined for const-qualified sequence
containers are supported <ins>and that the semantics of comparison functions are different from those required for a 
container</ins>.
</p></blockquote>
</li>
</ol>
</blockquote>

<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
-2- The class template <tt>match_results</tt> <del>shall satisfy</del><ins>satisfies</ins> the requirements of an allocator-aware container and of a
sequence container, <del>as specified in </del><ins>(</ins>23.2.3<ins>)</ins>, except that only operations defined for const-qualified sequence
containers are supported <ins>and the semantics of comparison functions are different from those required for a 
container</ins>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2592" href="#2592">2592.</a> Require that <tt>chrono::duration_cast</tt>s from smaller durations to larger durations do not overflow</h3>
<p><b>Section:</b> 20.17.2 [time.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andy Giese <b>Opened:</b> 2016-02-05 <b>Last modified:</b> 2016-05-08</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.syn">issues</a> in [time.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 20.17.2 [time.syn] states
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 45 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 35 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 29 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 23 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
However, a <tt>duration_cast&lt;minutes&gt;(seconds::max())</tt> would cause overflow if the underlying signed integers 
only met the minimums specified.
<p/>
The standard should specify that implementations guarantee that a <tt>duration_cast</tt> from any smaller duration in 
these "convenience typedefs" will not overflow any larger duration. That is, <tt>hours</tt> should be able to hold 
the maximum of <tt>minutes</tt>, which should be able to hold the maximum of <tt>seconds</tt> and so on.
<p/>
More formally, if the ratio <tt>typedef A</tt> and <tt>typedef B</tt> is <tt>1:Y</tt> where <tt>Y &gt; 1</tt> (e.g., 
1 : 60 in case of <tt>minutes</tt> : <tt>seconds</tt>), then <tt>#bits<sub>A</sub>-1</tt> must be at least 
<tt>ceil(log<sub>2</sub>(2<sup>#bits<sub>B</sub>-1)/Y)</sup>)</tt>.
<p/>
In the case of <tt>minutes</tt> : <tt>seconds</tt>, <tt>X = 1</tt>, <tt>Y = 60</tt>. Let 
<tt>#bits<sub>seconds</sub> = 32</tt>. Therefore:
</p>
<ul>
<li><p><tt>2<sup>(#bits<sub>seconds</sub> - 1)</sup> = 2<sup>31</sup> = 2147483648</tt></p></li>
<li><p><tt>ceil(log<sub>2</sub>(2<sup>31</sup> / 60) = 26</tt></p></li>
<li><p><tt>#bits<sub>minutes</sub> - 1 = 26</tt></p></li>
<li><p><tt>#bits<sub>minutes</sub> = 27</tt></p></li>
</ul>
<p>
Therefore, a minimum of 27 bits would be needed to store <tt>minutes</tt> if 32 were used to store <tt>seconds</tt>.
<p/>
I propose to change the definitions of the convenience typedefs as follows:
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 46 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 37 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 32 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 27 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
These bits were chosen to satisfy the above formula. Note that
minimums only increased, so larger ranges could be held. A nice
outcome of this choice is that <tt>minutes</tt> does not go above 32 bits.
</p>

<p><i>[2016-04-23, Tim Song comments]</i></p>

<p>
The P/R of LWG 2592 doesn't fix the issue it wants to solve, because the actual underlying type will likely 
have more bits than the specified minimum.
<p/>
Consider <tt>seconds</tt>, which the P/R requires to have at least 37 bits. On a typical system this implies 
using a 64-bit integer. To ensure that casting from <tt>seconds::max()</tt> to <tt>minutes</tt> doesn't overflow 
in such a system, it is necessary for the latter to have at least 59 bits (which means, in practice, 64 bits too), 
not just 32 bits. Thus, just changing the minimum number of bits will not be able to provide the desired guarantee 
that casting from a smaller unit to a larger one never overflow.
<p/>
If such a guarantee is to be provided, it needs to be spelled out directly. Note that the difference here is 9 bits 
(for the 1000-fold case) and 5 bits (for the 60-fold case), which is less than the size difference between integer 
types on common systems, so such a requirement would effectively require those convenience typedefs to use the 
same underlying integer type.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 20.17.2 [time.syn], header <tt>&lt;chrono&gt;</tt> synopsis, as indicated</p>

<blockquote><pre>
[&hellip;]

<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least <ins>46</ins><del>45</del> bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least <ins>37</ins><del>35</del> bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least <ins>32</ins><del>29</del> bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least <ins>27</ins><del>23</del> bits</i>, ratio&lt;3600&gt;&gt; hours;

[&hellip;]
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="2593" href="#2593">2593.</a> Moved-from state of Allocators</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-02-19 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements] suggests that the moved-from state of an allocator may be unequal to its 
previous state. Such a move constructor would break most container implementations, which move-construct the 
embedded allocator along with a compressed pair. Even if a moved-from container is empty, it should still 
subsequently allocate from the same resource pool as it did before.
</p>
<blockquote><pre>
std::vector&lt;int, pool&gt; a(500, my_pool);
auto b = std::move(a); // b uses my_pool too.
a.resize(500); // should still use my_pool.
</pre></blockquote>

<p><i>[2016-02, Jacksonville]</i></p>

<p>Marshall will see if this can be resolved editorially.</p>

<p>
After discussion, the editors and I decided that this could not be handled editorially. 
The bit about a moved-from state of an allocator being the same as the original state is a
normative change. I submitted a <a href="https://github.com/cplusplus/draft/pull/727">pull request</a>
to handle the mismatched variables in the table.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as indicated:
<blockquote class="note">
<p>
Note there's an editorial error in Table 28 in that line and the surrounding ones. The left column was apparently 
updated to use <tt>u</tt> and the right column is still using <tt>a</tt>/<tt>a1</tt>/<tt>b</tt>.
</p>
</blockquote>
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X u(move(a));<br/>
X u = move(a);</tt>
</td>
<td></td>
<td>
Shall not exit via an exception.
post: <ins><tt>u</tt> is equal to <tt>a</tt> and equal to the prior value of <tt>a</tt></ins><del><tt>a1</tt> 
equals the prior value of <tt>a</tt></del>.
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>

</blockquote>

<p><i>[2016-06-20, Oulu, Daniel comments]</i></p>

<p>
According to the current working draft, the situation has changed due to changes performed by the project editor, the revised 
resolution has been adjusted to N4594.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X u(std::move(a));<br/>
X u = std::move(a);</tt>
</td>
<td></td>
<td>
Shall not exit via an exception.
post: <ins><tt>u</tt> is equal to <tt>a</tt> and equal to the prior value of <tt>a</tt></ins><del><tt>u</tt> is equal to the prior
value of <tt>a</tt>.</del>.
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2594" href="#2594">2594.</a> Contradicting definition of empty <tt>shared_ptr</tt> on <tt>shared_ptr(nullptr, d)</tt></h3>
<p><b>Section:</b> 20.11.2.2 [util.smartptr.shared] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-02-20 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Latest draft (N4567) 20.11.2.2 [util.smartptr.shared] p1 says:
</p>
<blockquote>
<p>
A <tt>shared_ptr</tt> object is <em>empty</em> if it does not own a pointer.
</p>
</blockquote>
<p>
Please note that it says "own a pointer". This definition was added as
the resolution for LWG defect <a href="lwg-defects.html#813">813</a>.
<p/>
20.11.2.2.1 [util.smartptr.shared.const] p8 says about the effect of
<tt>shared_ptr(nullptr_t p, D d)</tt>:
</p>
<blockquote>
<p>
<i>Effects</i>: Constructs a <tt>shared_ptr</tt> object that <em>owns</em> the object <tt>p</tt> and the deleter <tt>d</tt>.
</p>
</blockquote>
<p>
Please note that it says "<em>owns</em> the object". This was intentionally
changed from "the pointer" as a part of resolution for LWG defect <a href="lwg-defects.html#758">758</a>,
to cover <tt>nullptr_t</tt> case.
<p/>
Since <tt>shared_ptr(nullptr, d)</tt> owns an object of type <tt>nullptr_t</tt>, but does
not own a pointer, it is said as "empty" by a strict reading of the
above mentioned definition in 20.11.2.2 [util.smartptr.shared] p1.
<p/>
These cause a contradiction:
<p/>
20.11.2.2.1 [util.smartptr.shared.const] p9 sets a postcondition
<tt>use_count() == 1</tt> on <tt>shared_ptr(nullptr, d)</tt>. But 
20.11.2.2.5 [util.smartptr.shared.obs] p7 says that the return value of <tt>use_count()</tt>
is "<tt>0</tt> when <tt>*this</tt> is <em>empty</em>".
</p>
<p>
Proposed wording changes:
<p/>
Replace the last 2 words in 20.11.2.2 [util.smartptr.shared] p1 from
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own a pointer.
</p></blockquote>
<p>
to
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own an object.
</p></blockquote>
<p>
Note that <tt>shared_ptr(nullptr_t)</tt> is defined to be empty in synopsis in
20.11.2.2 [util.smartptr.shared].
</p>
<blockquote><pre>
constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
</pre></blockquote>
<p>
It could be less confusing if <tt>shared_ptr(nullptr, d)</tt> could be defined to
be empty. But it seems too late to change that (which means changing
whether the deleter is called or not, see 
<a href="https://stackoverflow.com/questions/11164354/">this Stackoverflow article</a>). 
Then I'm proposing just fix the contradiction.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 20.11.2.2 [util.smartptr.shared] p1 as indicated:</p>

<blockquote>
<p>-1- The <tt>shared_ptr</tt> class template stores a pointer, usually obtained via <tt>new</tt>. <tt>shared_ptr</tt> 
implements semantics of shared ownership; the last remaining owner of the pointer is responsible for destroying the 
object, or otherwise releasing the resources associated with the stored pointer. A <tt>shared_ptr</tt> object is 
<em>empty</em> if it does not own <ins>an object</ins><del>a pointer</del>.
</p>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2595" href="#2595">2595.</a> <tt>reverse_iterator::operator[]</tt>'s return type revisited</h3>
<p><b>Section:</b> 24.5.1.1 [reverse.iterator], 24.5.1.3.12 [reverse.iter.opindex] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-02-28 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterator">issues</a> in [reverse.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="lwg-defects.html#386">386</a> changed the return type of <tt>reverse_iterator::operator[]</tt> to unspecified. However, 
as of N3066, the return type of a random access iterator's <tt>operator[]</tt> shall be convertible to <tt>reference</tt>; 
thus the return type of <tt>reverse_iterator::operator[]</tt> should be <tt>reference</tt> (and it is in all common
implementations).
<p/>
Suggested resolution: Adjust 24.5.1.1 [reverse.iterator]'s synopsis and 24.5.1.3.12 [reverse.iter.opindex] to 
use <tt>reference</tt> instead of <tt><i>unspecified</i></tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Edit 24.5.1.1 [reverse.iterator], class template <tt></tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Iterator&gt;
  class reverse_iterator {
  public:
    [&hellip;]
    typedef typename iterator_traits&lt;Iterator&gt;::reference reference;
    [&hellip;]
    constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](difference_type n) const;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Change 24.5.1.3.12 [reverse.iter.opindex] before p1 as indicated:</p>

<blockquote>
<pre>
constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](
  typename reverse_iterator&lt;Iterator&gt;::difference_type n) const;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2597" href="#2597">2597.</a> <tt>std::log</tt> misspecified for complex numbers</h3>
<p><b>Section:</b> 26.5.8 [complex.transcendentals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-03-01 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.transcendentals">issues</a> in [complex.transcendentals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>std::log</tt> is inconsistent for complex numbers, specifically, the Returns clause 
(26.5.8 [complex.transcendentals]). On the one hand, it states that the imaginary part of the return value lies 
in the <em>closed</em> interval <tt>[-<i>i</i> &pi;, +<i>i</i> &pi;]</tt>. On the other hand, it says that "the branch 
cuts are along the negative real axis" and "the imaginary part of <tt>log(x)</tt> is <tt>+&pi;</tt> when <tt>x</tt> 
is a negative real number".
</p>
<p>
The inconsistency lies in the difference between the mathematical concept of a branch cut and the nature of floating 
point numbers in C++. The corresponding specification in the C standard makes it clearer that if <tt>x</tt> is a real 
number, then <tt>log(x + 0<i>i</i>) = +&pi;</tt>, but <tt>log(x - 0<i>i</i>) = -&pi;</tt>, i.e. they consider positive 
and negative zero to represent the two different limits of approaching the branch cut from opposite directions. In 
other words, the term "negative real number" is misleading, and in fact there are <em>two distinct</em> real numbers, 
<tt>x + 0<i>i</i></tt> and <tt>x - 0<i>i</i></tt>, that compare equal but whose logarithms differ by <tt>2 &pi; <i>i</i></tt>.
</p>
<p>
The resolution should consist of two parts:
</p>
<ol>
<li><p>Double-check that our usage and definition of "branch cut" is sufficiently unambiguous. The C standard contains 
a lot more wording around this that we don't have in C++.</p></li>
<li><p>Change the Returns clause of <tt>log</tt> appropriately. For example: "When <tt>x</tt> is a negative real number, 
<tt>imag(log(x + 0<i>i</i>))</tt> is <tt>&pi;</tt>, and <tt>imag(log(x - 0<i>i</i>))</tt> is <tt>-&pi;</tt>."</p></li>
</ol>
<p>
Current implementations seem to behave as described in (2). 
(<a href="http://melpon.org/wandbox/permlink/pwBDeGiY3HDtFAh8">Try-it-at-home link</a>)
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2599" href="#2599">2599.</a> Library incomplete type permission phrase is unclear</h3>
<p><b>Section:</b> 20.2.6 [declval], 20.11.1 [unique.ptr], 20.11.1.1.1 [unique.ptr.dltr.general], 20.11.2.2 [util.smartptr.shared], 20.11.2.3 [util.smartptr.weak], 20.11.2.5 [util.smartptr.enab] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-03-08 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the phrase to grant this permission is:
</p>
<blockquote><p>
The template parameter <tt>T</tt> of <tt><i>LibraryTemplate</i></tt> may be an incomplete type.
</p></blockquote>
<p>
Two problems:
</p>
<ol>
<li><p>The timing is unclear.  We always allow specializations like <tt><i>LibraryTemplate</i>&lt;Incomp&gt;* p;</tt></p></li>
<li><p>To the users of a template, the correct terminology should be "argument" rather than "parameter".</p></li>
</ol>
<p>
Suggested resolution:
</p>
<blockquote><p>
In an instantiation of <tt><i>LibraryTemplate</i></tt>, an incomplete type
may be used as the template argument for the template parameter <tt>T</tt>.
</p></blockquote>
<p>
as shown <a href="https://github.com/cplusplus/draft/pull/304/files">here</a>.
<p/>
Or, to copy <a href=" http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4510.html">N4510's wording</a>:
</p>
<blockquote><p>
An incomplete type <tt>T</tt> may be used when instantiating <tt><i>LibraryTemplate</i></tt>.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2663" href="#2663">2663.</a> Enable efficient retrieval of file size from <code>directory_entry</code></h3>
<p><b>Section:</b> 27.10.15.14 [fs.op.file_size] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Gor Nishanov <b>Opened:</b> 2014-05-22 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  On Windows, the <code><del>FindFileData</del> <ins>WIN32_FIND_DATA</ins></code> structure, which is the underlying data type for <code>directory_entry</code>, contains the file size as one of the fields.

  Thus efficient enumeration of files and getting their sizes is possible without doing a separate query for the file size.

</p>
  <p><i>[17 Jun 2014 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>

  <p><i>[23 Nov 2015 Editorally correct name of data structure mentioned in discussion.]</i></p>


<p><i>[Mar 2016 Jacksonville Beman to provide paper about this]</i></p>


<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><i>[2016-08, Beman comments]</i></p>

<p>
This will be resolved by <a href="http://wg21.link/p0317r1">P0317R1</a>, Directory Entry Caching for Filesystem.
</p>


<p><b>Proposed resolution:</b></p>
  <p>
    <i>
      In 27.10.12 [class.directory_entry] Class <code>directory_entry</code> add the
      following observer declarations:
    </i>
  </p>
  <p></p>
  <blockquote>
    <pre>
      uintmax_t file_size();
      uintmax_t file_size(error_code&amp; ec) noexcept;
    </pre>
  </blockquote>
  <p>
    <i>
      In <code>directory_entry</code> observers 27.10.12.3 [directory_entry.obs]
      add the following:
    </i>
  </p>
  <p></p>
  <blockquote>
    <pre>
      uintmax_t file_size();
      uintmax_t file_size(error_code&amp; ec) noexcept;
    </pre>
    <p></p>
    <blockquote>
      <p>
        <i>Returns:</i> if <code>*this</code> contains a cached file size, return
        it.
        Otherwise return <code>file_size(path())</code> or <code>file_size(path(), ec)</code>
        respectively.
      </p>
      <p>
        <i>Throws:</i> As specified in Error reporting (7).
      </p>
    </blockquote>
  </blockquote>






<hr>
<h3><a name="2664" href="#2664">2664.</a> <code>operator/</code> (and other append) semantics not useful if argument has root</h3>
<p><b>Section:</b> 27.10.8.4.3 [path.append], 27.10.8.6 [path.non-member] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2014-05-30 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#path.append">active issues</a> in [path.append].</p>
<p><b>View all other</b> <a href="lwg-index.html#path.append">issues</a> in [path.append].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  In a recent discussion on the Boost developers mailing list, the semantics of <code>operator /</code>
  and other append operations were questioned:
<p/>
In brief, currently <code>p1 / p2</code> is required to concatenate the
  lexical representation of <code>p1</code> and <code>p2</code>, inserting a
  preferred separator as needed.
<p/>
This means that, for example, <code>&quot;c:\x&quot; / &quot;d:\y&quot;</code> gives <code>
    &quot;c:\x\d:\y&quot;</code>, and that <code>&quot;c:\x&quot; / &quot;\\server\share&quot;</code>
    gives <code>&quot;c:\x\\server\share&quot;</code>. This is rarely, if ever, useful.
<p/>
An alternative interpretation of <code>p1 / p2</code> could be that it yields a
  path that is the approximation of what <code>p2</code> would mean if interpreted
  in an environment in which <code>p1</code> is the starting directory. 
  Under this interpretation, <code>&quot;c:\x&quot; / &quot;d:\y&quot;</code> gives <code>&quot;d:\y&quot;</code>,
  which is more likely to match what was intended.
<p/>
I am not saying that this second interpretation is the right one, but I do say
  that we have reasons to suspect that the first one (lexical concatenation using
  a separator) may not be entirely correct.
  This leads me to think that the behavior of <code>p1 / p2</code>, when <code>p2</code>
  has a root, needs to be left implementation-defined, so that implementations are
  not required to do the wrong thing, as above.
<p/>
This change will not affect the ordinary use case in which <code>p2</code> is a
  relative, root-less, path.
</p>  
<p><i>[17 Jun 2014 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>


<p><i>[2016-02, Jacksonville]</i></p>

<p>Beman to provide wording.</p>

<p><i>[2016-06-13, Beman provides wording and rationale]</i></p>

<p>
<b>Rationale:</b> The purpose of the append operations is to provide a simple concatenation facility for users 
wishing to extend a path by appending one or more additional elements, and to do so without worrying about the 
details of when a separator is needed. In that context it makes no sense to provide an argument that has a 
<i>root-name</i>. The simplest solution is simply to require <code>!p.has_root_name()</code>.
The other suggested solutions IMO twist the functions into something harder to reason about
yet any advantages for users are purely speculative. The concatenation functions can
be used instead for corner cases.
</p>

<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><i>[2016-07-03, Daniel comments]</i></p>

<p>
The same wording area is touched by LWG <a href="lwg-active.html#2732">2732</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4594.</p>
<ol>
<li><p><i>Change 27.10.8.4.3 [path.append] path appends as indicated:</i></p>

<blockquote>
<code>path&amp; operator/=(const path&amp; p);</code>
<blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!p.has_root_name()</code>.</ins></p>
  <p>-2- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt> unless:</p>
  <ul>
  <li><p>an added <i>directory-separator</i> would be redundant, or</p></li>
  <li><p>an added <i>directory-separator</i> would change a relative path to an absolute path 
  [<i>Note:</i> An empty path is relative. &mdash; <i>end note</i>], or</p></li>
  <li><p><code>p.empty()</code> is <tt>true</tt>, or</p></li>
  <li><p><code>*p.native().cbegin()</code> is a <i>directory-separator</i>.</p></li>
  </ul>
  <p>Then appends <code>p.native()</code> to <tt>pathname</tt>.</p>
  <p>-3- <i>Returns:</i> <code>*this</code>.</p>
</blockquote>
<code>template &lt;class Source&gt;<br/>
&nbsp; path&amp; operator/=(const Source&amp; source);<br/>
template &lt;class Source&gt;<br/>
&nbsp; path&amp; append(const Source&amp; source);<br/>
template &lt;class InputIterator&gt;<br/>
&nbsp; path&amp; append(InputIterator first, InputIterator last);</code>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <code>!source.has_root_name()</code> or
<code>!*first.has_root_name()</code>, respectively.</ins>
<p/>
-4- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt>,
converting format and encoding if required (27.10.8.2 [path.cvt]), unless:
</p>
<ul>
  <li><p>an added <i>directory-separator</i> would be redundant, or</p></li>
  <li><p>an added <i>directory-separator</i> would change a relative path to an absolute path, or</p></li>
  <li><p><code>source.empty()</code> is <tt>true</tt>, or</p></li>
  <li><p><code>*source.native().cbegin()</code> is a <i>directory-separator</i>.</p></li>
</ul>
<p>
Then appends the effective range of <code>source</code> (27.10.8.3 [path.req]) or the range
<code>[first, last)</code> to <code>pathname</code>, converting format and encoding if required (27.10.8.2 [path.cvt]).
<p/>
-5- <i>Returns:</i> <code>*this</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p><i>Change 27.10.8.6 [path.non-member] path non-member functions as indicated:</i></p>

<blockquote>
<code>path operator/(const path&amp; lhs, const path&amp; rhs);</code>
  <blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!rhs.has_root_name()</code>.</ins></p>
  <p>-13- <i>Returns:</i> <code>path(lhs) /= rhs</code>.</p>
  </blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03 Chicago]</i></p>

<p>After discussion on <a href="lwg-active.html#2732">2732</a>, it was determined that the PR for that issue should be
applied to this issue before it is accepted. That PR changes all the path appends to go through
operator/=, so only one requires element remains necessary.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606, and assumes that the PR for <a href="lwg-active.html#2732">2732</a> is applied.</p>
<p><i>Change 27.10.8.4.3 [path.append] path operator/= as indicated:</i></p>

<blockquote>
<code>path&amp; operator/=(const path&amp; p);</code>
<blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!p.has_root_name()</code>.</ins></p>
  <p>-2- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt> unless:</p>
  <ul>
  <li><p>an added <i>directory-separator</i> would be redundant, or</p></li>
  <li><p>an added <i>directory-separator</i> would change a relative path to an absolute path
  [<i>Note:</i> An empty path is relative. &mdash; <i>end note</i>], or</p></li>
  <li><p><code>p.empty()</code> is <tt>true</tt>, or</p></li>
  <li><p><code>*p.native().cbegin()</code> is a <i>directory-separator</i>.</p></li>
  </ul>
  <p>Then appends <code>p.native()</code> to <tt>pathname</tt>.</p>
  <p>-3- <i>Returns:</i> <code>*this</code>.</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="2668" href="#2668">2668.</a> <code>path::operator+=</code> is defined, but not <code>operator+</code></h3>
<p><b>Section:</b> 27.10.8 [class.path] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#class.path">issues</a> in [class.path].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>This doesn't seem to be in Boost.Filesystem, so maybe it isn't needed,
but since <code>path += path2</code> works then it seems reasonable to expect
<code>path1 + path2</code> to work as well.</p>

  <p><i>[04 Jul 2014 Beman Dawes comments:]</i></p>

  <blockquote>
    <p>The 12 overloads required by <code>basic_string operator+</code> scared me off,
    and I never came back to the issue.</p>  
  </blockquote>

  <p><i>[22 Nov 2015 Beman supplies proposed resolution wording.]</i></p>

 
<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 




<p><b>Proposed resolution:</b></p>
<p>NAD, Future.</p>
  <blockquote>
  <p>It is not necessary to provide every possible string operation for class
  <code>path</code> because it is always possible to convert to a string,
  perform the operation, and convert back to a path. The most commonly needed string
  operations are provided for class <code>path</code> as a convenience, but every added
  function comes at the cost of increased interface complexity. In this case, the cost
  is judged to outweigh the convenience.</p>
  
  <p>Future changes to the language, such as concepts, and changes to the library, such as
  <code>basic_string_view</code>, may allow reduction of the complexity of the class path
  interface. The LWG may wish to reconsider this issue at that time.</p>
  </blockquote>





<hr>
<h3><a name="2675" href="#2675">2675.</a> <tt>register_callback</tt> can fail</h3>
<p><b>Section:</b> 27.5.3.6 [ios.base.callback] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2016-05-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>register_callback</tt> allocates memory and so it can fail, but the case is unspecified. libc++ sets
<tt>badbit</tt>, which is consistent with <tt>iword</tt> and <tt>pword</tt>. libstdc++ throws <tt>std::bad_alloc</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2676" href="#2676">2676.</a> Provide <code>filesystem::path</code> overloads for <i>File-based streams</i></h3>
<p><b>Section:</b> 27.9 [file.streams] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2016-03-16 <b>Last modified:</b> 2016-05-14</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#file.streams">issues</a> in [file.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
  <p>
    The constructor and <code>open</code> functions for <i>File-based streams</i> in
    27.9 [file.streams] currently provide overloads for <code>const char*</code> and
    <code>const string&amp;</code> arguments that specify the path for the file to be opened.
    With the addition of the File System TS to the standard library, these
    constructors and <code>open</code> functions need to be overloaded for <code>
      const filesystem::path&amp;
    </code> so that file-based streams can take advantage of class <code>filesystem::path</code>
    features such as support for strings of character types <code>wchar_t</code>,
    <code>char16_t</code>, and <code>char32_t</code>.
  </p>
  <p>
    The <code>
      const filesystem::path&amp; p
    </code> overload for these functions is like the
    existing <code>const string&amp;</code> overload; it simply calls the overload of
    the same function that takes a C-style string.</p>
  <p> For operating systems like POSIX
    that traffic in <code>char</code> strings for filenames, nothing more is
    required. For operating systems like Windows that traffic in <code>wchar_t</code>
    strings for filenames, an additional C-style string overload is required.
    The overload's character type needs to be specified as
    <code>std::filesystem::path::value_type</code> to also support possible future
    operating systems that traffic in <code>char16_t</code> or <code>char32_t</code> characters.
  </p>
  
  <p><b>Not recommended:</b></p>
  <p>Given the proposed constructor and <code>open</code> signatures taking
  <code>const filesystem::path&amp;</code>, it would in theory be possible to remove 
  some of the other signatures. This is not proposed because it would break ABI's, break
  user code depending on user-defined automatic conversions to the existing argument types,
  and invalidate existing documentation, books, and tutorials.</p>
  
  <p><b>Implementation experience:</b></p>
  <p>
    The Boost Filesystem library has provided header <code>&lt;boost/filesystem/fstream.hpp&gt;</code>
    implementing the proposed resolution for over a decade.
  </p>
  <p>
    The Microsoft/Dinkumware
    implementation of standard library header <code>&lt;fstream&gt;</code> has provided
    the <code>const wchar_t*</code>
    overloads for many years.
  </p>



<p><b>Proposed resolution:</b></p>

<p><i><span style="background-color: #E1E9FD">At the end of 27.9.1 File streams 
[</span><span style="background-color: #E1E9FD">fstreams</span><span style="background-color: #E1E9FD">] 
add a paragraph:</span></i></p>

<p>In this subclause, member functions taking arguments of <code>
const std::filesystem::path::value_type*</code> shall only be provided on systems 
where <code>std::filesystem::path::value_type</code> ([class.path]) is not <code>
char</code>. [<i>Note:</i> These functions enable class <code>path</code> 
support for systems with a wide native path character type, such as <code>
wchar_t</code>. &mdash; <i>end note</i>]</p>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.1 Class template 
basic_filebuf [filebuf] as indicated:</span></i></p>

<pre>basic_filebuf&lt;charT,traits&gt;* open(const char* s,
    ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode);  // wide systems only; see [fstreams]</ins> 
basic_filebuf&lt;charT,traits&gt;* open(const string&amp; s,
   ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const filesystem::path&amp; p,</ins>
   <ins>ios_base::openmode mode);</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.4 Member functions [filebuf.members] 
as indicated:</span></i></p>

<pre>basic_filebuf&lt;charT,traits&gt;* open(const char* s,
   ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const std::filesystem::path::value_type* s,</ins>
   <ins>ios_base::openmode mode);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.4 Member functions [filebuf.members] 
add:</span></i></p>

<pre><ins>basic_filebuf&lt;charT,traits&gt;* open(const filesystem::path&amp; p,</ins>
   <ins>ios_base::openmode mode);</ins></pre>
   
<blockquote>
  <p><i>Returns:</i> <code>open(p.c_str(), mode);</code></p>
</blockquote>

  <p><i><span style="background-color: #E1E9FD">Change 27.9.1.6 Class template 
basic_ifstream [ifstream] as indicated:</span></i></p>

<pre>explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins>
explicit basic_ifstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.7 basic_ifstream 
constructors [ifstream.cons] as indicated:</span></i></p>

<pre>explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.7 basic_ifstream 
constructors [ifstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_ifstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_ifstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.9 Member functions [ifstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.9 Member functions [ifstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.10 Class template 
basic_ofstream [ofstream] as indicated:</span></i></p>

<pre>explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins>
explicit basic_ofstream(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.11 basic_ofstream 
constructors [ofstream.cons] as indicated:</span></i></p>

<pre>explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.11 basic_ofstream 
constructors [ofstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_ofstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_ofstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.13 Member functions [ofstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.13 Member functions [ofstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.14 Class template 
basic_fstream [fstream] as indicated:</span></i></p>

<pre>explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins>
explicit basic_fstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.15 basic_fstream 
constructors [fstream.cons] as indicated:</span></i></p>

<pre>explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.15 basic_fstream 
constructors [fstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_fstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_fstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.17 Member functions [fstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.17 Member functions [fstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>






<hr>
<h3><a name="2677" href="#2677">2677.</a> <code>directory_entry::status</code> is not allowed to be cached as a quality-of-implementation issue</h3>
<p><b>Section:</b> 27.10.12.3 [directory_entry.obs] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal <b>Opened:</b> 2016-03-03 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#directory_entry.obs">active issues</a> in [directory_entry.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#directory_entry.obs">issues</a> in [directory_entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>To fix multi-threading problems in <code>directory_entry</code>, caching behavior
was removed from the type. This is bad for performance reasons,
because the values can no longer be cached from the result of <code>readdir</code>
on POSIX platforms, or from <code>FindFirstFile/FindNextFile</code> on Windows.</p>

<p>It appears that the intent was to allow implementers to fill in the
values for <code>directory_entry::status</code> inside <code>directory_iterator</code>, but as
currently specified:</p>

    <blockquote><i>Returns:</i> <code>status(path()[, ec])</code>.</blockquote>

<p>This is not allowed to be cached, because the target of the path can
change. For example, consider the following program:</p>

<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;

using namespace std;
namespace fs = ::std::filesystem;

void verify(const bool b, const char * const msg) {
    if (!b) {
        printf("fail: %s\n", msg);
        exit(1);
    }
}

void touch_file(const char * const filename) {
    ofstream f(filename);
    f &lt;&lt; '\n' &lt;&lt; endl;
    verify(f.good(), "File write failed");
}

int main() {
    fs::remove_all("subDir");
    fs::create_directory("subDir");
    fs::create_directory("subDir/child");
    touch_file("subDir/child/child");
    fs::current_path("./subDir");
    fs::directory_iterator dir(".");
    ++dir;
    fs::directory_entry entry = *dir;

    verify(entry == "./child",
      "unexpected subdirectory"); //enumerating "subDir" returned the directory "child"

    fs::file_status status = entry.status();
    verify(status.type() == fs::file_type::directory,
        "subDir/child was not a directory");
    fs::current_path("./child");
    status = entry.status(); // REQUIRED to re-stat() on POSIX,
                             // GetFileAttributes() on Windows
    verify(status.type() == fs::file_type::regular,
        "subDir/child/child was not a regular file");
    return 0;
}</pre>

  <p>
    <code>directory_entry</code> should be re-specified to allow implementers to cache
    the value of <code>status(path)</code> at the time <code>irectory_iterator</code> was
    incremented to avoid repeated <code>stat()</code> / <code>GetFileAttributes</code> calls. (This
    may mean additional constructors are necessary for <code>directory_entry</code> as well)
  </p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Beman is working on a paper to address this.
</p>

<p><i>[2016-08, Beman comments]</i></p>

<p>
This will be resolved by <a href="http://wg21.link/p0317r1">P0317R1</a>, Directory Entry Caching for Filesystem.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2679" href="#2679">2679.</a> Inconsistent Use of Effects and Equivalent To</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dawn Perchik <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-05-08</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<ul>
<li><p>
Some <i>Effects</i>: were intended to include the "Equivalent to" phrasing where no or different words were used.  
See examples in <tt>std::filesystem</tt> and throughout the library.
</p></li>
<li><p>
The wording in [structure.specifications]/4 is incorrect and <i>Effects</i>: throughout the library which use 
(or were intended to use) the "Equivalent to" phrasing need to be checked to make sure they fit the intended wording.
</p></li>
</ul>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
The PR is fine; but bullet #1 in the report really should have a list of places to change.
<p/>
Jonathan checked throughout the library for bullet #2 and found two problems in [string.access], 
which have been added to the PR.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>Change [structure.specifications]/4 as indicated:</p>

<blockquote>
<p>
"[&hellip;] if <tt>F</tt> has no <i>Returns</i>: element, a non-<tt>void</tt> return from <tt>F</tt> is specified by the 
<del>Returns: elements</del><ins>return statements</ins> in the code sequence."
</p>
</blockquote>
</li>

<li><p>Add two <tt>return</tt> keywords to [string.access]:</p>

<blockquote>
<pre>
const charT&amp; front() const;
charT&amp; front();
</pre>
<blockquote>
<p>-7- <i>Requires:</i> <code>!empty()</code>.</p>
<p>-8- <i>Effects:</i> Equivalent to <code><ins>return </ins>operator[](0)</code>.</p>
</blockquote>

<pre>
const charT&amp; back() const;
charT&amp; back();
</pre>
<blockquote>
<p>-9- <i>Requires:</i> <code>!empty()</code>.</p>
<p>-10- <i>Effects:</i> Equivalent to <code><ins>return </ins>operator[](size() - 1)</code>.</p>
</blockquote>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2686" href="#2686">2686.</a> Why is <tt>std::hash</tt> specialized for <tt>error_code</tt>, but not <tt>error_condition</tt>?</h3>
<p><b>Section:</b> 19.5.1 [system_error.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-05-03 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <tt>error_code</tt> and <tt>error_condition</tt> have an <tt>operator&lt;</tt> overload, 
enabling their use in associative containers without having to write a custom comparator. 
</p>
<p>
However, only <tt>error_code</tt> has a <tt>std::hash</tt>
specialization. So it's possible to have a
<tt>set&lt;error_code&gt;</tt>, a <tt>set&lt;error_condition&gt;</tt>,
an <tt>unordered_set&lt;error_code&gt;</tt>, but not an
<tt>unordered_set&lt;error_condition&gt;</tt>. This seems...odd.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Edit 19.5.1 [system_error.syn], header <tt>&lt;system_error&gt;</tt> synopsis, as indicated: </p>

<blockquote><pre>
namespace std {
    // ...

    // 19.5.6 Hash support
    template&lt;class T&gt; struct hash;
    template&lt;&gt; struct hash&lt;error_code&gt;;
    <ins>template&lt;&gt; struct hash&lt;error_condition&gt;;</ins>

   // ...
}
</pre></blockquote>
</li>
<li> <p> Edit 19.5.6 [syserr.hash] as indicated: </p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;error_code&gt;;
<ins>template &lt;&gt; struct hash&lt;error_condition&gt;;</ins>
</pre>

<blockquote>
<p>-1- The template specialization<ins>s</ins> shall meet the requirements of class template <tt>hash</tt> (20.12.14).</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2691" href="#2691">2691.</a> <tt>money_base::space</tt> and <tt>do_put</tt>: U+0020 versus <tt>fill</tt></h3>
<p><b>Section:</b> 22.4.6.3 [locale.moneypunct] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-12 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.moneypunct">issues</a> in [locale.moneypunct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of <tt>money_base::space</tt> is that "at least one space is required at that position." 
(N4582 subclause 22.4.6.3 [locale.moneypunct] paragraph 2)
<p/>
When formatting for output (22.4.6.2.2 [locale.money.put.virtuals]), it is not clear that
</p>
<ol style="list-style-type:lower-alpha">
<li><p>
"the number of characters generated for the specified format" (excluding fill padding) includes exactly 
one character for <tt>money_base::space</tt> (if present), and
</p></li>
<li><p>
all characters corresponding to <tt>money_base::space</tt> (excluding fill padding) are copies of <tt>fill</tt>.
</p></li>
</ol>
<p>
In particular, there is implementation divergence over point (b) as to whether U+0020 or <tt>fill</tt> should be used.
Further, should a character other than <tt>fill</tt> be used, it is unclear when "the fill characters are 
placed where <tt>none</tt> or <tt>space</tt> appears in the formatting pattern", whether the fill characters are placed 
at the beginning or the end of the "space field".
<p/>
I believe that a strict interpretation of the current wording supports U+0020; however, <tt>fill</tt> is more likely 
to be the pragmatic choice.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 22.4.6.3 [locale.moneypunct] paragraph 2 as indicated:</p>

<blockquote>
<p>
-2- Where <tt>none</tt> or <tt>space</tt> appears, white space is permitted in the format, except where <tt>none</tt> 
appears at the end, in which case no white space is permitted. <ins>For input, the value <tt>space</tt> indicates that 
at least one space is required at that position. For output, the value <tt>space</tt> indicates one instance of the 
fill character (22.4.6.2.2 [locale.money.put.virtuals]).</ins><del>The value <tt>space</tt> indicates that at least one 
space is required at that position</del>. Where <tt>symbol</tt> appears, the sequence of characters returned by 
<tt>curr_symbol()</tt> is permitted, and can be required. Where <tt>sign</tt> appears, the first (if any) of the 
sequence of characters returned by <tt>positive_sign()</tt> or <tt>negative_sign()</tt> (respectively as the monetary 
value is non-negative or negative) is required. Any remaining characters of the sign sequence are required after all 
other format components. Where <tt>value</tt> appears, the absolute numeric monetary value is required.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2693" href="#2693">2693.</a> <tt>constexpr</tt> for various <tt>std::complex</tt> arithmetic and value operators</h3>
<p><b>Section:</b> 26.5 [complex.numbers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Oliver Rosten <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This modification will allow complex-number arithmetic to be performed at compile time. From a mathematical 
standpoint, it is natural (and desirable) to treat complex numbers on the same footing as the reals. 
From a programming perspective, this change will broaden the scope in which <tt>std::complex</tt> can be used, 
allowing it to be smoothly incorporated into classes exploiting <tt>constexpr</tt>.
<p/>
Suggested resolution:
<p/>
The following functions in the <tt>std::complex</tt> namespace should be made <tt>constexpr</tt>:
</p>
<ol>
<li><p>
Section 26.5.5 [complex.member.ops]: The member (arithmetic) operators 
{<tt>+=</tt>, <tt>-=</tt>, <tt>/=</tt>, <tt>*=</tt>}
</p></li>
<li><p>
Section 26.5.6 [complex.ops]: The arithmetic operators unary operators {<tt>+</tt>, <tt>-</tt>} 
and binary operators {<tt>+</tt>, <tt>-</tt>, <tt>/</tt>, <tt>*</tt>};
</p></li>
<li><p>
Section 26.5.7 [complex.value.ops]: The 'value' operators <tt>abs</tt>, <tt>norm</tt>, and <tt>conj</tt>.
</p></li>
</ol>
<p>
In terms of modification of the standard, all that is required is the insertion of the <tt>constexpr</tt> specifier 
in the relevant parts of:
</p>
<ol>
<li><p>
Section 26.5.1 [complex.syn] (the Header synopsis), together with the corresponding entries in sections 
26.5.6 [complex.ops] and 26.5.7 [complex.value.ops].
</p></li>
<li><p>
Sections 26.5.2 [complex], 26.5.3 [complex.special] (class template and specializations), together 
with the corresponding entries in section 26.5.5 [complex.member.ops].
</p></li>
</ol>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This kind of work (new feature) has been being done via papers rather than via the issues list.
</p>
<p>
Walter believes that he knows someone who would be willing to write such a paper.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2694" href="#2694">2694.</a> Application of LWG 436 accidentally deleted definition of "facet"</h3>
<p><b>Section:</b> 22.3.1.1.2 [locale.facet] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.facet">issues</a> in [locale.facet].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[locale.facet]/1 (then-called [lib.locale.facet]) read in C++03:
</p>
<blockquote>
<p>
Class <tt>facet</tt> is the base class for locale feature sets. A class is a <i>facet</i> if it is publicly derived 
from another facet, or if it is a class derived from <tt>locale::facet</tt> and containing a publicly-accessible 
declaration as follows: [<i>Footnote</i>: This is a complete list of requirements; there are no other requirements. 
Thus, a facet class need not have a public copy constructor, assignment, default constructor, destructor, etc.]
</p>
<blockquote><pre>
static ::std::locale::id id;
</pre></blockquote>
<p>
Template parameters in this clause which are required to be facets are those named <tt>Facet</tt> in declarations. 
A program that passes a type that is <em>not</em> a facet, as an (explicit or deduced) template parameter to a locale 
function expecting a facet, is ill-formed.
</p>
</blockquote>
<p>
LWG <a href="lwg-defects.html#436">436</a>'s intent appears to be to ban <tt>volatile</tt>-qualified facets and permitting 
<tt>const</tt>-qualified ones. The PR was somewhat poorly worded, however, and the editor in applying 
it deleted the whole first half of the paragraph, including the definition of <i>facet</i> and the requirement 
for a static data member named <tt>id</tt>.
<p/>
As a result, we have things like 22.3.1.1.3 [locale.id]/2 and 22.3.2 [locale.global.templates]/1 referring 
to the <tt>id</tt> member that's not defined anywhere in the working draft.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Insert the following paragraph before 22.3.1.1.2 [locale.facet]/1:</p>

<blockquote>
<p>
<ins>-?- Class <tt>facet</tt> is the base class for locale feature sets. A class is a <i>facet</i> if it is publicly 
derived from another facet, or if it is a class derived from <tt>locale::facet</tt> and containing a publicly accessible 
declaration as follows: [<i>Footnote</i>: This is a complete list of requirements; there are no other requirements. Thus, a 
facet class need not have a public copy constructor, assignment, default constructor, destructor, etc.]</ins>
</p>
<blockquote><pre>
<ins>static ::std::locale::id id;</ins>
</pre></blockquote>
<p>
-1- Template parameters in this Clause which are required to be facets are those named <tt>Facet</tt> in declarations. A
program that passes a type that is <i>not</i> a facet, or a type that refers to a volatile-qualified facet, as an (explicit
or deduced) template parameter to a locale function expecting a facet, is ill-formed. A const-qualified facet is
a valid template argument to any locale function that expects a Facet template parameter.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2695" href="#2695">2695.</a> "As if" unclear in [member.functions]</h3>
<p><b>Section:</b> 17.6.5.5 [member.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in [member.functions].</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4582 subclause 17.6.5.5 [member.functions], the requirement that:
</p>
<blockquote><p>
any call to the member function that would select an overload from the set of declarations described in this 
standard behaves as if that overload were selected
</p></blockquote>
<p>
is unclear in the extent of the "as if". For example, in providing:
</p>
<blockquote><pre>
basic_string(const charT* s);
</pre></blockquote>
<p>
for a one-argument call to:
</p>
<blockquote><pre>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
it can be read that an implementation may be required to call the copy constructor for the allocator since 
the core language rules for copy elision would not allow the "a" argument to be constructed directly into 
the member used to store the allocator.
<p/>
Clarification (even if just a note) would be appreciated.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to issue <a href="lwg-active.html#2563">2563</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2697" href="#2697">2697.</a> [concurr.ts] Behavior of <tt>future/shared_future</tt> unwrapping constructor when given an invalid <tt>future</tt></h3>
<p><b>Section:</b> 99 [concurr.ts::futures.unique_future], 99 [concurr.ts::futures.shared_future] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-04-22 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concurr.ts::futures.unique_future">active issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#concurr.ts::futures.unique_future">issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: concurr.ts</b></p>

<p>
In the concurrency TS, the future/shared_future unwrapping constructors
</p>
<blockquote><pre>
future(future&lt;future&lt;R&gt;&gt;&amp;&amp;) noexcept;
shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre></blockquote>
<p>
appear to implicitly require <tt>rhs</tt> be valid (e.g., by referring to its shared state, and by requiring a 
<tt>valid() == true</tt> postcondition). However, they are also marked <tt>noexcept</tt>, suggesting that they 
are wide-contract, and also makes the usual suggested handling for invalid futures, throwing a 
<tt>future_error</tt>, impossible.
<p/>
Either the <tt>noexcept</tt> should be removed, or the behavior with an invalid future should be specified.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4577.pdf">N4577</a>.
</p>
<ol style="list-style-type:upper-alpha">
<li><p><b>Alternative 1:</b></p>
<p>Strike the <tt>noexcept</tt> on these constructors in 99 [futures.unique_future]/1-2 and 
99 [futures.shared_future]/1-2, and optionally add a <i>Requires</i>: <tt>rhs.valid() == true</tt> 
paragraph.</p>
</li>

<li><p><b>Alternative 2:</b></p>
<p>
Specify that an empty (<tt>shared_</tt>)<tt>future</tt> object is constructed if <tt>rhs</tt> is invalid, and adjust 
the postcondition accordingly.
</p>
<ol>
<li><p>Edit 99 [futures.unique_future] as indicated:</p>

<blockquote><pre>
future(future&lt;future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>If <tt>rhs.valid() == false</tt>, constructs an empty <tt>future</tt> object that does not 
refer to a shared state. Otherwise, c</ins><del>C</del>onstructs a <tt>future</tt> object from the shared state 
referred to by <tt>rhs</tt>. The <tt>future</tt> becomes ready when one of the following occurs:
</p>
<ul>
<li><p>Both the <tt>rhs</tt> and <tt>rhs.get()</tt> are ready. The value or the exception from
<tt>rhs.get()</tt> is stored in the <tt>future</tt>'s shared state.</p></li>
<li><p><tt>rhs</tt> is ready but <tt>rhs.get()</tt> is invalid. An exception of type
<tt>std::future_error</tt>, with an error condition of <tt>std::future_errc::broken_promise</tt>
is stored in the <tt>future</tt>'s shared state.</p></li>
</ul>
<p>
-4- <i>Postconditions</i>:
</p>
<ul>
<li><p><del><tt>valid() == true</tt></del><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> prior to 
the constructor invocation.</ins>.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>

<li><p>Edit 99 [futures.shared_future] as indicated:</p>

<blockquote><pre>
shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>If <tt>rhs.valid() == false</tt>, constructs an empty <tt>shared_future</tt> object that does not 
refer to a shared state. Otherwise, c</ins><del>C</del>onstructs a <tt>shared_future</tt> object from the shared state 
referred to by <tt>rhs</tt>. The <tt>shared_future</tt> becomes ready when one of the following occurs:
</p>
<ul>
<li><p>Both the <tt>rhs</tt> and <tt>rhs.get()</tt> are ready. The value or the exception from
<tt>rhs.get()</tt> is stored in the <tt>shared_future</tt>'s shared state.</p></li>
<li><p><tt>rhs</tt> is ready but <tt>rhs.get()</tt> is invalid. The <tt>shared_future</tt>
stores an exception of type <tt>std::future_error</tt>, with an error condition of
<tt>std::future_errc::broken_promise</tt>.</p></li>
</ul>
<p>
-4- <i>Postconditions</i>:
</p>
<ul>
<li><p><del><tt>valid() == true</tt></del><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> prior to 
the constructor invocation.</ins>.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>

</li>
</ol>





<hr>
<h3><a name="2699" href="#2699">2699.</a> Missing restriction in [numeric.requirements]</h3>
<p><b>Section:</b> 26.3 [numeric.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-03 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4582 subclause 26.3 [numeric.requirements], the "considerable flexibility in how arrays are initialized" 
do not appear to allow for replacement of calls to the default constructor with calls to the copy constructor with 
an appropriate source value.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Adjust 26.3 [numeric.requirements]/1 as indicated:</p>

<blockquote>
<p>
-1- The <tt>complex</tt> and <tt>valarray</tt> components are parameterized by the type of information they contain and
manipulate. [&hellip;]
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <tt>T</tt> is not an abstract class (it has no pure virtual member functions);</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(1.8) &mdash; If <tt>T</tt> is a class, its assignment operator, copy and default constructors, and 
destructor shall correspond to each other in the following sense: <ins>Initialization of raw storage using 
the copy constructor on the value of <tt>T()</tt>, however obtained, is semantically equivalent to value 
initialization of the same raw storage.</ins> Initialization of raw storage using the 
default constructor, followed by assignment, is semantically equivalent to initialization of raw storage 
using the copy constructor. Destruction of an object, followed by initialization of its raw storage using 
the copy constructor, is semantically equivalent to assignment to the original object.
[<i>Note</i>: This rule states<ins>, in part,</ins> that there shall not be any subtle differences in the 
semantics of initialization versus assignment. This gives an implementation considerable flexibility in how 
arrays are initialized.
[<i>Example</i>: An implementation is allowed to initialize a <tt>valarray</tt> by allocating storage using the 
<tt>new</tt> operator (which implies a call to the default constructor for each element) and then assigning each
element its value. Or the implementation can allocate raw storage and use the copy constructor to
initialize each element. &mdash; <i>end example</i>]
If the distinction between initialization and assignment is important for a class, or if it fails to satisfy any
of the other conditions listed above, the programmer should use <tt>vector</tt> (23.3.11) instead of <tt>valarray</tt>
for that class; &mdash; <i>end note</i>]</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2701" href="#2701">2701.</a> Unclear requirement in [memory.resource.private]</h3>
<p><b>Section:</b> 20.12.2.2 [memory.resource.private] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-05-04 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.12.2.2 [memory.resource.private] says:
</p>
<blockquote><pre>
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: Alignment shall be a power of two.
</p>
</blockquote>
</blockquote>
<p>
Is that supposed to be a requirement on the alignment specified by the
<tt>alignment</tt> parameter? If so the word "Alignment" should not be
capitalized and in text font.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
The resolution should reference [basic.align].  Jonathan to update the wording.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify 20.12.2.2 [memory.resource.private] paragraph 1 as shown:</p>

<blockquote><pre>
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: <del>Alignment</del><ins>The alignment specified by
<code>alignment</code></ins> shall be a power of two.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2702" href="#2702">2702.</a> <tt>num_put::do_put(..., bool)</tt> performs ill-formed <tt>do_put</tt> call</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The call to <tt>do_put(out, str, fill, (int)val)</tt> in N4582 subclause 22.4.2.2.2 [facet.num.put.virtuals] 
paragraph 6 cannot select a best viable function in overload resolution given the overloads listed for 
<tt>do_put</tt> in 22.4.2.2 [locale.nm.put].
<p/>
There is implementation divergence:
</p>
<ul>
<li><p>Some implementations call the <tt>long</tt> overload (as overriden);</p></li>
<li><p>some implementations call the <tt>unsigned long</tt> overload (as overriden);</p></li>
<li><p>some implementations call something else.</p></li>
</ul>
<p>
It appears that the resolution to DR <a href="lwg-defects.html#359">359</a> attempted a fix; however, the relevant portion of the 
change was not applied to the WP.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2703" href="#2703">2703.</a> No provision for fill-padding when <tt>boolalpha</tt> is set</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4582 subclause 22.4.2.2.2 [facet.num.put.virtuals] paragraph 6 makes no provision for fill-padding in its 
specification of the behaviour when <tt>(str.flags() &amp; ios_base::boolalpha) != 0</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2705" href="#2705">2705.</a> Questionable precondition on Sequence containers <tt>a.assign(n, t)</tt></h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-05-08 <b>Last modified:</b> 2016-05-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Please look through the following modifications on a value <tt>v</tt> of type <tt>vector&lt;T&gt;</tt>:
</p>
<blockquote><pre>
assert(v.size() &gt; 0);
v.push_back(v[0]);
v.insert(v.begin(), v[0]);
v.resize(v.size() * 2, v[0]);
v.assign(v.size() * 2, v[0]);
</pre></blockquote>
<p>
All of these use an element of itself which may be moved or destroyed by
the modification.
<p/>
From what I see so far, the first three are required to work. Please
see library issue <a href="lwg-closed.html#526">526</a> for validity of them.
<p/>
But only the last one is undefined because it violates a precondition of
a sequence container operation. I think this is too subtle.
<p/>
Should it be like that, really?
<p/>
The precondition is in Table 107 "Sequence container requirements" at the next 
of 23.2.3 [sequence.reqmts] p3.
</p>
<blockquote>
<p>
In Tables 107 and 108, <tt>X</tt> denotes a sequence container class,
<tt>a</tt> denotes a value of <tt>X</tt> containing elements of type <tt>T</tt>,
[&hellip;] <tt>n</tt> denotes a value of <tt>X::size_type</tt>,
[&hellip;] <tt>t</tt> denotes an lvalue or a <tt>const</tt> rvalue of <tt>X::value_type</tt>,
[&hellip;]
</p>
<p>[&hellip;]</p>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
pre: <tt>t</tt> is not a reference into <tt>a</tt>.<br/>
Replaces elements in <tt>a</tt> with <tt>n</tt> copies of <tt>t</tt>.
</td>
</tr>
</table>
</blockquote>
<p>
I looked into the following implementations:
</p>
<ul>
<li><p>
libc++ relies on the precondition.
<p/>
It deallocates first on <tt>n &gt; capacity()</tt> case,
see <a href="https://github.com/llvm-mirror/libcxx/blob/release_38/include/vector#L1415">here</a>.
</p></li>
<li><p>
libstdc++ doesn't rely on the precondition.
<p/>
It creates temporary <tt>vector(n, t)</tt> and <tt>swap()</tt>
on <tt>n &gt; capacity()</tt> case, see
<a href="https://github.com/gcc-mirror/gcc/blob/gcc_5_3_0_release/libstdc%2B%2B-v3/include/bits/vector.tcc#L223">here</a>.
</p></li>
<li><p>
MSVC relies on the precondition.
<p/>
It unconditionally does <tt>clear()</tt> and then <tt>insert(begin(), n, t)</tt>.
I looked into my local "%PROGRAMFILES(X86)%/Microsoft Visual Studio 14.0/VC/include/vector".
</p></li>
</ul>
<p>
One drawback of libstdc++ implementation, I could find so far, is
possibly increased peek memory usage (both old and new buffer exist at
the same time). But, because the same can happen on the most other
modifications, it seems a reasonable trade-off to remove the
precondition to fill the subtle gap. Users who really needs less memory
usage can do <tt>clear()</tt> and <tt>insert()</tt> by themselves.
<p/>
I also found that <tt>basic_string::assign(n, c)</tt> is safe on this point.
At 21.3.1.6.3 [string::assign] p17:
</p>
<blockquote>
<pre>
basic_string&amp; assign(size_type n, charT c);
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to <tt>assign(basic_string(n, c))</tt>.
<p/>
<i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
<p>
This can be seen as another gap.
<p/>
Looking back on the history, I found that the definition of <tt>assign(n, t)</tt>
was changed at C++14 for library issue <a href="lwg-defects.html#2209">2209</a>. There were more restricting 
definitions like this:
</p>
<blockquote>
<pre>
void assign(size_type n, const T&amp; t);
</pre>
<blockquote>
<p>
<i>Effects</i>:
</p>
<blockquote><pre>
erase(begin(), end());
insert(begin(), n, t);
</pre></blockquote>
</blockquote>
</blockquote>
<p>
I think the precondition was probably set to accept this old definition
and is not required inherently. And if the less memory usage was really
intended, the standard is now underspecifying about that.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Howard believes this should be NAD, but we tabled the discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>In 23.2.3 [sequence.reqmts], edit Table 107 (Sequence container requirements) as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
<del>pre: <tt>t</tt> is not a reference into <tt>a</tt>.</del><br/> 
Replaces elements in <tt>a</tt> with <tt>n</tt> copies of <tt>t</tt>.
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2708" href="#2708">2708.</a> <tt>recursive_directory_iterator::recursion_pending()</tt> is incorrectly specified</h3>
<p><b>Section:</b> 27.10.14.1 [rec.dir.itr.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-09 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rec.dir.itr.members">issues</a> in [rec.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>recursion_pending()</tt> says (27.10.14.1 [rec.dir.itr.members]/24):
</p>
<blockquote><p>
<i>Returns</i>: <tt>true</tt> if <tt>disable_recursion_pending()</tt> has not been called subsequent to the prior construction 
or increment operation, otherwise <tt>false</tt>.
</p></blockquote>
<p>
This language does not take into account cases where the prior construction was a copy construction from a iterator, 
<tt>it</tt>, where <tt>it.recursion_pending() == false</tt>. 
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Wed AM: Move to Open</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 27.10.14.1 [rec.dir.itr.members] as indicated:</p>

<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Postcondition</i>: <del><tt>options() == options</tt> for the signatures with a <tt>directory_options</tt> argument, 
otherwise <tt>options() == directory_options::none</tt>.</del>
</p>
<ul>
<li><p><ins><tt>options() == options</tt> for the signatures with a <tt>directory_options</tt> argument, otherwise 
<tt>options() == directory_options::none</tt>.</ins></p></li>
<li><p><ins><tt>recursion_pending() == true</tt>.</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The following changes the specification of <tt>recursion_pending()</tt> seemingly recursive. 
Perhaps it would be easier to specify <tt>recursion_pending()</tt> in terms of a exposition only member in 
<tt>recursive_directory_iterator</tt>.]
</p>
</blockquote>
<pre>
bool recursion_pending() const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Returns</i>: <del><tt>true</tt> if <tt>disable_recursion_pending()</tt> has not been called subsequent to the 
prior construction or increment operation, otherwise <tt>false</tt></del><ins><tt>false</tt> if 
<tt>disable_recursion_pending()</tt> has been called subsequent to the prior construction or increment operation, 
otherwise the value of <tt>recursion_pending()</tt> set by that operation</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-27- <i>Effects</i>: As specified by Input iterators (24.2.3), except that: [&hellip;]
<p/>
<ins>-?- <i>Postcondition</i>: <tt>recursion_pending() == true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2713" href="#2713">2713.</a> More missing allocator-extended constructors for unordered containers</h3>
<p><b>Section:</b> 23.5 [unord] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-20 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="lwg-defects.html#2210">2210</a> missed constructors accepting a range or initializer list and allocator.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Add to the synopsis in 23.5.4.1 [unord.map.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_map(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_map(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.5.1 [unord.multimap.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multimap(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multimap(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.6.1 [unord.set.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_set(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_set(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.7.1 [unord.multiset.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multiset(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multiset(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-06, Oulu &mdash; Daniel comments and provides new wording]</i></p>

<p>
During the LWG discussion of this issue it has been observed, that the interpretation of the embedded <i>see below</i>
is not really clear and that we should split declaration and definition of the new overloads, so that we have a place
that allows us to specify what "<i>see below</i>" stands for. In addition, the new wording wraps the "<i>see below</i>"
as "<tt>size_type(<i>see below</i>)</tt>" to clarify the provided expression type, similar as we did for the default
constructor of <tt>unordered_map</tt>.
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>Alisdair to review wording.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Add to the synopsis in 23.5.4.1 [unord.map.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.4.2 [unord.map.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.5.1 [unord.multimap.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.5.2 [unord.multimap.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.6.1 [unord.set.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.6.2 [unord.set.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.7.1 [unord.multiset.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.7.2 [unord.multiset.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2714" href="#2714">2714.</a> <tt>complex</tt> stream extraction underspecified</h3>
<p><b>Section:</b> 26.5.6 [complex.ops] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-05-23 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>operator&gt;&gt;(istream&amp;, complex&lt;T&gt;&amp;)</tt> is extremely short on details. 
It currently reads, in its entirety (26.5.6 [complex.ops]/12-15):
</p>
<blockquote class="note">
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp; operator>>(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<i>Effects:</i> Extracts a complex number <tt>x</tt> of the form: <tt>u</tt>, <tt>(u)</tt>, or <tt>(u,v)</tt>, 
where <tt>u</tt> is the real part and <tt>v</tt> is the imaginary part (27.7.2.2 [istream.formatted]).
<p/>
<i>Requires:</i> The input values shall be convertible to <tt>T</tt>.
<p/>
If bad input is encountered, calls <tt>is.setstate(ios_base::failbit)</tt> (which may throw <tt>ios::failure</tt> 
(27.5.5.4 [iostate.flags])).
<p/>
<i>Returns:</i> <tt>is</tt>.
<p/>
<i>Remarks:</i> This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace 
is specified to be the same for each of the simpler extractions.
</p>
</blockquote>
</blockquote>
<p>
It is completely unclear:
</p>
<ul>
<li>which "simpler extractions" are performed,</li>
<li>how the extracted characters are matched to the special characters <tt>'('</tt>, <tt>')'</tt> and <tt>','</tt> 
(by <tt>==</tt>, or by <tt>traits::eq</tt>),</li>
<li>what is left in the stream on failure. (For example, with <tt>"(0, 0]"</tt>, libstdc++ extracts the <tt>]</tt> 
while libc++ leaves it in the stream.)</li>
</ul>


<p><b>Proposed resolution:</b></p>
<blockquote class="note">
<i>Drafting note:</i> the following wording is based on:
<ul>
<li> Characters are extracted using <tt>operator&gt;&gt;</tt> and compared using <tt>traits::eq</tt>.</li>
<li> Mismatched characters are returned to the stream. </li>
</ul>
</blockquote>
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Replace 26.5.6 [complex.ops]/12-15 with the following paragraphs:</p>

<blockquote>
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator>>(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-?- <i>Effects:</i> First, extracts a character from <tt>is</tt>.
<ul>
<li>If the character extracted is equal to <tt>is.widen('(')</tt>, extracts an object <tt>u</tt> of type <tt>T</tt> from <tt>is</tt>, then extracts a character from <tt>is</tt>.
<ul>
    <li>
    If this character is equal to <tt>is.widen(')')</tt>, then assigns <tt>complex&lt;T&gt;(u)</tt> to <tt>x</tt>.
    </li>
    <li>
      Otherwise, if this character is equal to <tt>is.widen(',')</tt>, extracts an object <tt>v</tt> of type <tt>T</tt> from <tt>is</tt>,
      then extracts a character from <tt>is</tt>.
      If this character is equal to <tt>is.widen(')')</tt>, then assigns <tt>complex&lt;T&gt;(u, v)</tt> to <tt>x</tt>;
      otherwise returns the character to <tt>is</tt> and the extraction fails.
    </li>
    <li>
      Otherwise, returns the character to <tt>is</tt> and the extraction fails.
    </li>
  </ul>
</li>
<li> Otherwise, returns the character to <tt>is</tt>, extracts an object <tt>u</tt> of type <tt>T</tt> from <tt>is</tt>, and assigns <tt>complex&lt;T&gt;(u)</tt> to <tt>x</tt>.
</li>
</ul>
In the description above, characters are extracted from <tt>is</tt> as if by <tt>operator&gt;&gt;</tt> (27.7.2.2.3 [istream::extractors]), and returned
to the stream as if by <tt>basic_istream::putback</tt> (27.7.2.3 [istream.unformatted]). Character equality is determined using <tt>traits::eq</tt>.
An object <tt>t</tt> of type <tt>T</tt> is extracted from <tt>is</tt> as if by <tt> is &gt;&gt; t</tt>.
<p/>
If any extraction operation fails, no further operation is performed and the whole extraction fails.
<p/>
On failure, calls <tt>is.setstate(ios_base::failbit)</tt> (which may throw <tt>ios::failure</tt>
(27.5.5.4 [iostate.flags])).
<p/>
-?- <i>Returns:</i> <tt>is</tt>.
<p/>
-?- [<i>Note</i>: This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace
is specified to be the same for each of the simpler extractions. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2715" href="#2715">2715.</a> What is 'aggregate initialization syntax'?</h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.generic">active issues</a> in [atomics.types.generic].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.5 [atomics.types.generic] mentions 'aggregate initialization syntax'. It's unclear what it stands for, 
especially since atomic types are actually not aggregate types (they have user-provided constructors).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2729" href="#2729">2729.</a> Missing SFINAE on <tt>std::pair::operator=</tt></h3>
<p><b>Section:</b> 20.4.2 [pairs.pair], 20.5.2.2 [tuple.assign] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-07 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::is_copy_assignable&lt;std::pair&lt;int, std::unique_ptr&lt;int&gt;&gt;&gt;::value</tt> is <tt>true</tt>, and 
should be <tt>false</tt>. We're missing a "shall not participate in overload resolution unless" for <tt>pair</tt>'s 
<tt>operator=</tt>, and likewise for <tt>tuple</tt>.
</p>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Inspired by Eric Fiselier and Ville, Walter and Nevin provide initial Proposed Resolution.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.4.2 [pairs.pair] as indicated:</p>

<blockquote>
<pre>
pair&amp; operator=(const pair&amp; p);
</pre>
<blockquote>
<p>
-15- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_copy_assignable_v&lt;first_type&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;second_type&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
</pre>
<blockquote>
<p>
-18- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;first_type&amp;, const U&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;second_type&amp;, const V&amp;&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
pair&amp; operator=(pair&amp;&amp; p) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-21- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T1&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;T2&gt;
</pre></blockquote>
<p>
-22- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_move_assignable_v&lt;first_type&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;second_type&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);
</pre>
<blockquote>
<p>
-25- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;first_type&amp;, U&amp;&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;second_type&amp;, V&amp;&amp;&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.5.2.2 [tuple.assign] as indicated:</p>

<blockquote>
<pre>
tuple&amp; operator=(const tuple&amp; u);
</pre>
<blockquote>
<p>
-2- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_copy_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
tuple&amp; operator=(tuple&amp;&amp; u) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-5- <i>Remark:</i> The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;
</pre></blockquote>
<p>
where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i<sup>th</sup></i></tt> type in <tt>Types</tt>.
<p/>
-6- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins>
<tt>is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-9- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == sizeof...(UTypes)</tt> and 
<tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, const U<sub><i>i</i></sub>&amp;&gt;</tt> is <tt>true</tt> 
for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-12- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, U<sub><i>i</i></sub>&amp;&amp;&gt; == true</tt> 
for all <tt><i>i</i></tt><del>.</del> <ins>and</ins> <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp; u);
</pre>
<blockquote>
<p>
-15- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == 2</tt><del>.</del> <ins>and</ins> <tt>is_assignable_v&lt;T<sub><i>0</i></sub>&amp;, 
const U<sub><i>1</i></sub>&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T<sub><i>0</i></sub></tt> in 
<tt>Types</tt> and <tt>is_assignable_v&lt;T<sub><i>1</i></sub>&amp;, const U<sub><i>2</i></sub>&amp;&gt;</tt> 
is <tt>true</tt> for the second type <tt>T<sub><i>1</i></sub></tt> in <tt>Types</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-18- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == 2</tt><del>.</del> <ins>and</ins> <tt>is_assignable_v&lt;T<sub><i>0</i></sub>&amp;, 
U<sub><i>1</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T<sub><i>0</i></sub></tt> in 
<tt>Types</tt> and <tt>is_assignable_v&lt;T<sub><i>1</i></sub>&amp;, U<sub><i>2</i></sub>&amp;&amp;&gt;</tt> 
is <tt>true</tt> for the second type <tt>T<sub><i>1</i></sub></tt> in <tt>Types</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2730" href="#2730">2730.</a> <tt>numeric_limits</tt> primary template definition</h3>
<p><b>Section:</b> 18.3.2.1 [limits.numeric] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-09 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've received this report at the <a href="mailto:cxxeditor@gmail.com">project editor mail alias</a>, and it seems like it may be worthy of a LWG issue:
</p>
<blockquote class="note">
<p>
I recently had this problem: 
</p>
<ul>
<li>I was storing data in a vector of <tt>__uint128_t</tt>s</li>
<li>I used a sorting library which used <tt>numeric_limits&lt;T&gt;::max()</tt> as a sentinel value</li>
<li>GCC's libstdc++ provides a <tt>numeric_limits</tt> specialisation for that type, but</li>
<li>Clang's libc++ does not.</li>
</ul>
<p>
This broke the sorting for me on different platforms, and it was quite difficult to determine why. If the default 
<tt>numeric_limits</tt> didn't default to <tt>0</tt>s and <tt>false</tt> values (18.3.2.4 of N4582), and instead 
<tt>static_assert</tt>ed, causing my code to not compile, I would have found the solution immediately.
<p/>
I know that <tt>__uint128_t</tt> is non-standard, so neither GCC nor Clang is doing the wrong thing nor the right thing 
here. I could just submit a patch to libc++ providing the specialisations, but it doesn't fix the problem at its core.
<p/>
I am wondering, what is the rationale behind the defaults being <tt>0</tt> and <tt>false</tt>? It seems like it is 
inviting a problem for any future numeric types, whether part of a library, compiler extension, and possibly even 
future updates to C++'s numeric types. I think it would be much better to prevent code that tries to use 
unspecified <tt>numeric_limits</tt> from compiling.
</p>
</blockquote>
<p>
An alternative to this suggestion would be to still define the primary template, but not provide any of the members 
except <tt>is_specialized</tt>. Either way, this would make <tt>numeric_limits</tt> members SFINAEable.
<p/>
Along the same lines, one might wonder why the members that only make sense for floating-point types are required to 
be defined to nonsense values for integer types.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2731" href="#2731">2731.</a> Existence of <tt>lock_guard&lt;MutexTypes...&gt;::mutex_type</tt> typedef unclear</h3>
<p><b>Section:</b> 30.4.2.1 [thread.lock.guard] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-06-13 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.guard">issues</a> in [thread.lock.guard].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis of 30.4.2.1 [thread.lock.guard] the <tt>mutex_type</tt> typedef is specified as follows:
</p>
<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// If</i> MutexTypes... <i>consists of the single type</i> Mutex
  [&hellip;]
};
</pre>
</blockquote>
<p>
The comment seems ambiguous as it could mean either:
</p>
<ol>
<li><tt>sizeof...(MutexTypes) == 1</tt>.</li>
<li><tt>sizeof...(MutexTypes) &gt;= 1</tt> and every type in <tt>MutexTypes...</tt> is the same type.</li>
</ol>
<p>
I originally took the language to mean (2), but upon further review it seems that (1) is the intended interpretation, 
as suggested in the LEWG discussion in <a href="http://wiki.edg.com/bin/view/Wg21lenexa/N4470">Lenexa</a>.
<p/>
I think the language should be clarified to prevent implementation divergence.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Edit 30.4.2.1 [thread.lock.guard]/1, class template <tt>lock_guard</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// <ins>Only i</ins><del>I</del>f</i> MutexTypes... <i><del>consists of the</del><ins>expands to a</ins> single type</i> <tt>Mutex</tt>
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2734" href="#2734">2734.</a> Questionable specification in [path.concat]</h3>
<p><b>Section:</b> 27.10.8.4.4 [path.concat] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-06-16 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.10.8.4.4 [path.concat] specifies that the postcondition for
</p>
<blockquote>
<pre>
path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(const value_type* x);
path&amp; operator+=(value_type x);
template&lt;class Source&gt;
path&amp; operator+=(const Source&amp; x);
template&lt;class EcharT&gt;
path&amp; operator+=(EcharT x);
template&lt;class Source&gt; 
path&amp; concat(const Source&amp; x); 
template&lt;class InputIterator>
path&amp; concat(InputIterator first, InputIterator last);
</pre>
</blockquote>
<p>
is
</p>
<blockquote>
<p>
<tt>native() == prior_native</tt> + <i>effective-argument</i>
</p>
</blockquote>
<p>
where <i>effective-argument</i> is
</p>
<ol>
<li>if <tt>x</tt> is present and is <tt>const path&amp;</tt>, <tt>x.native()</tt>; otherwise</li>
<li>if <tt>source</tt> is present, the effective range of <tt>source</tt> (27.10.8.3 [path.req]); otherwise,</li>
<li>if <tt>first</tt> and <tt>last</tt> are present, the range <tt>[first, last)</tt>; otherwise,</li>
<li><tt>x</tt></li>
</ol>
<p>
It also says that
</p>
<blockquote>
<p>
If the value type of <i>effective-argument</i> would not be <tt>path::value_type</tt>, the actual argument or 
argument range is first converted (27.10.8.2.2 [path.type.cvt]) so that <i>effective-argument</i> has value 
type <tt>path::value_type</tt>.
</p>
</blockquote>
<p>
There are several problems with this specification:
<p/>
First, there is no overload taking "<tt>source</tt>" (note the lower case); all single-argument overloads take 
"<tt>x</tt>". Second, there's nothing that defines what it means to use <tt>operator+</tt> on a string and an 
iterator range; clearly concatentation is intended but there is no wording to that effect.
Third, the final portion uses "value type", but the "value type" of a single character is not a defined concept.
<p/>
Also, the reference only to 27.10.8.2.2 [path.type.cvt] seems to imply that any format conversion specified in 
27.10.8.2.1 [path.fmt.cvt] will not be performed, in seeming contradiction to the rule that <tt>native()</tt> 
is to return the native pathname format (27.10.8.4.6 [path.native.obs]/1). Is that intended?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2735" href="#2735">2735.</a> <tt>std::abs(short)</tt>, <tt>std::abs(signed char)</tt> and others should return <tt>int</tt> instead of 
<tt>double</tt> in order to be compatible with C++98 and C</h3>
<p><b>Section:</b> 26.9 [c.math] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> J&ouml;rn Heusipp <b>Opened:</b> 2016-06-16 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider this C++98 program:
</p>
<blockquote>
<pre>
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

int main() {
  return std::abs(static_cast&lt;short&gt;(23)) % 42;
}
</pre>
</blockquote>
<p>
This works fine with C++98 compilers. At the <tt>std::abs(short)</tt> call, short gets promoted to <tt>int</tt> and 
<tt>std::abs(int)</tt> is called.
<p/>
C++11 added the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4594.pdf">following wording</a>
on page 1083 &sect;26.9 p15 b2 [c.math]:
</p>
<blockquote>
<p>
Otherwise, if any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>double</tt> 
or an integer type, then all arguments of arithmetic type corresponding to <tt>double</tt> parameters are effectively 
cast to <tt>double</tt>.
</p>
</blockquote>
<p>
C++17 draft <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4594.pdf">additionally adds</a> on
page 1080 &sect;26.9 p10 [c.math]:
</p>
<blockquote>
<p>
If <tt>abs()</tt> is called with an argument of type <tt>X</tt> for which <tt>is_unsigned&lt;X&gt;::value</tt> is <tt>true</tt> 
and if <tt>X</tt> cannot be converted to <tt>int</tt> by integral promotion (4.5), the program is ill-formed. [<i>Note:</i> 
Arguments that can be promoted to <tt>int</tt> are permitted for compatibility with C. &mdash; <i>end note</i>]
</p>
</blockquote>
<p>
It is somewhat confusing and probably even contradictory to on the one hand specify <tt>abs()</tt> in terms of integral 
promotion in &sect;26.9 p10 and on the other hand demand all integral types to be converted to <tt>double</tt> in 
&sect;26.9 p15 b2.
<p/>
Most compilers (each with their own respective library implementation) I tested (MSVC, Clang, older GCC) appear to not 
consider &sect;26.9 p15 b2 for <tt>std::abs</tt> and compile the code successfully. GCC 4.5-5.3 (for <tt>std::abs</tt> but 
not for <tt>::abs</tt>) as well as GCC &gt;=6.0 (for both <tt>std::abs</tt> and <tt>::abs</tt>) fail to compile in the following 
way: Taking &sect;26.9 p15 b2 literally and applying it to <tt>abs()</tt> (which is listed in &sect;26.9 p12) results in 
<tt>abs(short)</tt> returning <tt>double</tt>, and with <tt>operator%</tt> not being specified for <tt>double</tt>, this 
makes the programm ill-formed.
<p/>
I do acknowledge the reason for the wording and semantics demanded by &sect;26.9 p15 b2, i.e. being able to call math functions 
with integral types or with partly floating point types and partly integral types. Converting integral types to <tt>double</tt>
certainly makes sense here for all the other floating point math functions.
However, <tt>abs()</tt> is special. <tt>abs()</tt> has overloads for the 3 wider integral types which return integral types. 
<tt>abs()</tt> originates in the C standard in <tt>stdlib.h</tt> and had originally been specified for integral types only. 
Calling it in C with a short argument returns an <tt>int</tt>. Calling <tt>std::abs(short)</tt> in C++98 also returns an 
<tt>int</tt>. Calling <tt>std::abs(short)</tt> in C++11 and later with &sect;26.9 p15 b2 applied to <tt>abs()</tt> suddenly 
returns a <tt>double</tt>.
<p/>
Additionally, this behaviour also breaks third-party C headers which contain macros or inline functions calling 
<tt>abs(short)</tt>.
<p/>
As per discussion on std-discussion, my reading of the standard as well as GCC's interpretation seem valid.
However, as can be seen, this breaks existing code.
<p/>
In addition to the compatibilty concerns, having <tt>std::abs(short)</tt> return <tt>double</tt> is also very confusing 
and unintuitive.
<p/>
The other (possibly, depending on their respective size relative to <tt>int</tt>) affected types besides <tt>short</tt> 
are <tt>signed char</tt>, <tt>unsigned char</tt> and <tt>unsigned short</tt>, and also <tt>char</tt>, <tt>char16_t</tt>, 
<tt>char32_t</tt> and <tt>wchar_t</tt>, (all of these are or may be promotable to <tt>int</tt>). Wider integral types 
are not affected because explicit overloads are specified for those types by &sect;26.9 p6, &sect;26.9 p7 and &sect;26.9 p9.
<tt>div()</tt> is also not affected because it is neither listed in &sect;26.9 p12, nor does it actually provide 
any overload for <tt>double</tt> at all.
<p/>
As far as I can see, the proposed or implemented solutions for LWG <a href="lwg-active.html#2294">2294</a>, <a href="lwg-defects.html#2192">2192</a> and/or 
<a href="lwg-defects.html#2086">2086</a> do not resolve this issue.
<p/>
I think both, &sect;26.9 p10 [c.math] and &sect;26.9 p15 [c.math] need some correction and clarification.
<p/>
(Note: These changes would explicitly render the current implementation in GCC's libstdc++ non-conforming, which would 
be a good thing, as outlined above.)
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: This has been changed in N4606; the rest of the changes may be editorial.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Modify 26.9 [c.math] as indicated:</p>

<blockquote>
<p>
-10- If <tt>abs()</tt> is called with an argument of type <tt>X</tt> for which <tt>is_unsigned&lt;X&gt;::value</tt> is 
<tt>true</tt> and if <tt>X</tt> cannot be converted to <tt>int</tt> by integral promotion (4.5), the program is ill-formed.
<ins>If <tt>abs()</tt> is called with an argument of type <tt>X</tt> which can be converted to <tt>int</tt> by integral 
promotion (4.5), the argument is promoted to <tt>int</tt>.</ins> [<i>Note:</i> Arguments that can be promoted to <tt>int</tt> 
are <ins>promoted to <tt>int</tt> in order to keep</ins><del>permitted for</del> compatibility with C. &mdash; <i>end note</i>]
<p/>
[&hellip;]
<p/>
-15- Moreover, there shall be additional overloads <ins>for these functions, with the exception of <tt>abs()</tt>,</ins> 
sufficient to ensure:
</p>
<ol>
<li><p>If any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, then
all arguments of arithmetic type (3.9.1) corresponding to <tt>double</tt> parameters are effectively cast to
<tt>long double</tt>.</p></li>
<li><p>Otherwise, if any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>double</tt>
or an integer type, then all arguments of arithmetic type corresponding to <tt>double</tt> parameters are
effectively cast to <tt>double</tt>.</p></li>
<li><p>Otherwise, all arguments of arithmetic type corresponding to <tt>double</tt> parameters have type <tt>float</tt>.</p></li>
</ol>
<p>
See also: ISO C 7.5, 7.10.2, 7.10.6.
<p/>
<ins>[<i>Note:</i> <tt>abs()</tt> is exempted from these rules in order to stay compatible with C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2736" href="#2736">2736.</a> <tt>nullopt_t</tt> insufficiently constrained</h3>
<p><b>Section:</b> 20.6.4 [optional.nullopt] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-06-17 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.6.4 [optional.nullopt]/2 requires of <tt>nullopt_t</tt> that
</p>
<blockquote>
<p>
Type <tt>nullopt_t</tt> shall not have a default constructor. It shall be a literal type. Constant <tt>nullopt</tt> shall 
be initialized with an argument of literal type.
</p>
</blockquote>
<p>
This does not appear sufficient to foreclose the following implementation:
</p>
<blockquote>
<pre>
struct nullopt_t 
{
  constexpr nullopt_t(const nullopt_t&amp;) = default;
};

constexpr nullopt_t nullopt(nullopt_t{});
</pre>
</blockquote>
<ul>
<li><tt>nullopt_t</tt> has no default constructor because it has a user-declared (copy) constructor;</li>
<li><tt>nullopt_t</tt> has a trivial destructor, is an aggregate, and is a literal type;</li>
<li><tt>nullopt</tt> has been initialized with an argument of literal type, to wit, <tt>nullopt_t</tt>.</li>
</ul>
<p>
But such a <tt>nullopt_t</tt> is still constructible from <tt>{}</tt> and so still makes <tt>opt = {}</tt> ambiguous.
</p>

<p><i>[08-16 - Chicago]</i></p>

<p>This is related to <a href="lwg-active.html#2510">2510</a></p>
<p>Monday PM: Ville to provide updated wording</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Edit 20.6.4 [optional.nullopt]/2 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: <tt>{}</tt> can do one of three things for a class type:
it may be aggregate initialization, it may call a default constructor,
or it may call an initializer-list constructor (see 8.6.4 [dcl.init.list], 13.3.1.7 [over.match.list]).
The wording below forecloses all three possibilities. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<p>
-2- Type <tt>nullopt_t</tt> shall not have a default constructor <ins>or an initializer-list constructor</ins>. 
It <ins>shall not be an aggregate and</ins> shall be a literal type. Constant <tt>nullopt</tt> shall 
be initialized with an argument of literal type.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2737" href="#2737">2737.</a> Consider relaxing object size restrictions for single-object allocation functions</h3>
<p><b>Section:</b> 18.6.2.1 [new.delete.single] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2016-06-21 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It should be considered whether the description of the
single-object allocation functions should say "or smaller", like
the array allocation functions. For example, according to 18.6.2.1 [new.delete.single] p1 (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate <tt>size</tt> bytes of
storage suitably aligned to represent any object <em>of that size</em>.
</p>
</blockquote>
<p>
In contrast to this, 18.6.2.2 [new.delete.array] p1 says (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate
<tt>size</tt> bytes of storage suitably aligned to represent any array object <em>of that size or smaller</em>. 
(footnote: It is not the direct responsibility of <tt>operator new[](std::size_t)</tt> or <tt>operator delete[](void*)</tt> 
to note the repetition count or element size of the array. Those operations are performed elsewhere in the array 
<tt>new</tt> and <tt>delete</tt> expressions. The array <tt>new</tt> expression, may, however, increase the size 
argument to operator <tt>new[](std::size_t)</tt> to obtain space to store supplemental information.)
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2741" href="#2741">2741.</a> <tt>is_partitioned</tt> requirements need updating</h3>
<p><b>Section:</b> 25.4.14 [alg.partitions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-07-06 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.partitions">issues</a> in [alg.partitions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote class="note">
<p>
<i>Requires:</i> <tt>InputIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument type.
</p>
</blockquote>
<p>
This seems to date from the days of adaptable function objects with an <tt>argument_type</tt> typedef, but in 
modern C++ the predicate might not have an argument type. It could have a function template that accepts various 
arguments, so it doesn't make sense to state requirements in terms of a type that isn't well defined.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Edit 25.4.14 [alg.partitions] as indicated:</p>

<blockquote>
<pre>
template &lt;class InputIterator, class Predicate&gt;
bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <del><tt>InputIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument 
type</del><ins>The expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class InputIterator, class OutputIterator1,
          class OutputIterator2, class Predicate&gt;
  pair&lt;OutputIterator1, OutputIterator2&gt;
  partition_copy(InputIterator first, InputIterator last,
                 OutputIterator1 out_true, OutputIterator2 out_false,
                 Predicate pred);
</pre>
<blockquote>
<p>
-12- <i>Requires:</i> <tt>InputIterator</tt>'s value type shall be <tt>CopyAssignable</tt>, and shall be writable 
(24.2.1 [iterator.requirements.general]) to the <tt>out_true</tt> and <tt>out_false</tt> 
<tt>OutputIterator</tt>s, and <del>shall be convertible to <tt>Predicate</tt>'s argument type</del><ins>the
expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>. 
The input range shall not overlap with either of the output ranges.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ForwardIterator, class Predicate&gt;
  ForwardIterator partition_point(ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred);
</pre>
<blockquote>
<p>
-16- <i>Requires:</i> <del><tt>ForwardIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument 
type</del><ins>The expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>. 
<tt>[first, last)</tt> shall be partitioned by <tt>pred</tt>, i.e. all elements that satisfy <tt>pred</tt> shall appear 
before those that do not.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2742" href="#2742">2742.</a> Inconsistent <tt>string</tt> interface taking <tt>string_view</tt></h3>
<p><b>Section:</b> 21.3.1.2 [string.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-06 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Generally, <tt>basic_string</tt> has a constructor matching each <tt>assign</tt> function and vice versa (except the 
constructor takes an allocator where <tt>assign</tt> does not). <a href="http://wg21.link/p0254r2">P0254R2</a> violates 
this by adding an <tt>assign(basic_string_view, size_type pos, size_type n = npos)</tt> but no corresponding constructor.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2743" href="#2743">2743.</a> p0083r3 <tt>node_handle</tt> private members missing "exposition only" comment</h3>
<p><b>Section:</b> 23.1.1.1 [container.node.overview] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-08 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The private members of <tt>node_handle</tt> are missing the usual "exposition only" comment. As a consequence, 
<tt>ptr_</tt> and <tt>alloc_</tt> now appear to be names defined by the library (so programs defining these names 
as macros before including a library header have undefined behavior).
<p/>
Presumably this is unintentional and these members should be considered to be for exposition only.
<p/>
It's also not clear whether the name <tt>node_handle</tt> is reserved for library usage or not; 
23.1.1.1 [container.node.overview]/3 says the implementation need not provide a type with this name, but 
doesn't seem to rule out the possibility that an implementation will choose to do so regardless.
</p>
<p>
<b>Daniel:</b>
<p/>
A similar problem seems to exist for the exposition-only type <tt><i>call_wrapper</i></tt> from 
<a href="http://wg21.link/p0358r1">p0358r1</a>, which exposes a private data member named <tt>fd</tt> and 
a typedef <tt>FD</tt>.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Jonathan says that we need to make clear that the name <tt>node_handle</tt> is not reserved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2746" href="#2746">2746.</a> Inconsistency between requirements for <tt>emplace</tt> between <tt>optional</tt> and <tt>variant</tt></h3>
<p><b>Section:</b> 20.6.3 [optional.object] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-13 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.object">active issues</a> in [optional.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.object">issues</a> in [optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Referring to N4604:
</p>
<p>
In 20.6.3.3 [optional.object.assign]: <tt>emplace</tt> (normal form) has a Requires that the construction works.
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> 
is <tt>true</tt>.
</p>
</blockquote>
<p>
In 20.8.3.3 [any.modifiers]: <tt>emplace</tt> (normal form) has a Requires that the construction works:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
In 20.7.2.4 [variant.mod]: <tt>emplace</tt> (<tt>T</tt>, normal form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, and <tt>T</tt> occurs exactly 
once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (Idx, normal form) has a <em>both</em> a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>
<p/>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, and <tt>T</tt> 
occurs exactly once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>T</tt>, <tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is 
<tt>true</tt>, and <tt>T</tt> occurs exactly once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (Idx, <tt>initializer_list</tt> form) has a both a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>
<p/>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is true, and <tt>T</tt> occurs exactly 
once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
Why the inconsistency? Should all the cases have a SFINAE requirement?
<p/>
I see that variant has an additional requirement (<tt>T</tt> occurs exactly once in <tt>Types...</tt>), but that 
only agues that it must be a SFINAE condition &mdash; doesn't say that the other cases (any/variant) should not.
<p/>
<tt>map</tt>/<tt>multimap</tt>/<tt>unordered_map</tt>/<tt>unordered_multimap</tt> have SFINAE'd versions of 
<tt>emplace</tt> that don't take <tt>initializer_list</tt>s, but they don't have any <tt>emplace</tt> versions 
that take ILs.
<p/>
Suggested resolution:
<p/>
Add SFINAE requirements to <tt>optional::emplace(Args&amp;&amp;... args)</tt> and 
<tt>any::emplace(Args&amp;&amp;... args);</tt>
</p>

<p><i>[08-16 - Chicago]</i></p>

<p>During issue prioritization, people suggested that this might apply to <tt>any</tt> as well.</p>
<p>Ville notes that <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2754">2754</a> and <a href="lwg-active.html#2756">2756</a> all go together.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2749" href="#2749">2749.</a> <tt>swappable</tt> traits for <tt>variant</tt>s</h3>
<p><b>Section:</b> 20.7.2.6 [variant.swap], 20.7.9 [variant.specalg] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-19 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>variant</tt> does not play nice with swappable traits, the non-member specialized <tt>swap</tt> overload is not 
SFINAE friendly. On the other hand, the member <tt>swap</tt> is SFINAE friendly, albeit with an incomplete condition, 
when arguably it shouldn't be. Given the <i>Effects</i>, <i>Throws</i>, and <i>Remarks</i> clauses, the SFINAE 
condition should include <tt>is_move_constructible_v</tt> and <tt>is_move_assignable_v</tt> to account for the 
involvement of <tt>variant</tt>'s move constructor and move assignment operator (the <tt>noexcept</tt> specification is 
correct as is, since the move assignment operator would only be called for <tt>variant</tt>s with different alternatives). 
This SFINAE condition should apply to the non-member <tt>swap</tt> overload, while the member <tt>swap</tt> should require 
all alternatives are swappable (as defined by 17.6.3.2 [swappable.requirements]).
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P1 - review later in the week</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.7.2.6 [variant.swap] as indicated:</p>

<blockquote>
<pre>
void swap(variant&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> Lvalues of type <tt>T<sub><i>i</i></sub></tt> shall be swappable and 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.</ins>
<p/>
[&hellip;]
<p/>
-3- <i>Remarks:</i> <del>This function shall not participate in overload resolution unless <tt>is_swappable_v&lt;Ti&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.</del> If an exception is thrown during the call to function 
<tt>swap(get&lt;<i>i</i>&gt;(*this), get&lt;<i>i</i>&gt;(rhs))</tt>, the states of the contained values of 
<tt>*this</tt> and of <tt>rhs</tt> are determined by the exception safety guarantee of swap for lvalues of 
<tt>T<sub><i>i</i></sub></tt> with <tt><i>i</i></tt> being <tt>index()</tt>. If an exception is thrown during the 
exchange of the values of <tt>*this</tt> and <tt>rhs</tt>, the states of the values of <tt>*this</tt> and of <tt>rhs</tt> 
are determined by the exception safety guarantee of <tt>variant</tt>'s move constructor and move assignment operator. 
The expression inside <tt>noexcept</tt> is equivalent to the logical AND of 
<tt>is_nothrow_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; 
is_nothrow_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> for all <tt><i>i</i></tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.7.9 [variant.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt>v.swap(w)</tt>.
<p/>
-2- <i>Remarks:</i> <ins>This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt; 
&amp;&amp; is_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.</ins> The 
expression inside <tt>noexcept</tt> is equivalent to <tt>noexcept(v.swap(w))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2751" href="#2751">2751.</a> <tt>shared_ptr</tt> deleter not specified to observe expired <tt>weak_ptr</tt> instances</h3>
<p><b>Section:</b> 20.11.2.2.2 [util.smartptr.shared.dest] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Aaron Jacobs <b>Opened:</b> 2016-07-21 <b>Last modified:</b> 2016-08-02</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 standard contains no language that guarantees the deleter run by a
<tt>shared_ptr</tt> will see all associated <tt>weak_ptr</tt> instances as expired. For example,
the standard doesn't appear to guarantee that the assertion in the following
snippet won't fire:
</p>
<blockquote><pre>
std::weak_ptr&lt;Foo&gt; weak;
std::shared_ptr&lt;Foo&gt; strong{
  new Foo,
  [&amp;weak] (Foo* f) {
    assert(weak.expired());
    delete f;
  },
};

weak = strong;
strong.reset();
</pre></blockquote>
<p>
It seems clear that the intent is that associated <tt>weak_ptr</tt>s are expired,
because otherwise <tt>shared_ptr</tt> deleters could resurrect a reference to an object
that is being deleted.
<p/>
Suggested fix: 20.11.2.2.2 [util.smartptr.shared.dest] should specify that the decrease in
<tt>use_count()</tt> caused by the destructor is sequenced before the call to the
deleter or the call to <tt>delete p</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2754" href="#2754">2754.</a> The <tt>in_place</tt> constructors and <tt>emplace</tt> functions added by P0032R3 don't require <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 20.8.3.1 [any.cons], 20.8.3.2 [any.assign], 20.8.3.3 [any.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-07-05 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.cons">active issues</a> in [any.cons].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.cons">issues</a> in [any.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>in_place</tt> constructors and <tt>emplace</tt> functions
added by <a href="http://wg21.link/p0032r3">P0032R3</a> don't require <tt>CopyConstructible</tt>.
<p/>
They must. Otherwise copying an <tt>any</tt> that's made to hold a non-<tt>CopyConstructible</tt>
type must fail with a run-time error. Since that's crazy, we want to prevent
storing non-<tt>CopyConstructible</tt> types in an <tt>any</tt>.
<p/>
Previously, the requirement for <tt>CopyConstructible</tt> was just on the converting
constructor template and the converting assignment operator template on <tt>any</tt>.
Now that we are adding two <tt>in_place</tt> constructor overloads and two
<tt>emplace</tt> overloads, it seems reasonable to require <tt>CopyConstructible</tt> in some more 
general location, in order to avoid repeating that requirement all over the place.
</p>

<p><i>[2016-07 &mdash; Chicago]</i></p>

<p>Monday: P1</p>
<p>Tuesday: Ville/Billy/Billy provide wording</p>

<p><i>[2016-08-02: Daniel comments]</i></p>

<p>
The P/R wording of this issue brought to my intention that the recently added <tt>emplace</tt> functions
of <tt>std::any</tt> introduced a breakage of a previous class invariant that only a <tt>decay</tt>ed type could
be stored as object into an <tt>any</tt>, this prevented storing arrays, references, functions, and <i>cv</i>-qualified
types. The new constraints added my Ville do prevent some of these types (e.g. neither arrays nor functions meet
the <tt>CopyConstructible</tt> requirements), but we need to cope with <i>cv</i>-qualified types and reference types.
</p>

<p><i>[2016-08-02: Agust&iacute;n K-ballo Berg&eacute; comments]</i></p>

<p>
Presumably the constructors <tt>any(in_place_type_t&lt;T&gt;, ...)</tt> would need to be modified in the same way 
the <tt>emplace</tt> overloads were.
</p>

<p><i>[2016-08-02: Ville adjusts the P/R to cope with the problems pointed out by Daniel's and Agust&iacute;n's comments]</i></p>

<p>Ville notes that <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2754">2754</a> and <a href="lwg-active.html#2756">2756</a> all go together.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>
<blockquote class="note">
<p>
Drafting note: this P/R doesn't turn the <i>Requires</i>-clauses into <i>Remarks</i>-clauses.
We might want to do that separately, because SFINAEing the constructors
allows users to query for <tt>is_constructible</tt> and get the right answer. Failing
to mandate the SFINAE will lead to non-portable answers for <tt>is_constructible</tt>.
Currently, libstdc++ SFINAEs. That should be done as a separate issue,
as this issue is an urgent bug-fix but the mandated SFINAE is not.
</p>
</blockquote>

<ol>
<li><p>Change 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
<del>If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-11- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-15- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and</ins> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.2 [any.assign] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. <del>If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.3 [any.modifiers] as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-1- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is 
<tt>false</tt>, <tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<ins>-?- <i>Requires</i>: <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03: Ville comments and revises his proposed wording]</i></p>

<p>
After discussing the latest P/R, here's an update. What this update does is that:
</p>
<ol>
<li><p>It strikes the <i>Requires</i>-clauses and does <em>not</em> add
<tt>CopyConstructible</tt> to the <i>Requires</i>-clauses.
<p/>
Rationale: <tt>any</tt> doesn't care whether the type it holds satisfies the
semantic requirements of the <tt>CopyConstructible</tt> concept. The syntactic 
requirements are now SFINAE constraints in <i>Requires</i>-clauses.</p></li>
<li><p>It reverts back towards <tt>decay_t</tt> rather than <tt>remove_cv_t</tt>, and does
<em>not</em> add the suggested SFINAE constraints for <tt>is_reference</tt>/<tt>is_array</tt>/<tt>is_function</tt>.
<p/>
Rationale:
</p>
<ol style="list-style-type:lower-alpha">
<li><p><tt>any</tt> decays by design. It's to some extent inconsistent
to not protect against decay in the <tt>ValueType</tt> constructor/assignment operator, but to protect
against decay in the <tt>in_place_t</tt> constructors and <tt>emplace</tt> functions</p></li>
<li><p>I think it's saner to just decay than to potentially run into
situations where I need to <tt>remove_reference</tt> inside <tt>in_place_t</tt>.</p></li>
</ol>
</li>
</ol>
<p>
Based on that, this P/R should supersede the previous one. We want to
look at this new P/R in LWG and potentially send it to LEWG for verification. 
Personally, I think this P/R is the more conservative one, doesn't add 
significant new functionality, and is consistent, and is
thus not really Library-Evolutionary.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
<del>-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<del>-11- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and</ins> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.2 [any.assign] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
<del>-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.3 [any.modifiers] as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<del>-1- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03: Ville comments and revises his proposed wording]</i></p>

<p>
This P/R brings back the <tt>CopyConstructible</tt> parts of the relevant
Requires-clauses but removes the other parts of the Requires-clauses.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
<del>If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-11- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> 
requirements</ins><del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-15- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> 
requirements</ins><del><tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and</ins> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.2 [any.assign] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. <del>If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.3 [any.modifiers] as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-1- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> 
requirements</ins><del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<ins>-?- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2756" href="#2756">2756.</a> C++ WP <tt>optional&lt;T&gt;</tt> should 'forward' <tt>T</tt>'s implicit conversions</h3>
<p><b>Section:</b> 20.6.3 [optional.object] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-26 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.object">active issues</a> in [optional.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.object">issues</a> in [optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds converting constructors and assignment operators to <tt>optional</tt>. The committee 
voted to apply it to the Library Fundamentals 2 TS WP in Oulu as part of LWG Motion 3. In both LWG and LEWG 
discussion of this issue, it was considered to be critical to apply to the specification of <tt>optional</tt> 
before shipping C++17 &mdash; it was an oversight on the part of LWG that there was no motion brought to apply 
this resolution to the C++ WP.
<p/>
LWG <a href="lwg-active.html#2745">2745</a> proposes removal of the <tt>constexpr</tt> specifier from the declarations of the 
converting constructors from <tt>const optional&lt;U&gt;&amp;</tt> and <tt>optional&lt;U&gt;&amp;&amp;</tt> 
since they are not implementable as <tt>constexpr</tt> constructors in C++17.
<p/>
This issue proposes application of the resolution of LWG <a href="lwg-defects.html#2451">2451</a> as amended by LWG <a href="lwg-active.html#2745">2745</a> 
to the specification of <tt>optional</tt> in the C++ WP.
</p>

<p><i>[2016-07 &mdash; Chicago]</i></p>

<p>Monday: Priority set to 1; will re-review later in the week</p>

<p><i>[2016-08-03, Tomasz comments]</i></p>

<ol>
<li><p>Value forwarding constructor (<tt>template&lt;typename U&gt; optional(U&amp;&amp;)</tt>) is underspecified.</p>
<p>For the following use code:</p>

<blockquote><pre>
optional&lt;T&gt; o1;
optional&lt;T&gt; o2(o1);
</pre></blockquote>

<p>
The second constructor will invoke value forwarding <tt>(U = optional&lt;T&gt;&amp;)</tt> constructor (better match) 
instead of the <tt>optional&lt;T&gt;</tt> copy constructor, in case if <tt>T</tt> can be constructed from 
<tt>optional&lt;T&gt;</tt>. This happens for any type <tt>T</tt> that has unconstrained perfect forwarding constructor, 
especially <tt>optional&lt;any&gt;</tt>.
</p>
</li>
<li>
<p>The behavior of the construction of the <tt>optional&lt;T&gt; ot</tt> from <tt>optional&lt;U&gt; ou</tt> is 
inconsistent for classes <tt>T</tt> than can be constructed both from <tt>optional&lt;U&gt;</tt> and <tt>U</tt>. 
There are two possible semantics for such operation:
</p>
<ul>
<li><p><em>unwrapping:</em> if <tt>ou</tt> is initialized (<tt>bool(ou)</tt>), initialize contained value of <tt>ot</tt> 
from <tt>*ou</tt>, otherwise make <tt>ot</tt> uninitialized (<tt>!bool(ot)</tt>)</p></li>
<li><p><em>value forwarding:</em> initialize contained value of <tt>ot</tt> from <tt>ou</tt>, <tt>ot</tt> is always 
initialized (<tt>bool(ot)</tt>). 
<p/>
With the proposed resolution, construction is preferring <em>value forwarding</em>, 
while assignment is always using <em>unwrapping</em>.</p></li>
</ul>
<p>
For example, if we consider following class:
</p>
<blockquote>
<pre>
struct Widget
{
  Widget(int);
  Widget(optional&lt;int&gt;);
};
</pre>
</blockquote>
<p>
Notice, that such set of constructor is pretty common in situation when the construction of the 
<tt>Widget</tt> from known value is common and usage of <tt>optional</tt> version is rare. In such situation, 
presence of <tt>Widget(int)</tt> construction is an optimization used to avoid unnecessary empty checks and 
construction <tt>optional&lt;int&gt;</tt>.
<p/>
For the following declarations:
</p>
<blockquote>
<pre>
optional&lt;Widget&gt; w1(make_optional(10));
optional&lt;Widget&gt; w2;
w2 = make_optional(10);
</pre>
</blockquote>
<p>
The <tt>w1</tt> will contain a value created using <tt>Widget(optional&lt;int&gt;)</tt> constructor, 
as corresponding <em>unwrapping</em> constructor (<tt>optional&lt;U&gt; const&amp;</tt>) is eliminated by 
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> 
(<tt>is_constructible_v&lt;Widget, const optional&lt;int&gt;&amp;&gt;</tt>) having a <tt>true</tt> value.
In contrast <tt>w2</tt> will contain a value created using <tt>Widget(int)</tt> constructor, as corresponding 
value forwarding assignment (<tt>U&amp;&amp;</tt>) is eliminated by the fact that 
<tt>std::decay_t&lt;U&gt;</tt> (<tt>optional&lt;int&gt;</tt>) is specialization of <tt>optional</tt>.
<p/>
In addition, the construction is having a preference for <em>value forwarding</em> and assignment is always using 
<em>unwrapping</em>. That means that for the following class:
</p>
<blockquote><pre>
struct Thingy
{
   Thingy(optional&lt;string&gt;);
};

optional&lt;Thingy&gt; t1(optional&lt;string&gt;("test"));
</pre></blockquote>
<p>
The <tt>t1</tt> has a contained value constructed from using <tt>Thingy(optional&lt;std::string&gt;)</tt>, 
as unwrapping constructor (<tt>optional&lt;U&gt; const&amp;</tt>) are eliminated by the 
<tt>is_constructible&lt;T, U const&amp;&gt;</tt> (<tt>is_constructible&lt;Thingy, std::string const&amp;&gt;</tt>) 
being <tt>false</tt>. However the following:
</p>
<blockquote><pre>
t1 = optional&lt;std::string&gt;("test2");
</pre></blockquote>
<p>
will not compile, because, the <em>value forwarding</em> assignment (<tt>U&amp;&amp;</tt>) is eliminated by 
<tt>std::decay_t&lt;U&gt;</tt> (<tt>optional&lt;std::string&gt;</tt>) being optional specialization and the 
<em>unwrapping</em> assignment (<tt>optional&lt;U&gt; const&amp;</tt>) is ill-formed because 
<tt>is_constructible&lt;T, U const&amp;&gt;</tt> (<tt>is_constructible&lt;Thingy, std::string const&amp;&gt;</tt>) 
is <tt>false</tt>.
</p>
</li>
<li>
<p>
The semantics of construction and assignment, of <tt>optional&lt;optional&lt;V&gt;&gt;</tt> from 
<tt>optional&lt;U&gt;</tt> where <tt>U</tt> is convertible to/ same as <tt>T</tt> is also inconsistent. Firstly, 
in this situation the <tt>optional&lt;V&gt;</tt> is a type that can be constructed both from 
<tt>optional&lt;U&gt;</tt> and <tt>U</tt> so it fails into set of problem described above. However in 
addition we have following non-template constructor in <tt>optional&lt;T&gt;</tt>:
</p>
<blockquote><pre>
optional(T const&amp;);
</pre></blockquote>
<p>
Which for <tt>optional&lt;optional&lt;V&gt;&gt;</tt> is equivalent to:
</p>
<blockquote><pre>
optional(optional&lt;V&gt; const&amp;);
</pre></blockquote>
<p>
While there is no corresponding non-template assignment from <tt>T const&amp;</tt>, to make sure that 
<tt>o = {};</tt> always clear an <tt>optional o</tt>.
<p/>
So for the following declarations:
</p>
<blockquote><pre>
optional&lt;int&gt; oi;
optional&lt;short&gt; os;

optional&lt;optional&lt;int&gt;&gt; ooi1(oi);
optional&lt;optional&lt;int&gt;&gt; ooi2(os);
</pre></blockquote>
<p>
The <tt>ooi1</tt> uses <em>from-<tt>T</tt></em> constructor, while <tt>ooi2</tt> uses <em>value forwarding</em> constructor. 
In this case both <tt>ooi1</tt> and <tt>ooi2</tt> are initialized and their contained values <tt>*ooi1</tt>, 
<tt>*ooi2</tt> are uninitialized <tt>optional</tt>s. However, if we will attempt to make construction consistent 
with assignment, by preferring <em>unwrapping</em> (<tt>optional&lt;U&gt; const&amp;</tt>), then <tt>ooi2</tt> 
will end up being uninitialized.
<p/>
In summary, I believe that relation between <em>unwrapping</em>, <em>value forwarding</em> and 
<em>from-<tt>T</tt></em> construction/assignment is to subtle to being handled as defect report and requires 
a full paper analyzing possible design and their pros/cons.
</p>
</li>
</ol>

<p>Tuesday PM: Ville and Eric to implement and report back in Issaquah. Moved to Open</p>
<p>Ville notes that <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2754">2754</a> and <a href="lwg-active.html#2756">2756</a> all go together.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; class optional
{
public:
  using value_type = T;
  
  <i>// 20.6.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional &amp;);
  optional(optional &amp;&amp;) noexcept(<i>see below</i>);
  constexpr optional(const T &amp;);
  constexpr optional(T &amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args &amp;&amp;...);
  <ins>template &lt;class U&gt; constexpr optional(U &amp;&amp;);
  template &lt;class U&gt; optional(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional(optional&lt;U&gt; &amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 20.6.3.3, Assignment</i>
  optional &amp;operator=(nullopt_t) noexcept;
  optional &amp;operator=(const optional &amp;);
  optional &amp;operator=(optional &amp;&amp;) noexcept(<i>see below</i>);
  template &lt;class U&gt; optional &amp;operator=(U &amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt; &amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args &amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>
</li>

<li><p>In 20.6.3.1 [optional.object.ctor], insert new signature specifications after p31:</p>

<blockquote>
<p>
<ins>[<i>Note</i>: The following constructors are conditionally specified as <tt>explicit</tt>. This is typically 
implemented by declaring two such constructors, of which at most one participates in overload resolution. &mdash; 
<i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U&gt;
constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes the contained value as if direct-non-list-initializing an object of type <tt>T</tt> 
with the expression <tt>std::forward&lt;U&gt;(v)</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>*this</tt> contains a value.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
    shall be a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
    <tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>U</tt> is not the same type as <tt>T</tt>.
    The constructor is <tt>explicit</tt> if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <tt>rhs</tt> contains a value, initializes the contained value as if direct-non-list-initializing 
an object of type <tt>T</tt> with the expression <tt>*rhs</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same&lt;decay_t&lt;U&gt;, T&gt;</tt> is 
<tt>false</tt>, <tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt> and 
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>. The constructor is <tt>explicit</tt> 
if and only if <tt>is_convertible_v&lt;const U&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <tt>rhs</tt> contains a value, initializes the contained value as if 
direct-non-list-initializing an object of type <tt>T</tt> with the expression <tt>std::move(*rhs)</tt>. 
<tt>bool(rhs)</tt> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same&lt;decay_t&lt;U&gt;, T&gt;</tt> is 
<tt>false</tt>, <tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt> and 
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt> and <tt>U</tt> is not the same type 
as <tt>T</tt>. The constructor is <tt>explicit</tt> if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt>
is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.6.3.3 [optional.object.assign], change as indicated:</p>

<blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>v</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless 
<ins><ins><tt>decay_t&lt;U&gt;</tt> is not <tt>nullopt_t</tt> and <tt>decay_t&lt;U&gt;</tt> is not a specialization of 
<tt>optional</tt></ins></ins><del><tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt> is <tt>true</tt></del>.
<p/>
<del>-23- <i>Notes</i>: The reason for providing such generic assignment and then constraining it so that effectively 
<tt>T == U</tt> is to guarantee that assignment of the form <tt>o = {}</tt> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>:</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(const optional&lt;U&gt;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>*rhs</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s assignment, 
the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s assignment. 
The function shall not participate in overload resolution unless <tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt> is 
<tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>: The result of the expression <tt>bool(rhs)</tt> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>std::move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>std::move(*rhs)</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless
<tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2757" href="#2757">2757.</a> <tt>std::string{}.insert(3, "ABCDE", 0, 1)</tt> is ambiguous</h3>
<p><b>Section:</b> 21.3.1.6.4 [string::insert] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-07-30 <b>Last modified:</b> 2016-08-03</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before C++17, we had the following signature to <tt>std::basic_string</tt>:
</p>
<blockquote><pre>
basic_string&amp;
  insert(size_type pos1, const basic_string&amp; str, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
Unlike most of the other member functions on <tt>std::basic_string</tt>, there were not corresponding
versions that take a <tt>charT*</tt> or <tt>(charT *, size)</tt>.
<p/>
In <a href="http://wg21.link/p0254r2">p0254r2</a>, we added:
</p>
<blockquote><pre>
basic_string&amp;
  insert(size_type pos1, basic_string_view&lt;charT, traits&gt; sv, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
which made the code above ambiguous. There are two conversions from "<tt>const charT*</tt>", 
one to <tt>basic_string</tt>, and the other to <tt>basic_string_view</tt>, and they're both equally 
good (in the view of the compiler).
<p/>
This ambiguity also occurs with the calls
</p>
<blockquote><pre>
assign(const basic_string&amp; str,             size_type pos, size_type n = npos);
assign(basic_string_view&lt;charT, traits&gt; sv, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
but I will file a separate issue (<a href="lwg-active.html#2758">2758</a>) for that.
<p/>
A solution is to add <em>even more</em> overloads to <tt>insert</tt>, to make it match all the other member
functions of <tt>basic_string</tt>, which come in fours (<tt>string</tt>, <tt>pointer</tt>, <tt>pointer + size</tt>, 
<tt>string_view</tt>).
</p>

<p><i>[2016-08-03, Chicago, Robert Douglas provides wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.1 [basic.string] modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                         size_type pos2, size_type n = npos);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 21.3.1.6.4 [string::insert], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                     size_type pos2, size_type n = npos);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2758" href="#2758">2758.</a> <tt>std::string{}.assign("ABCDE", 0, 1)</tt> is ambiguous</h3>
<p><b>Section:</b> 21.3.1.6.3 [string::assign] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-07-30 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string::assign">issues</a> in [string::assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before C++17, we had the following signature to <tt>std::basic_string</tt>:
</p>
<blockquote><pre>
basic_string&amp;
  assign(const basic_string&amp; str, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
Unlike most of the other member functions on <tt>std::basic_string</tt>, there were not corresponding
versions that take a <tt>charT*</tt> or <tt>(charT *, size)</tt>.
<p/>
In <a href="http://wg21.link/p0254r2">p0254r2</a>, we (I) added:
</p>
<blockquote><pre>
basic_string&amp;
  assign(basic_string_view&lt;charT, traits&gt; sv, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
which made the code above ambiguous. There are two conversions from "<tt>const charT*</tt>", 
one to <tt>basic_string</tt>, and the other to <tt>basic_string_view</tt>, and they're both equally 
good (in the view of the compiler).
<p/>
This ambiguity also occurs with the calls
</p>
<blockquote><pre>
insert(size_type pos1, const basic_string&amp; str,             size_type pos2, size_type n = npos);
insert(size_type pos1, basic_string_view&lt;charT, traits&gt; sv, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
but I will file a separate issue (<a href="lwg-active.html#2757">2757</a>) for that.
<p/>
A solution is to add <em>even more</em> overloads to <tt>assign</tt>, to make it match all the other member
functions of <tt>basic_string</tt>, which come in fours (<tt>string</tt>, <tt>pointer</tt>, <tt>pointer + size</tt>, 
<tt>string_view</tt>).
</p>

<p><i>[2016-08-03, Chicago, Robert Douglas provides wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.1 [basic.string] modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; replace(size_type pos1, size_type n1,
                          <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                          size_type pos2, size_type n2 = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    int compare(size_type pos1, size_type n1,
                <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                size_type pos2, size_type n2 = npos) const;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 21.3.1.6.2 [string::append], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.6.3 [string::assign], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.6.6 [string::replace], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(size_type pos1, size_type n1, 
                     <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                     size_type pos2, size_type n2 = npos);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.7.9 [string::compare], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
int compare(size_type pos1, size_type n1,
            <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
            size_type pos2, size_type n2 = npos) const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2761" href="#2761">2761.</a> <tt>directory_entry</tt> comparisons are members</h3>
<p><b>Section:</b> 27.10.12.3 [directory_entry.obs] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-08-03 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#directory_entry.obs">active issues</a> in [directory_entry.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#directory_entry.obs">issues</a> in [directory_entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The comparison operators for <tt>directory_entry</tt> are member functions
(27.10.12.3 [directory_entry.obs]).
<p/>
That means that a <tt>directory_entry</tt> can be compared with a <tt>path</tt>,
but a <tt>path</tt> cannot be compared with a <tt>directory_entry</tt>, because
the left-hand side is not subject to conversions. This seems
unfortunate.
<p/>
Note that the comparisons for <tt>path</tt> are non-members (27.10.8.6 [path.non-member]).
<p/>
The meta-p/r is to turn the <tt>directory_entry</tt> comparisons into non-member functions.
</p>

<p><i>[08-2016 - Chicago]</i></p>

<p>Wed PM: Priority 2</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2762" href="#2762">2762.</a> <tt>unique_ptr operator*()</tt> should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 27.10.12.3 [directory_entry.obs] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-08-04 <b>Last modified:</b> 2016-08-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#directory_entry.obs">active issues</a> in [directory_entry.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#directory_entry.obs">issues</a> in [directory_entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See LWG <a href="lwg-active.html#2337">2337</a>. Since we aren't removing <tt>noexcept</tt> from <tt>shared_ptr</tt>'s 
<tt>operator*</tt>, we should consider adding <tt>noexcept</tt> to <tt>unique_ptr</tt>'s <tt>operator*</tt>.
</p>


<p><b>Proposed resolution:</b></p>





</body>
</html>
