<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-03-22 at 18:03:07 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2378"></a>2378. Behaviour of standard exception types</h3>
<p><b>Section:</b> 18.6.2.1 [bad.alloc], 18.6.2.2 [new.badlength], 18.7.2 [bad.cast], 18.7.3 [bad.typeid], 18.8.2 [bad.exception] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2014-03-31 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think we have an issue with the specification of some of the standard exception types. 
In particular, several of them have default constructors with remarks to the effect that 
"The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined". 
(In some cases this is contradictory to a further specification of <tt>what()</tt>, which 
is specified to return an implementation-defined NTBS.)
</p>

<p>
<strong>Previous resolution from Andy [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Edit 18.6.2.1 [bad.alloc] p3 as indicated:</p>

<blockquote>
<pre>
bad_alloc() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks</i>: <del>The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined</del><ins><tt>what()</tt> returns an implementation-defined NTBS</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.6.2.2 [new.badlength] p3 as indicated: [<i>Drafting note</i>: Added the Postcondition, since we don't 
say anything else about <tt>bad_array_new_length::what()</tt> &mdash; <i>end of note</i>]</p>

<blockquote>
<pre>
bad_array_new_length() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i><del>Remarks</del><ins>Postcondition</ins></i>: <del>The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined</del><ins><tt>what()</tt> returns an implementation-defined NTBS</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.2 [bad.cast] p3 as indicated:</p>

<blockquote>
<pre>
bad_cast() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.3 [bad.typeid] p3 as indicated:</p>

<blockquote>
<pre>
bad_typeid() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.8.2 [bad.exception] p3 as indicated:</p>

<blockquote>
<pre>
bad_exception() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2014-06-17, Rapperswil]</i></p>

<p>
Jonathan provides alternative wording.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
NJ: I don't know why we need the explict statement about <tt>what()</tt> here, since <tt>bad_array_new_length</tt> 
already derives.<br/> 
AM: yes.<br/> 
NJ: Then "what()" is missing from the synopsis.<br/> 
AM: Yes, that's an error and it needs to be added.
<p/>
Conclusion: Update the wording to add the missing entry in the synopsis. 
<p/>
AM: The issue needs another update; we need to add missing "Remarks". DK updates the paper.<br/> 
AM: Any objections to "tentatively ready"? No objections. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Edit 18.6.2.1 [bad.alloc] p3 as indicated:</p>

<blockquote>
<pre>
bad_alloc() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.6.2.1 [bad.alloc] p5 as indicated:</p>

<blockquote>
<pre>
virtual const char* what() const noexcept;
</pre>
<blockquote>
<p>
-5- <i>Returns</i>: An implementation-defined NTBS.
<p/>
<ins>-?- <i>Remarks</i>: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a <tt>wstring</tt> (21.3, 22.4.1.4).</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Edit class <tt>bad_array_new_length</tt> synopsis 18.6.2.2 [new.badlength] as indicated:</p>

<blockquote>
<pre>
namespace std {
  class bad_array_new_length : public bad_alloc {
  public:
    bad_array_new_length() noexcept;
    <ins>virtual const char* what() const noexcept;</ins>
  };
}
</pre>
</blockquote>
</li>

<li><p>Edit 18.6.2.2 [new.badlength] as indicated:</p>

<blockquote>
<pre>
bad_array_new_length() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined.</del>
</p>
</blockquote>
<pre>
<ins>virtual const char* what() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: An implementation-defined NTBS.</ins>
<p/>
<ins>-?- <i>Remarks</i>: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a <tt>wstring</tt> (21.3, 22.4.1.4).</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.2 [bad.cast] p3 as indicated:</p>

<blockquote>
<pre>
bad_cast() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.3 [bad.typeid] p3 as indicated:</p>

<blockquote>
<pre>
bad_typeid() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.8.2 [bad.exception] p3 as indicated:</p>

<blockquote>
<pre>
bad_exception() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2415"></a>2415. Inconsistency between <tt>unique_ptr</tt> and <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2015-01-19</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt> guarantees that it will not invoke its deleter if it stores
a null pointer, which is useful for deleters that must not be called
with a null pointer e.g.
</p>
<blockquote><pre>
unique_ptr&lt;FILE, int(*)(FILE*)&gt; fptr(file, &amp;::fclose);
</pre></blockquote>
<p>
However, <tt>shared_ptr</tt> does invoke the deleter if it owns a null pointer,
which is a silent change in behaviour when transferring
ownership from <tt>unique_ptr</tt> to <tt>shared_ptr</tt>. That means the following
leads to undefined behaviour:
</p>
<blockquote><pre>
std:shared_ptr&lt;FILE&gt; fp = std::move(fptr);
</pre></blockquote>
<p>
Peter Dimov's suggested fix is to construct an empty <tt>shared_ptr</tt> from a
<tt>unique_ptr</tt> that contains a null pointer.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on eight votes in favour.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] p29 as indicated:</p>
<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: <ins>If <tt>r.get() == nullptr</tt>, equivalent to <tt>shared_ptr()</tt>. Otherwise, if <tt>D</tt> is
not a reference type, equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt>. Otherwise, equivalent to 
<tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt></ins><del>Equivalent to <tt>shared_ptr(r.release(), 
r.get_deleter())</tt> when <tt>D</tt> is not a reference type, otherwise <tt>shared_ptr(r.release(), 
ref(r.get_deleter()))</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2448"></a>2448. Non-normative Container destructor specification</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-10-18 <b>Last modified:</b> 2015-03-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to Table 96 &mdash; "Container requirements" the specification:
</p>
<blockquote><p>
note: the destructor is applied to every element of <tt>a</tt>; any
memory obtained is deallocated.
</p></blockquote>
<p>
The initial "note:" can be read as if that part of the specification would not be normative (This note form
differs from footnotes in tables, which have normative meaning).
<p/>
It seems that this initial part of the specification exists since C++98. But comparing with
the similar <a href="https://www.sgi.com/tech/stl/Container.html">SGI Container specification</a> there is no evidence
for that being intended to be non-normative.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
NJ: If we fix this, we should also fix it elsewhere. Oh, this is the only place?<br/> 
GR: If this is intended to be different from elsewhere, we should make sure.<br/> 
AM: <tt>valarray</tt> specifies this without the "note:".<br/> 
DK: <tt>valarray</tt> requires trivially destructible types!<br/> 
GR: That's good enough for me.<br/> 
NJ: First time <tt>valarray</tt> has been useful for something!
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4140.
</p>

<ol>
<li><p>Change 23.2.1 [container.requirements.general], Table 96 &mdash; "Container requirements", as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>(&amp;a)-&gt;~X()</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
</td>
<td>
<del>note:</del> the destructor<br/>
is applied to every<br/>
element of <tt>a</tt>; any<br/>
memory obtained is
deallocated.
</td>
<td>
linear
</td>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2455"></a>2455. Allocator default construction should be allowed to throw</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-01-18</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements]/4 in the 2014-10 WP (N4140), says:
</p>
<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception. <tt>X::pointer</tt> 
and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
<p>
The words "these types" would normally apply only to the previous sentence only, i.e., only to the pointer types.  
However, an alternative reading would be that the allocator constructors themselves cannot throw. The change to 
the <tt>vector</tt> and <tt>string</tt> default constructors, making them unconditionally <tt>noexcept</tt> depends 
on this alternative reading.
<p/>
I believe that the wording in the standard is not intended to forbid throwing default constructors for allocators.  
Indeed, I believe that allocators do not require default constructors and that if they provide a default constructor 
they should be allowed to throw.
<p/>
In addition, the <tt>noexcept</tt> specifications for the <tt>string</tt> and <tt>vector</tt> default constructors 
should be changed to make them conditional.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p4 as indicated:</p>

<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these <ins>pointer</ins> types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
</li>

<li><p>Change 21.4 [basic.string] following p5, class template <tt>basic_string</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(noexcept(Allocator()))</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>
</li>

<li><p>Change 23.3.6.1 [vector.overview] following p2, class template <tt>vector</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(noexcept(Allocator()))</ins> : vector(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : vector(Allocator()) { }
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2467"></a>2467. <tt>is_always_equal</tt> has slightly inconsistent default</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], 20.7.8.1 [allocator.traits.types] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2015-01-18 <b>Last modified:</b> 2015-03-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 28 &mdash; "Allocator requirements" says that <tt>X::is_always_equal</tt> has a default value 
of <tt>is_empty&lt;X&gt;</tt>, and this is consistent with the return type description:
</p>
<blockquote>
<p>
Identical to or derived from <tt>true_type</tt> or <tt>false_type</tt>
</p>
</blockquote>
<p>
<tt>is_empty&lt;X&gt;</tt> is guaranteed to be derived from either <tt>true_type</tt> or <tt>false_type</tt>.  
So far so good.
<p/>
20.7.8.1 [allocator.traits.types]/p10 says:
</p>
<blockquote>
<pre>
typedef <i>see below</i> is_always_equal;
</pre>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;::type</tt>.
</p>
</blockquote>
</blockquote>
<p>
This is subtly different than what Table 28 says is the default: <tt>is_empty&lt;Alloc&gt;::type</tt> is 
not <tt>is_empty&lt;Alloc&gt;</tt>, but is rather one of <tt>true_type</tt> or <tt>false_type</tt>.
<p/>
There are two ways to fix this:
</p>
<ol>
<li>
<p>
Change Table 28 to say: <tt>is_empty&lt;X&gt;<ins>::type</ins></tt>.
<p/>
or
</p></li>

<li><p>Change 20.7.8.1 [allocator.traits.types]/p10:</p></li>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;<del>::type</del></tt>.
</p>
</blockquote>
</ol>
<p>
Both options are correct, and I see no reason to prefer one fix over the other. But Table 28 and 
20.7.8.1 [allocator.traits.types]/p10 should be consistent with one another.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: We should accept the first bullet. GR: Why does <tt>is_empty</tt> even have a type member? AM: All type traits 
have a type member. I agree with DK's preference for the first type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4296.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as presented:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::is_always_equal</tt>
</td>
<td>
Identical to or derived<br/>
from <tt>true_type</tt> or<br/>
<tt>false_type</tt>
</td>
<td>
[&hellip;]
</td>
<td>
<tt>is_empty&lt;X&gt;<ins>::type</ins></tt>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





</body>
</html>
