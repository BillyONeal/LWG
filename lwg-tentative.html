<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-09-15 at 18:09:19 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2015-03-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2224" href="#2224">2224.</a> Ambiguous status of access to non-live objects</h3>
<p><b>Section:</b> 17.6.4.10 [res.on.objects] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2012-12-17 <b>Last modified:</b> 2015-05-05</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.objects">issues</a> in [res.on.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard currently does not discuss when library objects may be accessed, except in a non-normative 
note pertaining to synchronization in [res.on.objects], leaving it ambiguous whether single-threaded 
code can access a library object during its construction or destruction. For example, there is a 
reasonable question as to what happens if the deleter supplied to a <tt>unique_ptr</tt> transitively 
accesses the <tt>unique_ptr</tt> itself during <tt>unique_ptr</tt>'s destruction; a straightforward 
reading suggests that this is permitted, and that the deleter will see the <tt>unique_ptr</tt> still 
holding the originally stored pointer, but consensus on the LWG reflector indicates this was not the 
intent (see discussion beginning with 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=33362">c++std-lib-33362</a>).
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Geoffrey will provide an example that clearly highlights the issue.
</p>

<p><i>[2013-03-19 Geoffrey provides revised resolution and an example]</i></p>


<p>
I contend that the most straightforward reading of the current standard requires the following example code to print 
"good" (because <tt>~unique_ptr</tt> is not specified to modify the state of the internal pointer), but the consensus 
on the reflector was that its behavior should be undefined.
<p/>
This example also shows that, contrary to a comment in the telecon, the PR is not tautological. 12.7 [class.cdtor]/p4 
explicitly permits member function calls during destruction, so the behavior of this code is well-defined as far as 
the core language is concerned, despite the fact that it accesses a library object after the end of the object's 
lifetime. If we want this code to have undefined behavior, we need to specify that at the library level.
</p>

<blockquote><pre>
#include &lt;memory&gt;
#include &lt;iostream&gt;

class A;

struct B {
 std::unique_ptr&lt;A&gt; a;
};

struct A {
 B* b;
 ~A() {
   if (b-&gt;a.get() == this) {
     std::cout &lt;&lt; "good" &lt;&lt; std::endl;
   }
 }
};

int main() {
 B b;
 b.a.reset(new A);
 b.a-&gt;b = &amp;b;
}
</pre></blockquote>

<p>
Previous resolution:
</p>
<blockquote class="note">
<ol>
<li><p>Change the title of sub-clause 17.6.4.10 [res.on.objects] as indicated:</p>
<p><del>Shared objects and the library</del><ins>Library object access</ins> [res.on.objects]</p>
</li>

<li><p>Edit 17.6.4.10 [res.on.objects] p2 as indicated:</p>
<p>-2- <del>[<i>Note</i>: In particular, the program is required to ensure that completion of the constructor 
of any object of a class type defined in the standard library happens before any other member function 
invocation on that object and, unless otherwise specified, to ensure that completion of any member function 
invocation other than destruction on such an object happens before destruction of that object. This applies 
even to objects such as mutexes intended for thread synchronization. &mdash; <i>end note</i>]</del>
<ins>If an object of a standard library type is accessed outside of the object's lifetime (3.8 [basic.life]), 
the behavior is undefined unless otherwise specified.</ins></p>
</li>
</ol>
</blockquote>

<p><i>[2014 Urbana]</i></p>

<p>
STL: is this resolved by our change to the reeentrancy rules? [LWG <a href="lwg-active.html#2414">2414</a>]<br/>
GR: don't think that solves the multi-threaded case<br/>
MC: I like changing the note to normative text<br/>
GR: uses the magic "happens before" words, and "access" is magic too<br/>
JW: I like this. strict improvement, uses the right wording we have to say this properly<br/>
STL: I like the last sentence of the note, could we add that as a new note at the end?<br/>
So add "[Note: This applies even to objects such as mutexes intended for thread synchronization.]" to the end and move to Ready 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Change the title of sub-clause 17.6.4.10 [res.on.objects] as indicated:</p>
<p><del>Shared objects and the library</del><ins>Library object access</ins> [res.on.objects]</p>
</li>

<li><p>Edit 17.6.4.10 [res.on.objects] p2 as indicated: <em>[<i>Editorial remark:</i> The motivation, is to 
be more precise about the meaning of "outside the object's lifetime" in the presence of threads &mdash; <i>end editorial 
remark</i>]</em></p>
<p>-2- <del>[<i>Note</i>: In particular, the program is required to ensure that completion of the constructor 
of any object of a class type defined in the standard library happens before any other member function 
invocation on that object and, unless otherwise specified, to ensure that completion of any member function 
invocation other than destruction on such an object happens before destruction of that object. This applies 
even to objects such as mutexes intended for thread synchronization. &mdash; <i>end note</i>]</del>
<ins>If an object of a standard library type is accessed, and the beginning of the object's lifetime 
(3.8 [basic.life]) does not happen before the access, or the access does not happen before the end 
of the object's lifetime, the behavior is undefined unless otherwise specified. [<i>Note</i>: This applies even to 
objects such as mutexes intended for thread synchronization. &mdash; <i>end note</i>]</ins></p>
</li>
</ol>






<hr>
<h3><a name="2273" href="#2273">2273.</a> <tt>regex_match</tt> ambiguity</h3>
<p><b>Section:</b> 28.11.2 [re.alg.match] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2013-07-14 <b>Last modified:</b> 2015-09-15</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.match">issues</a> in [re.alg.match].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.11.2 [re.alg.match] p2 in describing regex_match says:
</p>
<blockquote>
<p>
-2-  <i>Effects:</i> Determines whether there is a match between the regular expression <tt>e</tt>, and all of 
the character sequence <tt>[first,last)</tt>. The parameter <tt>flags</tt> is used to control how the expression 
is matched against the character sequence. Returns true if such a match exists, false otherwise.
</p>
</blockquote>

<p>
It has come to my attention that different people are interpreting the first sentence of p2 in different ways:
</p>

<ol>
<li><p>
If a search of the input string using the regular expression <tt>e</tt> matches the entire input string, 
<tt>regex_match</tt> should return true.
</p></li>
<li><p>
Search the input string using the regular expression <tt>e</tt>. Reject all matches that do not match the 
entire input string. If a such a match is found, return true.
</p></li>
</ol>

<p>
The difference between these two subtly different interpretations is found using the following ECMAScript example:
</p>

<blockquote><pre>
std::regex re("Get|GetValue");
</pre></blockquote>

<p>
Using <tt>regex_search</tt>, this <tt>re</tt> can never match the input string <tt>"GetValue"</tt>, because ECMA 
specifies that alternations are ordered, not greedy. As soon as <tt>"Get"</tt> is matched in the left alternation, 
the matching algorithm stops.
<p/>
Using definition 1, <tt>regex_match</tt> would return false for an input string of <tt>"GetValue"</tt>.
<p/>
However definition 2 alters the grammar and appears equivalent to augmenting the regex with a trailing <tt>'$'</tt>, 
which is an anchor that specifies, reject any matches which do not come at the end of the input sequence.
So, using definition 2, <tt>regex_match</tt> would return true for an input string of <tt>"GetValue"</tt>.
<p/>
My opinion is that it would be strange to have <tt>regex_match</tt> return true for a <tt>string/regex</tt> 
pair that <tt>regex_search</tt> could never find. I.e. I favor definition 1.
<p/>
John Maddock writes:
<p/>
The intention was always that <tt>regex_match</tt> would reject any match candidate which didn't match the entire 
input string. So it would find <tt>GetValue</tt> in this case because the <tt>"Get"</tt> alternative had already 
been rejected as not matching. Note that the comparison with ECMA script is somewhat moot, as ECMAScript defines 
the regex grammar (the bit we've imported), it does not define anything like <tt>regex_match</tt>, nor do we import 
from ECMAScript the behaviour of that function. So IMO the function should behave consistently regardless of the 
regex dialect chosen. Saying "use awk regexes" doesn't cut it, because that changes the grammar in other ways.
<p/>
(John favors definition 2).
<p/>
We need to clarify 28.11.2 [re.alg.match]/p2 in one of these two directions.
</p>

<p><i>[2014-06-21, Rapperswil]</i></p>

<p>
AM: I think there's a clear direction and consensus we agree with John Maddock's position, and if noone else 
thinks we need the other function I won't ask for it.
<p/>
Marshall Clow and STL to draft.
</p>

<p><i>[2015-06-10, Marshall suggests concrete wording]</i></p>


<p><i>[2015-01-11, Telecom]</i></p>

<p>Move to Tenatatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Change 28.11.2 [re.alg.match]/2, as follows:</p>

<blockquote><pre>
template &lt;class BidirectionalIterator, class Allocator, class charT, class traits&gt;
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m,
                   const basic_regex&lt;charT, traits>&amp; e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: The type <tt>BidirectionalIterator</tt> shall satisfy the requirements of a Bidirectional Iterator
(24.2.6).
<p/>
-2- <i>Effects</i>: Determines whether there is a match between the regular expression <tt>e</tt>, and all of the character
sequence <tt>[first,last)</tt>. The parameter <tt>flags</tt> is used to control how the expression is matched against
the character sequence. <ins>When determining if there is a match, only potential matches that match the entire character 
sequence are considered.</ins> Returns <tt>true</tt> if such a match exists, <tt>false</tt> otherwise. <ins>[<i>Example</i>:</ins>
</p>
<blockquote>
<pre>
<ins>std::regex re("Get|GetValue");
std::cmatch m;
regex_search("GetValue", m, re);	// returns true, and m[0] contains "Get"
regex_match ("GetValue", m, re);	// returns true, and m[0] contains "GetValue"
regex_search("GetValues", m, re);	// returns true, and m[0] contains "Get"
regex_match ("GetValues", m, re);	// returns false</ins>
</pre>
</blockquote>
<p>
<ins>&mdash; <i>end example</i>]</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.8.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2015-03-29</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.8.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.8.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.8.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.8.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.8.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.8.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2495" href="#2495">2495.</a> There is no such thing as an <i>Exception Safety</i> element</h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-05-05 <b>Last modified:</b> 2015-08-17</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.2.2.1 [util.smartptr.shared.const] includes several "Exception safety"
elements, but that is not one of the elements defined in 17.5.1.4
17.5.1.4 [structure.specifications]. We should either define what it means, or
just move those sentences into the <i>Effects:</i> clause.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
Move to Tentatively Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] as follows:</p>

<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Effects</i>: Constructs a <tt>shared_ptr</tt> object that <i>owns</i> the pointer <tt>p</tt>. <ins>If an exception 
is thrown, <tt>delete p</tt> is called.</ins>
<p/>
[&hellip;]
<p/>
<del>-7- <i>Exception safety</i>: If an exception is thrown, <tt>delete p</tt> is called.</del>
</p>
</blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template &lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-9- <i>Effects</i>: Constructs a <tt>shared_ptr</tt> object that owns the object <tt>p</tt> and the deleter <tt>d</tt>. 
The second and fourth constructors shall use a copy of <tt>a</tt> to allocate memory for internal use. <ins>If an exception 
is thrown, <tt>d(p)</tt> is called.</ins>
<p/>
[&hellip;]
<p/>
<del>-12- <i>Exception safety</i>: If an exception is thrown, <tt>d(p)</tt> is called.</del>
</p>
</blockquote>
[&hellip;]
<pre>
template &lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Effects</i>: Constructs a <tt>shared_ptr</tt> object that shares ownership with <tt>r</tt> and stores a copy of the pointer
stored in <tt>r</tt>. <ins>If an exception is thrown, the constructor has no effect.</ins>
<p/>
[&hellip;]
<p/>
<del>-27- <i>Exception safety</i>: If an exception is thrown, the constructor has no effect.</del>
</p>
</blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: Equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt> when <tt>D</tt> is not a reference type,
otherwise <tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt>. <ins>If an exception is thrown, the constructor has no effect.</ins>
<p/>
<del>-30- <i>Exception safety</i>: If an exception is thrown, the constructor has no effect.</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2500" href="#2500">2500.</a> [fund.ts.v2] fundts.memory.smartptr.shared.obs/6 should apply to <i>cv</i>-unqualified <tt>void</tt></h3>
<p><b>Section:</b> X [memory.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2015-05-11 <b>Last modified:</b> 2015-09-15</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
S. B. Tam reported this <a href="https://github.com/cplusplus/fundamentals-ts/issues/51">here</a>.
<p/>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3920.html">N3920</a> changed <tt>operator*()</tt> in 
[util.smartptr.shared.obs] as:
</p>
<blockquote>
<p>
<i>Remarks</i>: When <tt>T</tt> is <ins>an array type or <i>cv</i>-qualified</ins> <tt>void</tt>, it
is unspecified whether this member function is declared. &hellip;
</p>
</blockquote>
<p>
This excludes <i>cv</i>-unqualified <tt>void</tt>, which is probably unintended.
</p>

<p><i>[2015-09-11, Telecom]</i></p>

<p>
Move to Tentatively Ready
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>In the <a href="https://rawgit.com/cplusplus/fundamentals-ts/v2/fundamentals-ts.html#memory.smartptr.shared.obs.6">library 
fundamentals v2</a>, [memory.smartptr.shared.obs] p2, change as indicated:</p>
<blockquote>
<p>
<i>Remarks</i>: When <tt>T</tt> is an array type or <ins>(possibly</ins> <i>cv</i>-qualified<ins>)</ins> 
<tt>void</tt>, it is unspecified whether this
member function is declared. If it is declared, it is unspecified what
its return type is, except that the declaration (although not
necessarily the definition) of the function shall be well formed.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2510" href="#2510">2510.</a> Tag types should not be <tt>DefaultConstructible</tt></h3>
<p><b>Section:</b> 18.6 [support.dynamic], 20.2 [utility], 20.3.5 [pair.piecewise], 20.7.2 [memory.syn], 20.7.6 [allocator.tag], 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-06-13 <b>Last modified:</b> 2015-08-17</p>
<p><b>View all other</b> <a href="lwg-index.html#support.dynamic">issues</a> in [support.dynamic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::experimental::optional</tt>, for certain reasons, specifies its <tt>nullopt</tt> type
to not be <tt>DefaultConstructible</tt>. It doesn't do so for its tag type <tt>in_place_t</tt>
and neither does the standard proper for any of its tag types. That turns
out to be very unfortunate, consider the following:
</p>
<blockquote><pre>
#include &lt;memory&gt;
#include &lt;array&gt;

void f(std::array&lt;int, 1&gt;, int) {} // #1
void f(std::allocator_arg_t, int) {} // #2

int main()
{
  f({}, 666); // #3
}
</pre></blockquote>
<p>
The call at #3 is ambiguous. What's even worse is that if the overload #1
is removed, the call works just fine. The whole point of a tag type is that
it either needs to mentioned in a call or it needs to be a forwarded argument,
so being able to construct a tag type like that makes no sense.
<p/>
Making the types have an <em>explicit default constructor</em> might have helped, but 
<a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1518">CWG 1518</a>
is going against that idea.
<p/>
[optional.nullopt]/3 solves this problem for <tt>nullopt</tt>:
</p>
<blockquote>
<p>
Type <tt>nullopt_t</tt> shall not have a default constructor. It shall be a
literal type. Constant <tt>nullopt</tt> shall be initialized with an argument
of literal type.
</p>
</blockquote>

<p><i>[2015-06, Telecom]</i></p>

<p>
Move to Tentatively Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>In 18.6 [support.dynamic]/1, change the header <tt>&lt;new&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct nothrow_t <del>{}</del>; <ins><i>see below</i></ins>
extern const nothrow_t nothrow;
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 18.6 [support.dynamic]/1 (<em>following</em> the header <tt>&lt;new&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>nothrow_t</tt> shall not have a default constructor.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.2 [utility]/2, change the header <tt>&lt;utility&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.3.5, pair piecewise construction</i>
struct piecewise_construct_t <del>{ }</del>; <ins><i>see below</i></ins>
constexpr piecewise_construct_t piecewise_construct{ <ins><i>unspecified</i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 20.2 [utility]/2 (<em>following</em> the header <tt>&lt;utility&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>piecewise_construct_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>piecewise_construct</tt> shall be initialized with an argument of literal type.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.3.5 [pair.piecewise], apply the following edits:</p>

<blockquote><pre>
struct piecewise_construct_t <del>{ }</del>;
constexpr piecewise_construct_t piecewise_construct{ <ins><i>unspecified</i></ins> };
</pre></blockquote>
</li>
<li><p>In 20.7.2 [memory.syn]/1, change the header <tt>&lt;memory&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.7.6, allocator argument tag</i>
struct allocator_arg_t <del>{ }</del>; <ins><i>see below</i></ins>
constexpr allocator_arg_t allocator_arg{ <ins><i>unspecified</i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 20.7.2 [memory.syn]/1 (<em>following</em> the header <tt>&lt;memory&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>allocator_arg_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>allocator_arg</tt> shall be initialized with an
argument of literal type.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.7.6 [allocator.tag], apply the following edits:</p>

<blockquote><pre>
namespace std {
  struct allocator_arg_t <del>{ }</del>;
  constexpr allocator_arg_t allocator_arg{ <ins><i>unspecified</i></ins> };
}
</pre></blockquote>
<blockquote class="note">
<p>
Editorial drive-by: <tt>piecewise_construct_t</tt> is written, in 20.3.5 [pair.piecewise] like
</p>
<blockquote><pre>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
<p>
whereas other tag types such as <tt>allocator_construct_t</tt> are, in e.g.
20.7.6 [allocator.tag], written like
</p>
<blockquote><pre>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<p>
We should decide whether or not to write out the <tt>std</tt> namespace in such
paragraphs. I would suggest not to write it out.
</p>
</blockquote>

</li>
<li><p>In 30.4 [thread.mutex]/1, change the header <tt>&lt;mutex&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct defer_lock_t <del>{ }</del>; <ins><i>see below</i></ins>
struct try_to_lock_t <del>{ }</del>; <ins><i>see below</i></ins>
struct adopt_lock_t <del>{ }</del>; <ins><i>see below</i></ins>

constexpr defer_lock_t defer_lock { <ins><i>unspecified </i></ins> };
constexpr try_to_lock_t try_to_lock { <ins><i>unspecified </i></ins> };
constexpr adopt_lock_t adopt_lock { <ins><i>unspecified </i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add three new paragraphs after [thread.mutex]/1 (<em>following</em> the header <tt>&lt;mutex&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>defer_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>defer_lock</tt> shall be initialized with an
argument of literal type.</ins>
<p/>
<ins>-?- Type <tt>try_to_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>try_to_lock</tt> shall be initialized with an
argument of literal type.</ins>
<p/>
<ins>-?- Type <tt>adopt_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>adopt_lock</tt> shall be initialized with an
argument of literal type.</ins>
</p>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2515" href="#2515">2515.</a> [fund.ts.v2] Certain comparison operators of <tt>observer_ptr</tt> do not match synopsis</h3>
<p><b>Section:</b> X [memory.observer.ptr.special] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-07 <b>Last modified:</b> 2015-08-17</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a> 
[memory.observer.ptr.special] paragraphs 15, 17 and 19, the <tt>&gt;</tt>, <tt>&lt;=</tt> and 
<tt>&gt;=</tt> operators of <tt>observer_ptr</tt> are shown as
</p>
<blockquote><pre>
template &lt;class W&gt; 
bool operator>(observer_ptr&lt;W&gt; p1, observer_ptr&lt;W&gt; p2);
</pre></blockquote>
<p>
whereas in [header.memory.synop] they are shown as
</p>
<blockquote><pre>
template &lt;class W1, class W2&gt; 
bool operator>(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</pre></blockquote>
<p>
Given that the specification of <tt>operator&lt;</tt> took special care to support hetergeneous types, 
presumably the second version is intended.
</p>

<p><i>[2015-07, Telecom]</i></p>

<p>
Move to Tentatively Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit X [memory.observer.ptr.special] as indicated:</p>

<blockquote>
<pre>-15- template &lt;class W<ins>1, class W2</ins>&gt;
bool operator&gt;(observer_ptr&lt;W<ins>1</ins>&gt; p1, observer_ptr&lt;W<ins>2</ins>&gt; p2);
</pre>
<blockquote><p>
[&hellip;]
</p></blockquote>
<pre>
-17- template &lt;class W<ins>1, class W2</ins>&gt;
bool operator&lt;=(observer_ptr&lt;W<ins>1</ins>&gt; p1, observer_ptr&lt;W<ins>2</ins>&gt; p2);
</pre>
<blockquote><p>
[&hellip;]
</p></blockquote>
<pre>
-19- template &lt;class W<ins>1, class W2</ins>&gt;
bool operator&gt;=(observer_ptr&lt;W<ins>1</ins>&gt; p1, observer_ptr&lt;W<ins>2</ins>&gt; p2);
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2517" href="#2517">2517.</a> [fund.ts.v2] Two <tt>propagate_const</tt> assignment operators have incorrect return type</h3>
<p><b>Section:</b> X [propagate_const.assignment] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-08 <b>Last modified:</b> 2015-08-17</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a> 
[propagate_const.assignment] depicts the two <tt>operator=</tt>s described as returning by value. 
This is obviously incorrect. The class synopsis correctly shows them as returning by reference.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
Move to Tentatively Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit [propagate_const.assignment] as indicated:</p>
<blockquote>
<pre>
-1- template &lt;class U&gt;
constexpr propagate_const<ins>&amp;</ins> operator=(propagate_const&lt;U&gt;&amp;&amp; pu)
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
-5- template &lt;class U&gt;
constexpr propagate_const<ins>&amp;</ins> operator=(U&amp;&amp; u)
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2526" href="#2526">2526.</a> [fund.ts] Incorrect precondition for <tt>experimental::function::swap</tt></h3>
<p><b>Section:</b> 20.9.12.2.2 [func.wrap.func.mod] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-08-04 <b>Last modified:</b> 2015-09-15</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.mod">issues</a> in [func.wrap.func.mod].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
20.9.12.2.2 [func.wrap.func.mod] says that the precondition of <tt>swap</tt> is
</p>
<blockquote><pre>
this-&gt;get_memory_resource() == other-&gt;get_memory_resource()
</pre></blockquote>
<p>
That compares two pointers and so requires the memory resource used by <tt>*this</tt> and <tt>other</tt> to be 
the exact same object. That doesn't seem correct (for one, it would essentially outlaw swapping all <tt>function</tt>s 
constructed with "plain" allocators, since they would each have their own <tt>resource_adaptor</tt> object 
and so the pointers will not compare equal). Presumably the intent is to compare the <tt>memory_resource</tt>s for equality.
</p>
<p>
Also, <tt>other</tt> is a reference, not a pointer.
</p>

<p><i>[2015-09-11, Telecom]</i></p>

<p>
Move to Tentatively Ready
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>.
</p>

<ol>
<li><p>Edit 20.9.12.2.2 [func.wrap.func.mod] as indicated:</p>
<blockquote>
<pre>
void swap(function&amp; other);
</pre>
<blockquote>
<p>
-2- <i>Requires</i>: <tt><ins>*</ins>this-&gt;get_memory_resource() == <ins>*</ins>other<del>-&gt;</del><ins>.</ins>get_memory_resource()</tt>. 
<p/>
-3- <i>Effects</i>: Interchanges the targets of <tt>*this</tt> and <tt>other</tt>.
<p/>
-4- <i>Remarks</i>: The allocators of <tt>*this</tt> and <tt>other</tt> are not interchanged. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
