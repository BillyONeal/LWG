<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2016-08-02 at 13:08:57 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-02-12</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2179" href="#2179">2179.</a> <tt>enable_shared_from_this</tt> and construction from raw pointers</h3>
<p><b>Section:</b> 20.11.2.5 [util.smartptr.enab], 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-16 <b>Last modified:</b> 2016-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
On reflector message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32927">c++std-lib-32927</a>, 
Matt Austern asked whether the following example should be well-defined or not
</p>
<blockquote><pre>
struct X : public enable_shared_from_this&lt;X&gt; { };
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
pointing out that 20.11.2.2.1 [util.smartptr.shared.const] does not seem to allow it, since
<tt>xp1</tt> and <tt>xp2</tt> aren't allowed to share ownership, because each of them is required to have 
<tt>use_count() == 1</tt>. Despite this wording it might be reasonable (and technical possible)
to implement that request.
<p/>
On the other hand, there is the non-normative note in 20.11.2.5 [util.smartptr.enab] p11 (already part of TR1):
</p>
<blockquote><p>
The <tt>shared_ptr</tt> constructors that <span style="color:#C80000;font-weight:bold">create unique pointers</span> 
can detect the presence of an <tt>enable_shared_from_this</tt> base and assign the newly created <tt>shared_ptr</tt> 
to its <tt>__weak_this member</tt>.
</p></blockquote>
<p>
Now according to the specification in 20.11.2.2.1 [util.smartptr.shared.const] p3-7:
</p>
<blockquote><pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre></blockquote>
<p>
the notion of <em>creating unique pointers</em> can be read to be included by this note, because the post-condition
of this constructor is <tt>unique() == true</tt>. Evidence for this interpretation seems to be weak, though.
<p/>
Howard Hinnant presented the counter argument, that actually the following is an "anti-idiom" and it seems questionable 
to teach it to be well-defined in any case:
</p>
<blockquote><pre>
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
He also pointed out that the current post-conditions of the affected <tt>shared_ptr</tt> constructor
would need to be reworded.
<p/>
It needs to be decided, which direction to follow. If this idiom seems too much broken to be supported,
the note could be improved. If it should be supported, the constructors in
20.11.2.2.1 [util.smartptr.shared.const] need a careful analysis to ensure that post-conditions
are correct.
<p/>
Several library implementations currently do not support this example, instead they typically
cause a crash. Matt points out that there are currently no explicit requirements imposed on
<tt>shared_ptr</tt> objects to prevent them from owning the same underlying object without sharing the 
ownership. It might be useful to add such a requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
More discussion is needed to pick a direction to guide a proposed resolution.
</p>

<p><i>[2013-05-09 Jonathan comments]</i></p>

<p>
The note says the newly created <tt>shared_ptr</tt> is assigned to the <tt>weak_ptr</tt> member. It doesn't 
say before doing that the <tt>shared_ptr</tt> should check if the <tt>weak_ptr</tt> is non-empty and possibly 
share ownership with some other pre-existing <tt>shared_ptr</tt>.
</p>

<p><i>[2015-08-26 Daniel comments]</i></p>

<p>
LWG issue <a href="lwg-active.html#2529">2529</a> is independent but related to this issue.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2208" href="#2208">2208.</a> <tt>std::reverse_iterator</tt> should be a literal type</h3>
<p><b>Section:</b> 24.5.1 [reverse.iterators] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2016-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in [reverse.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
<tt>std::reverse_iterator::reverse_iterator(Iterator)</tt> should be constexpr
so that other constexpr functions can return <tt>reverse_iterator</tt>s. Of the
other methods, the other constructors, <tt>base()</tt>, <tt>operator+</tt>, <tt>operator-</tt>,
<tt>operator[]</tt>, and the non-member operators can probably also be
<tt>constexpr</tt>.
<p/>
<tt>operator*</tt> cannot be constexpr because it involves an assignment to a
member variable. Discussion starting with c++std-lib-33282 indicated
that it would be useful to make reverse_iterator a literal type
despite this restriction on its use at compile time.
</p>



<p><b>Proposed resolution:</b></p>
This issue was Resolved by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0">P0031R0</a>
adopted at Jacksonville, 2016.





<hr>
<h3><a name="2241" href="#2241">2241.</a> <tt>&lt;cstdalign&gt;</tt> and <tt>#define</tt> of <tt>alignof</tt></h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2016-06-28</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.runtime">active issues</a> in [support.runtime].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 18.10 [support.runtime] p2:
</p>

<blockquote><p>
The contents of these headers are the same as the Standard C library headers [..], <tt>&lt;stdalign.h&gt;</tt>, [..]
</p></blockquote>

<p>
Since our base C standard is C99, which doesn't have a <tt>&lt;stdalign.h&gt;</tt>, the reference to a non-existing 
C header is irritating (In this context <tt>&lt;stdalign.h&gt;</tt> doesn't refer to the deprecated C++ header
<tt>&lt;stdalign.h&gt;</tt> described in D.4 [depr.c.headers]).
<p/>
Furthermore, it would be also important that it doesn not define a macro named <tt>alignof</tt>, which C11 also defines 
in this header. 
<p/>
Currently we only have the following guarantee as part of 18.10 [support.runtime] p7:
</p>

<blockquote><p>
The header <tt>&lt;cstdalign&gt;</tt> and the header <tt>&lt;stdalign.h&gt;</tt> shall not define a macro named 
<tt>alignas</tt>.
</p></blockquote>

<p>
It is unclear what the better strategy is: Striking the reference to <tt>&lt;stdalign.h&gt;</tt> in
18.10 [support.runtime] p2 or upgrading to C11 as new base C standard.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
STL: related to earlier issue on C4, <a href="lwg-active.html#2201">2201</a>, and now we get a C11 header<br/>
JY: find _Alignof as keyword C11 FDIS has four defines in stdalign.h<br/>
AM: need paper for C11 as base library we should really do that<br/>
STL: really need vendor input<br/>
STL: don't think we need to do anything right now not P1<br/>
AM: any objections to downscale to P2  (no objections)
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Walter: this is on track to go away if we adopt Clark's paper to rebase to C11<br/>
Room: tentatively resolved; revisit after C11 paper: <a href="http://wg21.link/P0063">P0063</a><br/>
</p>

<p><i>[2016-03 Oulu]</i></p>

<p><a href="http://wg21.link/P0063">P0063</a> was adopted.</p>
<p>Change status to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.11.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-02-12</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.11.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.11.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2391" href="#2391">2391.</a> <tt>basic_string</tt> is missing non-<tt>const</tt> <tt>data()</tt></h3>
<p><b>Section:</b> 21.3.1 [basic.string] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Michael Bradshaw <b>Opened:</b> 2014-05-27 <b>Last modified:</b> 2016-05-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Regarding 21.3.1 [basic.string], <tt>std::basic_string&lt;charT&gt;::data()</tt> returns a <tt>const charT*</tt> 
21.3.1.7.1 [string.accessors]. While this method is convenient, it doesn't quite match <tt>std::array&lt;T&gt;::data()</tt> 
23.3.7.5 [array.data] or <tt>std::vector&lt;T&gt;::data()</tt> 23.3.11.4 [vector.data], both of which provide two 
versions (that return <tt>T*</tt> or <tt>const T*</tt>). An additional <tt>data()</tt> method can be added to 
<tt>std::basic_string</tt> that returns a <tt>charT*</tt> so it can be used in similar situations that <tt>std::array</tt> and 
<tt>std::vector</tt> can be used. Without a non-<tt>const</tt> <tt>data()</tt> method, <tt>std::basic_string</tt> has to be treated 
specially in code that is otherwise oblivious to the container type being used.
<p/>
Adding a <tt>charT*</tt> return type to <tt>data()</tt> would be equivalent to doing <tt>&amp;str[0]</tt> or <tt>&amp;str.front()</tt>.
<p/>
Small discussion on the issue can be found <a href="http://stackoverflow.com/questions/7518732/why-are-stdvectordata-and-stdstringdata-different">here</a>
and in the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/ll9HuEML6zo/discussion">std-discussion thread</a>  
(which didn't get too much attention).
<p/>
This requires a small change to <tt>std::basic_string</tt>'s definition in 21.3.1 [basic.string] to add the method to 
<tt>std::basic_string</tt>, and another small change in 21.3.1.7.1 [string.accessors] to define the new method.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Back to LEWG.
</p>

<p><i>[2016-05-22]</i></p>

<p>
Marshall says: this issue has been resolved by P0272R1.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change class template <tt>basic_string</tt> synopsis, 21.3.1 [basic.string], as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
  class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    <i>// 21.4.7, string operations:</i>
    const charT* c_str() const noexcept;
    const charT* data() const noexcept;
    <ins>charT* data() noexcept;</ins>
    allocator_type get_allocator() const noexcept;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Add the following sequence of paragraphs following 21.3.1.7.1 [string.accessors] p3, as indicated:</p>
<blockquote>
<pre>
<ins>charT* data() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: A pointer <tt>p</tt> such that <tt>p + i == &amp;operator[](i)</tt> for each <tt>i</tt> in <tt>[0,size()]</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Constant time.</ins>
<p/>
<ins>-?- <i>Requires</i>: The program shall not alter the value stored at <tt>p + size()</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2529" href="#2529">2529.</a> Assigning to <tt>enable_shared_from_this::__weak_this</tt> twice</h3>
<p><b>Section:</b> 20.11.2.5 [util.smartptr.enab] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-08-26 <b>Last modified:</b> 2016-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear what should happen if a pointer to an object with an
<tt>enable_shared_from_this</tt> base is passed to two different <tt>shared_ptr</tt>
constructors.
</p>
<blockquote><pre>
#include &lt;memory&gt;

using namespace std;

int main()
{
  struct X : public enable_shared_from_this&lt;X&gt; { };
  auto xraw = new X;
  shared_ptr&lt;X&gt; xp1(xraw);  // #1
  {
    shared_ptr&lt;X&gt; xp2(xraw, [](void*) { });  // #2
  }
  xraw-&gt;shared_from_this();  // #3
}
</pre></blockquote>
<p>
This is similar to LWG <a href="lwg-active.html#2179">2179</a>, but involves no undefined behaviour due
to the no-op deleter, and the question is not whether the second
<tt>shared_ptr</tt> should share ownership with the first, but which <tt>shared_ptr</tt>
shares ownership with the <tt>enable_shared_from_this::__weak_this</tt> member.
<p/>
With all three of the major <tt>std::shared_ptr</tt> implementations the <tt>xp2</tt>
constructor modifies the <tt>__weak_this</tt> member so the last line of the
program throws <tt>bad_weak_ptr</tt>, even though all the requirements on the 
<tt>shared_from_this()</tt> function are met (20.11.2.5 [util.smartptr.enab])/7:
</p>
<blockquote><p>
<i>Requires</i>: <tt>enable_shared_from_this&lt;T&gt;</tt> shall be an accessible base class
of <tt>T</tt>. <tt>*this</tt> shall be a subobject of an object <tt>t</tt> of type <tt>T</tt>. There shall
be at least one <tt>shared_ptr</tt> instance <tt>p</tt> that owns <tt>&amp;t</tt>.
</p></blockquote>
<p>
Boost doesn't update <tt>__weak_this</tt>, leaving it sharing with <tt>xp1</tt>, so the
program doesn't throw. That change was made to <tt>boost::enable_shared_from_this</tt> because 
someone reported exactly this issue as a bug, see <a href="https://svn.boost.org/trac/boost/ticket/2584">Boost issue 2584</a>.
<p/>
On the reflector Peter Dimov explained that there are real-world use
cases that rely on the Boost behaviour, and none which rely on the
behaviour of the current <tt>std::shared_ptr</tt> implementations. We should
specify the behaviour of <tt>enable_shared_from_this</tt> more precisely, and
resolve this issue one way or another.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2692" href="#2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-05-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2717" href="#2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.13.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.13.4 [allocator.adaptor.members] p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2739" href="#2739">2739.</a> Issue with <tt>time_point</tt> non-member subtraction with an unsigned duration</h3>
<p><b>Section:</b> 20.17.6.5 [time.point.nonmember] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Winterberg <b>Opened:</b> 2016-06-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.point.nonmember">issues</a> in [time.point.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4594, 20.17.6.5 [time.point.nonmember], <tt>operator-(time_point, duration)</tt> is specified as:
</p>
<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <tt>lhs + (-rhs)</tt>.
</p>
</blockquote>
</blockquote>
<p>
When <tt>Rep2</tt> is an unsigned integral type, the behavior is quite different with arithmetic of the underlying 
integral types because of the requirement to negate the incoming duration and then add that. It also ends up 
producing different results than the underlying durations as well as the non-member <tt>time_point::operator-=</tt>.
<p/>
Consider this program:
</p>
<blockquote>
<pre>
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;

using namespace std;
using namespace std::chrono;

int main()
{
  const duration&lt;uint32_t&gt; unsignedSeconds{5};

  auto someValue = system_clock::from_time_t(200);
  cout &lt;&lt; system_clock::to_time_t(someValue) &lt;&lt; '\n';
  cout &lt;&lt; system_clock::to_time_t(someValue - unsignedSeconds) &lt;&lt; '\n';
  someValue -= unsignedSeconds;
  cout &lt;&lt; system_clock::to_time_t(someValue) &lt;&lt; '\n';

  std::chrono::seconds signedDur{200};
  cout &lt;&lt; signedDur.count() &lt;&lt; '\n';
  cout &lt;&lt; (signedDur - unsignedSeconds).count() &lt;&lt; '\n';
  signedDur -= unsignedSeconds;
  cout &lt;&lt; signedDur.count() &lt;&lt; '\n';
}
</pre>
</blockquote>
<p>
The goal of the program is to compare the behavior of <tt>time_point</tt> non-member <tt>operator-</tt>, 
<tt>time_point</tt> member <tt>operator-=</tt>, <tt>duration</tt> non-member <tt>operator-</tt>, and 
<tt>duration</tt> member <tt>operator-=</tt> with basically the same inputs.
<p/>
libc++ produces this output, which appears mandated by the standard:
</p>
<blockquote>
<pre>
200
4294967491
195
200
195
195
</pre>
</blockquote>
<p>
On the other hand, libstdc++ produces this output, which is what I "intuitively" expect and behaves more consistently:
</p>
<blockquote>
<pre>
200
195
195
200
195
195
</pre>
</blockquote>
<p>
Given the seemingly brief coverage of durations with unsigned representations in the standard, this seems to be an 
oversight rather than a deliberate choice for this behavior. Additionally, there may be other "unexpected" behaviors 
with durations with an unsigned representation, this is just the one that I've come across.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Change 20.17.6.5 [time.point.nonmember] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <del><tt>lhs + (-rhs)</tt></del><ins><tt><i>CT</i>(lhs.time_since_epoch() - rhs)</tt>, where 
<tt><i>CT</i></tt> is the type of the return value</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2740" href="#2740">2740.</a> <tt>constexpr optional&lt;T&gt;::operator-&gt;</tt></h3>
<p><b>Section:</b> 20.6.3.5 [optional.object.observe] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-02 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>optional&lt;T&gt;::operator-&gt;</tt>s are constrained to be <tt>constexpr</tt> functions
only when <tt>T</tt> is not a type with an overloaded unary <tt>operator&amp;</tt>. This
constrain comes from the need to use <tt>addressof</tt> (or a similar
mechanism), and the inability to do so in a constant expression in
C++14. Given that <tt>addressof</tt> is now <tt>constexpr</tt>, this constrain is no
longer needed.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Modify 20.6.3.5 [optional.object.observe] as indicated:</p>

<blockquote>
<pre>
constexpr T const* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>*this</tt> contains a value.
<p/>
-2- <i>Returns:</i> <tt>val</tt>.
<p/>
-3- <i>Throws:</i> Nothing.
<p/>
-4- <i>Remarks:</i> <del>Unless <tt>T</tt> is a user-defined type with overloaded unary <tt>operator&amp;</tt>, 
t</del><ins>T</ins>hese functions shall be <tt>constexpr</tt> functions.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2744" href="#2744">2744.</a> <tt>any</tt>'s <tt>in_place</tt> constructors</h3>
<p><b>Section:</b> 20.8.3.1 [any.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-07-10 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.cons">active issues</a> in [any.cons].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.cons">issues</a> in [any.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>in_place</tt> constructor that takes an <tt>initializer_list</tt> has both a <i>Requires:</i>
for <tt>is_constructible</tt> and a <i>Remarks:</i> for <tt>is_constructible</tt>. The one
that takes just a pack has just a <i>Requires:</i> for <tt>is_constructible</tt>.
<p/>
I think both of those should be <i>Remarks:</i>, i.e. SFINAEable constraints.
Otherwise querying is_constructible for an any with <tt>in_place_t</tt> will
not give a reasonable answer, and I utterly fail to see any implementation
burden in SFINAEing those constructors.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.
<p/>
-8- <i>Effects:</i> Constructs an object of type <tt>any</tt> that contains an object of type <tt>T</tt> 
direct-initialized with <tt>std::forward&lt;ValueType&gt;(value)</tt>.
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution if <tt>decay_t&lt;ValueType&gt;</tt> is the
same type as <tt>any</tt> <ins>or if <tt>ValueType</tt> is a specialization of <tt>in_place_type_t</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-11- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></ins>
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2745" href="#2745">2745.</a> [fund.ts.v2] Implementability of LWG 2451</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-10 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::optional.object">issues</a> in [fund.ts.v2::optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds conditionally explicit converting constructors to <tt>optional&lt;T&gt;</tt> that accept:
</p>
<ol>
<li>Types convertible to <tt>T</tt>: <tt>template &lt;class U&gt; constexpr optional(T&amp;&amp;);</tt></li>
<li>Rvalue <tt>optional&lt;U&gt;</tt> when <tt>U&amp;&amp;</tt> is convertible to <tt>T</tt>: 
<tt>template &lt;class U&gt; constexpr optional(optional&lt;U&gt;&amp;&amp;);</tt></li>
<li>Lvalue <tt>const optional&lt;U&gt;</tt> when <tt>const U&amp;</tt> is convertible to <tt>T</tt>: 
<tt>template &lt;class U&gt; constexpr optional(const optional&lt;U&gt;&amp;);</tt></li>
</ol>
<p>
All three of these constructors are required to be <tt>constexpr</tt> "If <tt>T</tt>'s selected constructor is a 
<tt>constexpr</tt> constructor". While this is not problematic for #1, it is not possible in the current language 
to implement signatures #2 and #3 as <tt>constexpr</tt> functions for the same reasons that <tt>optional</tt>'s 
<em>non-converting</em> constructors from <tt>optional&lt;T&gt;&amp;&amp;</tt> and <tt>const optional&lt;T&gt;&amp;</tt> 
cannot be <tt>constexpr</tt>.
<p/>
We should remove the "<tt>constexpr</tt>" specifier from the declarations of the conditionally explicit converting 
constructors that accept <tt>optional&lt;U&gt;&amp;&amp;</tt> and <tt>const optional&lt;U&gt;&amp;</tt>, and strike 
the remarks requiring these constructors to be <tt>constexpr</tt>.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>
<p>This needs to be considered for C++17 as well</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<blockquote class="note">
<p>
Wording relative to N4600 + LWG <a href="lwg-defects.html#2451">2451</a>, although it should be noted that this resolution should be applied 
wherever LWG <a href="lwg-defects.html#2451">2451</a> is applied, be that to the fundamentals TS or the specification of <tt>optional</tt> in the 
C++ Working Paper.
</p>
</blockquote>

<ol>
<li><p>Edit 99 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;

  // 5.3.1, Constructors
  [&hellip;]
  template &lt;class U&gt; constexpr optional(U&amp;&amp;);
  template &lt;class U&gt; <del>constexpr</del> optional(const optional&lt;U&gt;&amp;);
  template &lt;class U&gt; <del>constexpr</del> optional(optional&lt;U&lt;&amp;&amp;);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>In 99 [optional.object.ctor], modify the new signature specifications added by LWG <a href="lwg-defects.html#2451">2451</a></p>

<blockquote>
<pre>
template &lt;class U&gt;
  <del>constexpr</del> optional(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-48- <i>Remarks:</i> <del>If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.</del> This constructor shall not participate in overload resolution 
unless [&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U&gt;
  <del>constexpr</del> optional(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-53- <i>Remarks:</i> <del>If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.</del> This constructor shall not participate in overload resolution 
unless [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2747" href="#2747">2747.</a> Possibly redundant <tt>std::move</tt> in [alg.foreach]</h3>
<p><b>Section:</b> 25.3.4 [alg.foreach] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-07-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.4 [alg.foreach] p3 says <i>Returns:</i> <tt>std::move(f)</tt>.
<p/>
12.8 [class.copy] says that since <tt>f</tt> is a function parameter overload resolution to select the constructor 
for the return value is first performed as if for an rvalue, so the <tt>std::move</tt> is redundant.
<p/>
It could be argued that it isn't entirely redundant, because it says that implementations can't do something slightly different like return an lvalue reference that is bound to <tt>f</tt>, which would prevent it being treated as an rvalue. We should discuss it.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 25.3.4 [alg.foreach] as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Function&gt;
  Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Returns:</i> <tt><del>std::move(</del>f<del>)</del></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2748" href="#2748">2748.</a> <tt>swappable</tt> traits for <tt>optional</tt>s</h3>
<p><b>Section:</b> 20.6.3.4 [optional.object.swap], 20.6.9 [optional.specalg] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-19 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>optional</tt> didn't benefit from the wording modifications by P0185 "Adding [<tt>nothrow_</tt>]<tt>swappable</tt> 
traits"; as such, it suffers from LWG <a href="lwg-defects.html#2456">2456</a>, and does not play nice with swappable traits.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3.4 [optional.object.swap] as indicated:</p>

<blockquote>
<pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote>
<pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.9 [optional.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2750" href="#2750">2750.</a> [fund.ts.v2] LWG 2451 conversion constructor constraint</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object.ctor] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds a converting constructor to <tt>optional</tt> with signature:
</p>
<blockquote>
<pre>
template &lt;class U&gt;
constexpr optional(U&amp;&amp; v);
</pre>
</blockquote>
<p>
and specifies that "This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>U</tt> is not the same type as <tt>T</tt>." 
This suffices to avoid this constructor being selected by overload resolution for arguments that should match the 
move constructor, but not for arguments that should match the copy constructor. The recent churn around tuple's 
constructors suggests that we want this constructor to not participate in overload resolution if 
<tt>remove_cv_t&lt;remove_reference_t&lt;U&gt;&gt;</tt> is the same type as <tt>T</tt>.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<blockquote class="note">
<p>
Wording relative to N4600 + LWG <a href="lwg-defects.html#2451">2451</a>, although it should be noted that this resolution should be applied 
wherever LWG <a href="lwg-defects.html#2451">2451</a> is applied, be that to the fundamentals TS or the specification of <tt>optional</tt> in the 
C++ Working Paper.
</p>
</blockquote>

<ol>
<li><p>In 99 [optional.object.ctor], modify as indicated:</p>

<blockquote>
<pre>
template &lt;class U&gt;
  constexpr optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-43- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall 
be a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt><ins>decay_t&lt;</ins>U<ins>&gt;</ins></tt> 
is not the same type as <tt>T</tt>. The constructor is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> 
is <tt>false</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2753" href="#2753">2753.</a> Optional's constructors and assignments need constraints</h3>
<p><b>Section:</b> 20.6.3.1 [optional.object.ctor], 20.6.3.3 [optional.object.assign] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-22 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To use <tt>optional&lt;T&gt;</tt> as if it were a <tt>T</tt> in generic contexts, <tt>optional&lt;T&gt;</tt>'s "generic" 
operations must behave as do those of <tt>T</tt> under overload resolution. At minimum, <tt>optional</tt>'s constructors 
and assignment operators should not participate in overload resolution with argument types that cannot be used to 
construct/assign the contained <tt>T</tt> so that <tt>is_constructible_v&lt;optional&lt;T&gt;, Args...&gt;</tt> 
(respectively <tt>is_assignable_v&lt;optional&lt;T&gt;&amp;, RHS&gt;</tt>) is equivalent to 
<tt>is_constructible_v&lt;T, Args...&gt;</tt> (respectively <tt>is_assignable_v&lt;T&amp;, RHS&gt;</tt>).
</p>
<p>
In passing, note that the Requires element for <tt>optional</tt>'s in-place <tt>initializer_list</tt> constructor 
unnecessarily duplicates its Remarks element; it should be removed.
</p>
<p>
It should also be noted that the resolution of LWG <a href="lwg-defects.html#2451">2451</a> adds constructors to <tt>optional</tt> with 
appropriate constraints, but does not constrain the additional assignment operators. If LWG chooses to apply the 
resolution of 2451 to the WP, the Requires elements of the additional assignment operators should also be converted 
to constraints as the wording herein does for the assignment operators in N4606.
</p>
<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Remove 20.6.3.1 [optional.object.ctor] p3, and add a new paragraph after p6:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <em>Remarks:</em> The function shall not participate in overload resolution unless 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p7, and change p11 to:</p>

<blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <em>Remarks:</em> The expression inside <tt>noexcept</tt> is equivalent to 
<tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>. <ins>The function shall not participate in 
overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p12, and change p16 to:</p>

<blockquote>
<pre>
constexpr optional(const T&amp; v);
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-16- <em>Remarks:</em> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>The function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p17, and change p21 to:</p>

<blockquote>
<pre>
constexpr optional(T&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-21- <em>Remarks:</em> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall 
be a <tt>constexpr</tt> constructor. <ins>The function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p22, and change p26 to:</p>

<blockquote>
<pre>
template &lt;class... Args&gt; 
  constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <em>Remarks:</em> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>The function shall not participate in overload 
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p27.</p>

<blockquote>
<pre>
template &lt;class U, class... Args&gt; 
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p4, and change p8 to:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <em>Remarks:</em> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown 
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception 
safety guarantee of <tt>T</tt>'s copy assignment. <ins>The function shall not participate in overload resolution 
unless <tt>is_copy_constructible_v&lt;T&gt; &amp;&amp; is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p9, and add a new paragraph after p14:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-14- <i>Remarks:</i> [&hellip;] If an exception is thrown during the call to <tt>T</tt>'s move
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety 
guarantee of <tt>T</tt>'s move assignment.
<p/>
<ins>The function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt; &amp;&amp; is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins></p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p15, and change p19 to (yes, this wording is odd - the intent 
is that it will "do the right thing" after incorporation of LWG <a href="lwg-defects.html#2451">2451</a>):</p>

<blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <em>Remarks:</em> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>v</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless <tt>is_same_v&lt;decay_t&lt;U&gt;, 
T&gt;<ins> &amp;&amp; is_constructible_v&lt;T, U&gt; &amp;&amp; is_assignable_v&lt;T&amp;, U&gt;</ins></tt> is 
<tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2755" href="#2755">2755.</a> string.view.io uses non-existent <tt>basic_string_view::to_string</tt> function</h3>
<p><b>Section:</b> 21.4.4 [string.view.io], 21.3.2.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Baker <b>Opened:</b> 2016-07-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In looking at N4606, [string.view.io] has an <i>Effects</i> clause that references <tt>basic_string_view::to_string</tt> 
which no longer exists after the application of <a href="http://wg21.link/p0254r2">P0254R2</a>.
</p>

<p><i>[2016-07-26, Marshall suggests concrete wording]</i></p>

<p><i>[07-16 - Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 21.3.2.9 [string.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT, traits, Allocator&gt;&amp; str);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> <ins>Equivalent to: <tt>return os &lt;&lt; basic_string_view&lt;charT, 
traits&gt;(str);</tt></ins><del>Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) 
of <tt>os</tt>. Forms a character sequence <tt>seq</tt>, initially consisting of the elements defined by the 
range <tt>[str.begin(), str.end())</tt>. Determines padding for <tt>seq</tt> as described in 
27.7.3.6.1 [ostream.formatted.reqmts]. Then inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, 
where <tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</del>
<p/>
<del>-6- <i>Returns:</i> <tt>os</tt></del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 21.4.4 [string.view.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               basic_string_view&lt;charT, traits&gt; str);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> <del>Equivalent to: <tt>return os &lt;&lt; str.to_string();</tt></del><ins>Behaves 
as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>os</tt>. Forms a character 
sequence <tt>seq</tt>, initially consisting of the elements defined by the range <tt>[str.begin(), 
str.end())</tt>. Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Then 
inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</ins>
<p/>
<ins>-?- <i>Returns:</i> <tt>os</tt></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
