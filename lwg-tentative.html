<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-02-27 at 12:02:54 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2111"></a>2111. Which <tt>unexpected</tt>&#47;<tt>terminate</tt> handler is called from the exception handling runtime?</h3>
<p><b>Section:</b> 18.8.3.4 [terminate], D.11.4 [unexpected] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-12-06 <b>Last modified:</b> 2015-02-27</p>
<p><b>View all other</b> <a href="lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Prior to N3242, modified by N3189, we said this about <tt>unexpected()</tt>:
</p>

<blockquote><p>
<i>Effects</i>: Calls the <tt>unexpected_handler</tt> function in effect immediately after evaluating the throw-expression 
(D.13.1), if called by the implementation, or calls the current <tt>unexpected_handler</tt>, if called by the program.
</p></blockquote>

<p>
and this about <tt>terminate()</tt>:
</p>

<blockquote><p>
<i>Effects</i>: Calls the <tt>terminate_handler</tt> function in effect immediately after evaluating the throw-expression (18.8.3.1), 
if called by the implementation, or calls the current <tt>terminate_handler</tt> function, if called by the program.
</p></blockquote>

<p>
But now in both places we say:
</p>

<blockquote><p>
Calls the current <tt>unexpected_handler</tt> function.
</p></blockquote>

<p>
and:
</p>

<blockquote><p>
Calls the current <tt>terminate</tt> function.
</p></blockquote>

<p>
The difference is that in C++98&#47;03 if a destructor reset a handler during stack unwinding, that new handler was 
not called if the unwinding later led to <tt>unexpected()</tt> or <tt>terminate()</tt> being called.  But these new 
words say that this new handler <em>is</em> called. This is an ABI-breaking change in the way exceptions are handled.  
Was this change intentional?
<p/>
N3189 was mainly about introducing exception safety and getters for the handlers. I don't recall the issue of 
<em>which</em> handler gets called being part of the discussion.
<p/>
I propose that we revert to the C++98&#47;03 behavior in this regard, lest ABI's such as the Itanium ABI are invalidated.  
A mechanical way to do this is to revert bullets 9 and 12 of N3189.
</p>

<p><i>[2011-12-09: Daniel comments]</i></p>


<p>
There was no such semantic change intended. It was an unfortunate side effect when trying to better separate different
responsibilities in the previous wording.
<p/>
A related issue is <a href="lwg-active.html#2088">2088</a>.
</p>

<p><i>[2012-01-30: Howard comments]</i></p>


<p>
The C++98&#47;03 wording is somewhat ambiguous:
</p>
<blockquote><p>
Calls the terminate_handler function in effect immediately after evaluating the throw-expression...
</p></blockquote>
<p>
There are potentially two throw-expressions being referred to here, and it is not clear if this sentence is referring to just the first or both:
</p>
<ol>
<li><tt>throw <i>assignment-expression</i>;</tt></li>
<li><tt>throw;</tt></li>
</ol>
<p>
There is ample evidence in current implementations that it is understood that <i>only</i> 
1. was meant. But clearly both 1 and 2 could have been meant. We need a clarification. Does an execution 
of a rethrow (throw;) update which handlers can potentially be called?
</p>
<ol>
<li value="2"><tt>throw;</tt> // update handlers to get_xxx()?</li>
</ol>
<p>
My opinion: Go with existing practice, and clarify what that practice is, if surveys find that everyone 
does the same thing. Gcc 4.2 and Apple do 1. only, and do not reset the handlers to the current handlers 
on throw;.
<p/>
If current practice is not unanimously one way or the other, I have no strong opinion. I have not found 
a motivating use case for the use of any particular handler. Most applications set the handlers once at 
the beginning of the program and then do not change them, and so will not be impacted by whatever decision 
is made here.
</p>

<p><i>[2014-02-15 Issaquah: Move to Review]</i></p>


<p>
STL: Original change in N3242 came from trying to make set/get exception handler thread safe.
The issue requests we revert to 98/03, which Howard notes was already ambiguous.
</p>

<p>
Alisdair: Issue author thinks we made this change in C++11 without taking into account Itanium ABI,
which cannot implement the new semantic (without breaking compatibility).
</p>

<p>
Alisdair: original change in N3242 was trying to solve the problem of which handler is called when
the handler is changing in another thread, but this turns out to be an issue in even the
single-threaded case.
</p>

<p>
Pablo: despite wanting to make it thread safe, you are still changing a global
</p>

<p>
STL and Marshall confirm that there is real implementation divergance on the question, so
we cannot pick just one behavior if we want to avoid breaking exisitng practice.
</p>

<p>
Alisdair: not sure who to talk to across all library vendors to fix, need more information
for progress (IBM and Sun)
</p>

<p>
STL: Howard did identify a problem with the wording as well: <tt>throw;</tt> is a throw expression,
but we typically want to re-activate the in-flight exception, not throw a new copy.
</p>

<p>
Pablo: wondering why all of this wording is here (N3189)? It looks like we were trying to handle another thread
changing handler between a <tt>throw</tt> and <tt>terminate</tt> in current thread.
</p>

<p>
Alisdair: Anything working with exception handling should have used only thread-local resources, but that ship has sailed.
We must account for the same exception object being re-thrown in multiple threads simultaneously, with no happens-before
relationships.
</p>

<p>
Room: Why on earth would we care about exactly which way the program dies when the terminate calls are racing?!
</p>

<p>
Pablo: Reasonable to set the handler once (in <tt>main</tt>) and never change it.
</p>

<p>
Pablo: If willing to put lots of work into this, you could say at point of a <tt>throw</tt> these handlers become
thread local but that is overkill.  We want destructors to be able to change these handlers (if only for backwards
compatibility).
</p>

<p>
Alisdair: the <i>&quot;do it right&quot;</i> is to do something per thread, but that is more work than vendors will want to do.
Want to say setting handler while running multiple threads is unspecified.
</p>

<p>
Pablo: possible all we need to do is say it is always the current handler
</p>

<p>
STL: That prevents an implementation or single threaded program from calling a new handler after a <tt>throw</tt>,
probably should say if <tt>terminate</tt> is called <i>by the implementation</i> (during EH), any handler that was
current can be called.  Leaves it up in the air as to when the handler is captured, supporting the diverging
existing practices.
</p>

<p>
Jeffrey: use <i>happens before</i> terminology to avoid introducing races
</p>

<p>
STL: Give this to concurrency?
</p>

<p>
Jeffrey: It is in clause 18, generally LWG and not SG1 territory.
</p>

<p>
Alisdair: Concerned about introducing <i>happens before</i> into fundamental exception handling since it would affect
single threaded performance as well.  Want to give to concurrency or LEWG/EWG, we are into language design here.
</p>

<p>
Jeffrey: suspect LEWG won't have a strong opinion.  I don't want it to be ours!!!
</p>

<p>
Pablo: Might be a case for core>
</p>

<p>
Alisdair: Would be happier if at least one core person were in the discussion.
</p>

<p>
STL: No sympathy for code that tries to guard the terminate handler.
</p>

<p>
Alisdair: We are back to set it once, globally.  Want to be clear that if <tt>set_terminate</tt> is called just once,
when EH is not active, and never changed again, then the user should get the handler from that specific call.
</p>

<p>
AlisdairM: "unspecified which handler is called if an exception is active when <tt>set_terminate</tt> is called."
This supports existing behaviors, and guarantees which handler is called in non-conentious situations.  Implicit
assumption that a funtion becomes a handler only after a successful call to <tt>set_handler</tt>, so we are not
leaving a door open to the implementation inventing entirely new handlers of its own.
</p>

<p>
<i>Consensus.</i>
</p>

<p>
Poll to confirm status as P1: new consensus is P3
</p>

<p>
<i>Action:</i> Alisdair provides new wording.  Drop from P1 to P3, and move to Review.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Amend 18.8.3.4 [terminate] as indicated:
</p>

<tt>[[noreturn]] void terminate() noexcept;</tt>
<blockquote><p>
<i>Remarks:</i> Called by the implementation when exception handling must be abandoned for any of several reasons (15.5.1)
<del>, in effect immediately after throwing the exception</del>. May also be called directly by the program.
</p></blockquote>

<blockquote><p>
<i>Effects:</i> <ins>Calls a <tt>terminate_handler</tt> function. It is unspecified which <tt>terminate_handler</tt> function will
be called if an exception is active during a call to <tt>set_terminate</tt>. Otherwise c</ins><del>C</del>alls the current
<tt>terminate_handler</tt> function. [<i>Note:</i> A default <tt>terminate_handler</tt> is always considered a callable handler in
this context. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Amend D.11.4 [unexpected] as indicated:
</p>

<tt>[[noreturn]] void unexpected();</tt>
<blockquote><p>
Remarks: Called by the implementation when a function exits via an exception not allowed by its <i>exception-specification</i>
(15.5.2)<del>, in effect after evaluating the throw-expression (D.11.1)</del>. May also be called directly by the program.
</p></blockquote>

<blockquote><p>
<i>Effects:</i> <ins>Calls an <tt>unexpected_handler</tt> function. It is unspecified which <tt>unexpected_handler</tt>
function will be called if an exception is active during a call to <tt>set_unexpected</tt>. Otherwise c</ins><del>C</del>alls the current 
<tt>unexpected_handler</tt> function. [<i>Note:</i> A default <tt>unexpected_handler</tt> is always considered a callable handler in 
this context. &mdash; <i>end note</i>] 
</p></blockquote>






<hr>
<h3><a name="2156"></a>2156. Unordered containers' <tt>reserve(n)</tt> reserves for <tt>n-1</tt> elements</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel James <b>Opened:</b> 2012-05-07 <b>Last modified:</b> 2015-02-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
I think that unordered containers' <tt>reserve</tt> doesn't quite do what it should. I'd expect after calling 
<tt>x.reserve(n)</tt> to be able to insert <tt>n</tt> elements without invalidating iterators. But as 
the standard is written (I'm looking at n3376), I think the guarantee only holds for <tt>n-1</tt> elements.
<p/>
For a container with <tt>max_load_factor</tt> of <tt>1</tt>, <tt>reserve(n)</tt> is equivalent to
<tt>rehash(ceil(n/1))</tt>, ie. <tt>rehash(n)</tt>. <tt>rehash(n)</tt> requires that the bucket
count is <tt>&gt;= n</tt>, so it can be <tt>n</tt> (Table 103). The rule is that <tt>insert</tt>
shall not affect the validity of iterators if <tt>(N + n) &lt; z * B</tt> (23.2.5 [unord.req] p15). 
But for this case the two sides of the equation are equal, so <tt>insert</tt> can affect the validity of iterators.
</p>

<p><i>[2013-03-16 Howard comments and provides wording]</i></p>


<p>
Given the following:
</p>

<blockquote><pre>
LF := load_factor()
MLF := max_load_factor()
S := size()
B := bucket_count()

LF == S/B
</pre></blockquote>

<p>
The container has an invariant:
</p>

<blockquote><pre>
LF &lt;= MLF
</pre></blockquote>

<p>
Therefore:
</p>

<blockquote><pre>
MLF &gt;= S/B
S &lt;= MLF * B
B &gt;= S/MLF
</pre></blockquote>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Howard to provide rationale and potentally revised wording.
</p>


<p><i>[2012-02-12 Issaquah : recategorize as P3]</i></p>

<p>
Jonathon Wakely: submitter is Boost.Hash maintainer. Think it's right.
</p>

<p>
Marshall Clow: even if wrong it's more right than what we have now
</p>

<p>
Geoffrey Romer: issue is saying rehash should not leave container in such a state that a notional insertion of zero elements should not trigger a rehash
</p>

<p>
AJM: e.g. if you do a range insert from an empty range
</p>

<p>
AJM: we don't have enough brainpower to do this now, so not priority zero
</p>

<p>
Recategorised as P3
</p>

<p><i>[Teleconference, January 29 2015]</i></p>

<p>
Move to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li>
<p>
In 23.2.5 [unord.req] Table 103 &mdash; Unordered associative container requirements, change the post-condition 
in the row for <code>a.rehash(n)</code> to:
</p>
<blockquote>
Post: <code>a.bucket_count() &gt;<ins>=</ins> a.size() / a.max_load_factor()</code> and <code>a.bucket_count() &gt;= n</code>.
</blockquote>
</li>

<li>
<p>
In 23.2.5 [unord.req]/p15 change
</p>
<blockquote>
The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators if 
<code>(N+n) &lt;<ins>=</ins> z * B</code>, where <code>N</code> is the number of elements in the container 
prior to the insert operation, <code>n</code> is the number of elements inserted, <code>B</code> is the container's 
bucket count, and <code>z</code> is the container's maximum load factor.
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2218"></a>2218. Unclear how containers use <tt>allocator_traits::construct()</tt></h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-11-27 <b>Last modified:</b> 2015-02-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Firstly, 23.2.1 [container.requirements.general]/7 says a container's
allocator is used to obtain memory, but it isn't stated explicitly that the same 
allocator is used to construct and destroy elements, as opposed to a value-initialized 
allocator of the same type.
</p>
<p>
Secondly, 23.2.1 [container.requirements.general]/3 says elements "shall be
constructed using the <tt>allocator_traits&lt;allocator_type&gt;::construct</tt>
function and destroyed using the <tt>allocator_traits&lt;allocator_type&gt;::destroy</tt> function" and
23.2.1 [container.requirements.general]/13 defines <tt>CopyInsertable</tt> etc. in
terms of an allocator <tt>A</tt> which is identical to the container's <tt>allocator_type</tt>.
</p>
<p>
The intent of making <tt>construct()</tt> and <tt>destroy()</tt> function templates was
that containers would be permitted to use <tt>allocator_traits&lt;A&gt;::construct()</tt> instead of
<tt>allocator_traits&lt;allocator_type&gt;::construct()</tt>, where <tt>A</tt> is
<tt>allocator_traits&lt;allocator_type&gt;::rebind_alloc&lt;U&gt;</tt> for some other type
<tt>U</tt>.  This allows node-based containers to store an allocator of the right type for 
allocating nodes and to use the same object to construct elements in aligned storage within 
those nodes, avoiding rebinding and copying the stored allocator every time an element needs
to be constructed.
<p/>
It should be made clear that a possibly-rebound copy of the container's allocator is used for object 
construction.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Jonathan: point 2 in the proposed resolution is definitely needed.
</p>

<p><i>[2014-11-28, Jonathan improves wording]</i></p>

<p>
In the first set of edits to paragraph 3 both pieces inserting "<tt>rebind_alloc&lt;U&gt;::</tt>"
should be replaced by "<tt>rebind_traits&lt;U&gt;::</tt>"
<p/>
Otherwise it implies using the allocator's functions directly, but they might not exist and 
it should be through the rebound traits type.
</p>

<p><i>[Teleconference, January 29 2015]</i></p>

<p>
Moved to Tentatively Ready
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 23.2.1 [container.requirements.general] paragraph 3:</p>
<blockquote><p>
For the components affected by this subclause that declare an <tt>allocator_type</tt>, objects stored in these
components shall be constructed using the <tt>allocator_traits&lt;allocator_type&gt;::<ins>rebind_traits&lt;U&gt;::</ins>construct</tt> 
function and destroyed using the <tt>allocator_traits&lt;allocator_type&gt;::<ins>rebind_traits&lt;U&gt;::</ins>destroy</tt> 
function (20.7.8.2 [allocator.traits.members])<ins>, where <tt>U</tt> is either <tt>allocator_type::value_type</tt> 
or an internal type used by the container</ins>. These functions are called only for the container's element type, 
not for internal types used by the container. [ <i>Note</i>: This means, for example, that a node-based container 
might need to construct nodes containing aligned buffers and call construct to place the element into the buffer. 
&mdash; <i>end note</i> ]
</p></blockquote>
</li>

<li><p>Edit 23.2.1 [container.requirements.general] paragraph 7:</p>
<blockquote><p>
[&hellip;] A copy of this allocator is used for any memory allocation <ins>and element construction</ins> performed, 
by these constructors and by all member functions, during the lifetime of each container object or until the allocator 
is replaced. [&hellip;]
</p></blockquote>
</li>

<li><p>Edit 23.2.1 [container.requirements.general] paragraph 13:</p>
<blockquote><p>
[&hellip;] Given <ins>an allocator type <tt>A</tt> and given</ins> a container type <tt>X</tt> having <del>an 
<tt>allocator_type</tt> identical to <tt>A</tt> and</del> a <tt>value_type</tt> identical to <tt>T</tt> 
<ins>and an <tt>allocator_type</tt> identical to <tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;</tt></ins> 
and given an lvalue <tt>m</tt> of type <tt>A</tt>, a pointer <tt>p</tt> 
of type <tt>T*</tt>, an expression <tt>v</tt> of type (possibly <tt>const</tt>) <tt>T</tt>, and an rvalue <tt>rv</tt> 
of type <tt>T</tt>, the following terms are defined.
<p/>
[&hellip;]
<p/>
[ <i>Note</i>: A container calls <tt>allocator_traits&lt;A&gt;::construct(m, p, args)</tt> to construct an element 
at <tt>p</tt> using <tt>args</tt><ins>, with <tt>m == get_allocator()</tt></ins>. The default <tt>construct</tt> in 
<tt>std::allocator</tt> will call <tt>::new((void*)p) T(args)</tt>, but specialized allocators may choose a 
different definition. &mdash; <i>end note</i> ]
</p></blockquote>
</li>

</ol>






<hr>
<h3><a name="2380"></a>2380. May <tt>&lt;cstdlib&gt;</tt> provide <tt>long ::abs(long)</tt> and <tt>long long ::abs(long long)</tt>?</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-03-31 <b>Last modified:</b> 2015-02-27</p>
<p><b>View all other</b> <a href="lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.5 [depr.c.headers] p3 says:
</p>
<blockquote><p>
[<i>Example</i>: The header <tt>&lt;cstdlib&gt;</tt> assuredly provides its declarations and definitions within the namespace
<tt>std</tt>. It may also provide these names within the global namespace. The header <tt>&lt;stdlib.h&gt;</tt> assuredly
provides the same declarations and definitions within the global namespace, much as in the C Standard. It
may also provide these names within the namespace <tt>std</tt>. &mdash; <i>end example</i>]
</p></blockquote>
<p>
This suggests that <tt>&lt;cstdlib&gt;</tt> may provide <tt>::abs(long)</tt> and <tt>::abs(long long)</tt>. But this seems like 
it might contradict the normative wording of 17.6.1.2 [headers] p4:
</p>
<blockquote><p>
Except as noted in Clauses 18 through 30 and Annex D, the contents of each header <tt>c<em>name</em></tt> shall be the same
as that of the corresponding header <tt><em>name</em>.h</tt>, as specified in the C standard library (1.2) or the C Unicode
TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for
names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace <tt>std</tt>. It is
unspecified whether these names are first declared within the global namespace scope and are then injected
into namespace <tt>std</tt> by explicit using-declarations (7.3.3).
</p></blockquote>
<p>
Note that this allows <tt>&lt;cstdlib&gt;</tt> to provide <tt>::abs(int)</tt>, but does not obviously allow <tt>::abs(long)</tt> 
nor <tt>::abs(long long)</tt>, since they are not part of the header <tt>stdlib.h</tt> as specified in the C standard library.
<p/>
26.8 [c.math] p7 adds signatures <tt>std::abs(long)</tt> and <tt>std::abs(long long)</tt>, but not in a way that seems 
to allow <tt>::abs(long)</tt> and <tt>::abs(long long)</tt> to be provided.
<p/>
I think the right approach here would be to allow <tt>&lt;cstdlib&gt;</tt> to either provide no <tt>::abs</tt> declaration, or 
to provide all three declarations from namespace <tt>std</tt>, but it should not be permitted to provide only <tt>int abs(int)</tt>. 
Suggestion:
<p/>
Change in 17.6.1.2 [headers] p4:
</p>
<blockquote><p>
[&hellip;]. It is unspecified whether these names <ins>(including any overloads added in Clauses 18 through 30 and Annex D)</ins> 
are first declared within the global namespace scope and are then injected into namespace <tt>std</tt> by explicit using-declarations 
(7.3.3).
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Modify 17.6.1.2 [headers] p4 as indicated:</p>

<blockquote><p>
Except as noted in Clauses 18 through 30 and Annex D, the contents of each header <tt>c<em>name</em></tt> shall be the same
as that of the corresponding header <tt><em>name</em>.h</tt>, as specified in the C standard library (1.2) or the C Unicode
TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for
names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace <tt>std</tt>. It is
unspecified whether these names <ins>(including any overloads added in Clauses 18 through 30 and Annex D)</ins> are first 
declared within the global namespace scope and are then injected into namespace <tt>std</tt> by explicit using-declarations (7.3.3).
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2402"></a>2402. <tt>basic_string(const basic_string&amp; str, size_type pos, size_type n = npos)</tt> shouldn't use <tt>Allocator()</tt></h3>
<p><b>Section:</b> 21.4.2 [string.cons] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2015-02-27</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>Discussion:</b></p>
<p>
21.4.2 [string.cons] p3 specifies:
</p>
<blockquote>
<pre>
basic_string(const basic_string&amp; str, size_type pos, size_type n = npos, const Allocator&amp; a = Allocator());
</pre>
<p>
But this implies that <tt>basic_string(str, pos)</tt> and <tt>basic_string(str, pos, n)</tt> use <tt>Allocator()</tt> 
instead of getting an allocator from <tt>str</tt>.
<p/>
21.4.1 [string.require] p3 says "The <tt>Allocator</tt> object used shall be obtained as described in 23.2.1."  
23.2.1 [container.requirements.general] p8 says "Copy constructors for these container types obtain an allocator 
by calling <tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> on the allocator 
belonging to the container being copied.", but this isn't exactly a copy constructor. Then it talks about move constructors 
(which this definitely isn't), and finally says that "All other constructors for these container types take a 
<tt>const allocator_type&amp;</tt> argument. [&hellip;] A copy of this allocator is used for any memory allocation performed".
</p>
</blockquote>

<p><i>[Teleconference, January 29 2015]</i></p>

<p>
Move to NAD, this is not a copy constructor, and so deliberately does not use the <tt>allocator_traits</tt> method for
finding an allocator for copy constructors.
</p>

<p>
This may be a reasonable design change (and change of current behavior) but should be considered more broadly,
and the correct response would be a paper submitted to LEWG.  Closing this issue as NAD should not prejudice
such a paper.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 21.4 [basic.string] p5, class template <tt>basic_string</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 21.4.2, construct/copy/destroy:</i>
[&hellip;]
basic_string(basic_string&amp;&amp; str) noexcept;
<ins>basic_string(const basic_string&amp; str, size_type pos, size_type n = npos);</ins>
basic_string(const basic_string&amp; str, size_type pos, size_type n<del> = npos</del>,
            const Allocator&amp; a<del> = Allocator()</del>);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 21.4.2 [string.cons] around p3 as indicated:</p>

<blockquote>
<pre>
<ins>basic_string(const basic_string&amp; str, 
             size_type pos, size_type n = npos);</ins>
basic_string(const basic_string&amp; str, 
             size_type pos, size_type n<del> = npos</del>,
             const Allocator&amp; a<del> = Allocator()</del>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-5- <i>Effects</i>: Constructs an object of class <tt>basic_string</tt> and determines the effective length <tt>rlen</tt> of the
initial string value as the smaller of <tt>n</tt> and <tt>str.size() - pos</tt>, as indicated in Table 65. <ins>The first constructor 
obtains an allocator by calling <tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> on the 
allocator belonging to <tt>str</tt>.</ins>
<p/>
Table 65 &mdash; <ins><tt>basic_string(const basic_string&amp;, size_type, size_type)</tt> and</ins>
<tt>basic_string(const basic_string&amp;, size_type, size_type, const Allocator&amp;)</tt> effects
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2410"></a>2410. [fund.ts] <tt>shared_ptr&lt;array&gt;</tt>'s constructor from <tt>unique_ptr</tt> should be constrained</h3>
<p><b>Section:</b> X [mods.util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-06-16 <b>Last modified:</b> 2015-02-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
The proposed resolution for LWG <a href="lwg-defects.html#2399">2399</a> doesn't apply cleanly to the Fundamentals TS, but the issue is still present.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4023 in regard to fundamental-ts changes.</p>

<ol>
<li><p>In fundamental-ts, change [mods.util.smartptr.shared.const] p34 as indicated:</p>

<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
-34- <i><del>Requires</del><ins>Remarks</ins></i>: <ins>This constructor shall not participate in overload resolution
unless</ins> <tt>Y*</tt> <del>shall be</del><ins>is</ins> <i>compatible with</i> <tt>T*</tt>. 
<p/>
-35- <i>Effects</i>: Equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt> when <tt>D</tt> is not a reference type, 
otherwise <tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt>.
<p/>
-36- <i>Exception safety</i>: If an exception is thrown, the constructor has no effect. 
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2415"></a>2415. Inconsistency between <tt>unique_ptr</tt> and <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2015-01-27</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt> guarantees that it will not invoke its deleter if it stores
a null pointer, which is useful for deleters that must not be called
with a null pointer e.g.
</p>
<blockquote><pre>
unique_ptr&lt;FILE, int(*)(FILE*)&gt; fptr(file, &amp;::fclose);
</pre></blockquote>
<p>
However, <tt>shared_ptr</tt> does invoke the deleter if it owns a null pointer,
which is a silent change in behaviour when transferring
ownership from <tt>unique_ptr</tt> to <tt>shared_ptr</tt>. That means the following
leads to undefined behaviour:
</p>
<blockquote><pre>
std:shared_ptr&lt;FILE&gt; fp = std::move(fptr);
</pre></blockquote>
<p>
Peter Dimov's suggested fix is to construct an empty <tt>shared_ptr</tt> from a
<tt>unique_ptr</tt> that contains a null pointer.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on eight votes in favour.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] p29 as indicated:</p>
<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: <ins>If <tt>r.get() == nullptr</tt>, equivalent to <tt>shared_ptr()</tt>. Otherwise, if <tt>D</tt> is
not a reference type, equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt>. Otherwise, equivalent to 
<tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt></ins><del>Equivalent to <tt>shared_ptr(r.release(), 
r.get_deleter())</tt> when <tt>D</tt> is not a reference type, otherwise <tt>shared_ptr(r.release(), 
ref(r.get_deleter()))</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2418"></a>2418. [fund.ts] <tt>apply</tt> does not work with member pointers</h3>
<p><b>Section:</b> X [tuple.apply] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2014-07-08 <b>Last modified:</b> 2015-02-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
The definition of <tt>apply</tt> present in &sect;3.2.2 [tuple.apply] prevents this
function template to be used with pointer to members type passed as the first argument.
</p>
<blockquote>
<i>Effects:</i> 
<p/>
[&hellip;]
<p/>
<tt>return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);</tt>
</blockquote>
<p>
This makes this utility inconsistent with other standard library components and limits its usability.
<p/>
We propose to define its functionally in terms of <tt><i>INVOKE</i></tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">N4081</a> 
in regard to fundamental-ts changes.</p>

<ol>
<li><p>Edit &sect;3.2.2 [tuple.apply] paragraph 2:</p>

<blockquote>
<pre>
template &lt;class F, class Tuple&gt;
constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Given the exposition only function
</p>
<blockquote>
<pre>
template &lt;class F, class Tuple, size_t... I&gt;
constexpr decltype(auto) apply_impl(  // <i>exposition only</i>
    F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {
  return <ins><i>INVOKE</i>(</ins>std::forward&lt;F&gt;(f)<del>(</del><ins>, </ins>std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
}
</pre>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2420"></a>2420. <tt>function&lt;void(ArgTypes...)&gt;</tt> does not discard the return value of the target object</h3>
<p><b>Section:</b> 20.9.11.2 [func.wrap.func] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n Berg&eacute; <b>Opened:</b> 2014-07-12 <b>Last modified:</b> 2015-02-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>function&lt;void(ArgTypes...)&gt;</tt> should discard the return value of the target object. This behavior was 
in the original proposal, and it was removed (accidentally?) by the resolution of LWG <a href="lwg-defects.html#870">870</a>.
</p>

<p><i>[2014-10-05 Daniel comments]</i></p>

<p>
This side-effect was indeed not intended by <a href="lwg-defects.html#870">870</a>.
</p>


<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Edit 20.9.11.2 [func.wrap.func] paragraph 2:</p>

<blockquote>
<p>
A callable object <tt>f</tt> of type <tt>F</tt> is <i>Callable</i> for argument types <tt>ArgTypes</tt> and return type 
<tt>R</tt> if the expression <tt><i>INVOKE</i>(f, declval&lt;ArgTypes&gt;()...<del>, R</del>)</tt>, considered as an unevaluated 
operand (Clause 5), is well formed (20.9.2 [func.require])<ins> and, if <tt>R</tt> is not <tt>void</tt>, implicitly 
convertible to <tt>R</tt></ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2448"></a>2448. Non-normative Container destructor specification</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-10-18 <b>Last modified:</b> 2015-02-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to Table 96 &mdash; "Container requirements" the specification:
</p>
<blockquote><p>
note: the destructor is applied to every element of <tt>a</tt>; any
memory obtained is deallocated.
</p></blockquote>
<p>
The initial "note:" can be read as if that part of the specification would not be normative (This note form
differs from footnotes in tables, which have normative meaning).
<p/>
It seems that this initial part of the specification exists since C++98. But comparing with
the similar <a href="https://www.sgi.com/tech/stl/Container.html">SGI Container specification</a> there is no evidence
for that being intended to be non-normative.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4140.
</p>

<ol>
<li><p>Change 23.2.1 [container.requirements.general], Table 96 &mdash; "Container requirements", as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>(&amp;a)-&gt;~X()</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
</td>
<td>
<del>note:</del> the destructor<br/>
is applied to every<br/>
element of <tt>a</tt>; any<br/>
memory obtained is
deallocated.
</td>
<td>
linear
</td>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2454"></a>2454. Add <tt>raw_storage_iterator::base()</tt> member</h3>
<p><b>Section:</b> 20.7.10 [storage.iterator] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-02-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#storage.iterator">active issues</a> in [storage.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#storage.iterator">issues</a> in [storage.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Eric Niebler pointed out that <tt>raw_storage_iterator</tt> should give access
to the <tt>OutputIterator</tt> it wraps.
<p/>
This helps alleviate the exception-safety issue pointed out in the
discussion of LWG <a href="lwg-active.html#2127">2127</a>, as an exception can be caught and then
destructors can be run for the constructed elements in the range
<tt>[begin, raw.base())</tt>
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4140.pdf">N4140</a>.</p>

<ol>
<li><p>Add a new function to the synopsis in 20.7.10 [storage.iterator] p1:</p>

<blockquote><pre>
namespace std {
  template &lt;class OutputIterator, class T&gt;
  class raw_storage_iterator
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
  public:
    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator&lt;OutputIterator,T&gt;&amp; operator*();
    raw_storage_iterator&lt;OutputIterator,T&gt;&amp; operator=(const T&amp; element);
    raw_storage_iterator&lt;OutputIterator,T&gt;&amp; operator++();
    raw_storage_iterator&lt;OutputIterator,T&gt; operator++(int);
    <ins>OutputIterator base() const;</ins>
};
}
</pre></blockquote>
</li>

<li><p>Insert the new function and a new paragraph series after p7:</p>

<blockquote><pre>
<ins>OutputIterator base() const;</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Returns</i>: An iterator of type <tt>OutputIterator</tt> that points to the
same value as <tt>*this</tt> points to.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2455"></a>2455. Allocator default construction should be allowed to throw</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-01-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements]/4 in the 2014-10 WP (N4140), says:
</p>
<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception. <tt>X::pointer</tt> 
and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
<p>
The words "these types" would normally apply only to the previous sentence only, i.e., only to the pointer types.  
However, an alternative reading would be that the allocator constructors themselves cannot throw. The change to 
the <tt>vector</tt> and <tt>string</tt> default constructors, making them unconditionally <tt>noexcept</tt> depends 
on this alternative reading.
<p/>
I believe that the wording in the standard is not intended to forbid throwing default constructors for allocators.  
Indeed, I believe that allocators do not require default constructors and that if they provide a default constructor 
they should be allowed to throw.
<p/>
In addition, the <tt>noexcept</tt> specifications for the <tt>string</tt> and <tt>vector</tt> default constructors 
should be changed to make them conditional.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p4 as indicated:</p>

<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these <ins>pointer</ins> types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
</li>

<li><p>Change 21.4 [basic.string] following p5, class template <tt>basic_string</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(noexcept(Allocator()))</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>
</li>

<li><p>Change 23.3.6.1 [vector.overview] following p2, class template <tt>vector</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(noexcept(Allocator()))</ins> : vector(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : vector(Allocator()) { }
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2463"></a>2463. [fund.ts] Incorrect complexity for <tt>sample()</tt> algorithm</h3>
<p><b>Section:</b> X [alg.random.sample] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2014-12-17 <b>Last modified:</b> 2015-02-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
According to paragraph 10.1 of the Library Fundamentals 1 draft, the complexity of the new 
<tt>std::experimental::sample</tt> template function is O(<tt>n</tt>). Note that <tt>n</tt> is actually 
a parameter of this function, corresponding to the sample size. But both common algorithms for 
sampling, the selection algorithm and the reservoir algorithm, are linear with respect to the 
population size, which is often many orders of magnitude bigger than the sample size.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4335 in regard to fundamental-ts changes.</p>

<ol>
<li><p>Change X [alg.random.sample] p5 to read:</p>

<blockquote>
<p>
-5- <i>Complexity</i>: O(<tt><del>n</del><ins>last - first</ins></tt>). 
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2467"></a>2467. <tt>is_always_equal</tt> has slightly inconsistent default</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], 20.7.8.1 [allocator.traits.types] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2015-01-18 <b>Last modified:</b> 2015-02-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 28 &mdash; "Allocator requirements" says that <tt>X::is_always_equal</tt> has a default value 
of <tt>is_empty&lt;X&gt;</tt>, and this is consistent with the return type description:
</p>
<blockquote>
<p>
Identical to or derived from <tt>true_type</tt> or <tt>false_type</tt>
</p>
</blockquote>
<p>
<tt>is_empty&lt;X&gt;</tt> is guaranteed to be derived from either <tt>true_type</tt> or <tt>false_type</tt>.  
So far so good.
<p/>
20.7.8.1 [allocator.traits.types]/p10 says:
</p>
<blockquote>
<pre>
typedef <i>see below</i> is_always_equal;
</pre>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;::type</tt>.
</p>
</blockquote>
</blockquote>
<p>
This is subtly different than what Table 28 says is the default: <tt>is_empty&lt;Alloc&gt;::type</tt> is 
not <tt>is_empty&lt;Alloc&gt;</tt>, but is rather one of <tt>true_type</tt> or <tt>false_type</tt>.
<p/>
There are two ways to fix this:
</p>
<ol>
<li>
<p>
Change Table 28 to say: <tt>is_empty&lt;X&gt;<ins>::type</ins></tt>.
<p/>
or
</p></li>

<li><p>Change 20.7.8.1 [allocator.traits.types]/p10:</p></li>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;<del>::type</del></tt>.
</p>
</blockquote>
</ol>
<p>
Both options are correct, and I see no reason to prefer one fix over the other. But Table 28 and 
20.7.8.1 [allocator.traits.types]/p10 should be consistent with one another.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change Table 28 to say: <tt>is_empty&lt;X&gt;<ins>::type</ins></tt>.
</p>





</body>
</html>
