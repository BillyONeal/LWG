<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-04-08 at 17:04:44 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760"></a>760. The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2015-03-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2059"></a>2059. C++0x ambiguity problem with <tt>map::erase</tt></h3>
<p><b>Section:</b> 23.4.4 [map] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2011-05-18 <b>Last modified:</b> 2015-03-29</p>
<p><b>View all other</b> <a href="lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>map::erase</tt> (and several related methods) took an iterator in C++03, but take a <tt>const_iterator</tt> 
in C++0x. This breaks code where the map's <tt>key_type</tt> has a constructor which accepts an iterator 
(for example a template constructor), as the compiler cannot choose between <tt>erase(const key_type&amp;)</tt> 
and <tt>erase(const_iterator)</tt>.</p>
<blockquote><pre>
#include &lt;map&gt;

struct X
{
  template&lt;typename T&gt;
  X(T&amp;) {}
};

bool operator&lt;(const X&amp;, const X&amp;) { return false; }

void erasor(std::map&lt;X,int&gt;&amp; s, X x)
{
  std::map&lt;X,int&gt;::iterator it = s.find(x);
  if (it != s.end())
    s.erase(it);
}
</pre></blockquote>

<p><i>[
2011 Bloomington
]</i></p>


<p>
This issue affects only associative container <tt>erase</tt> calls, and is not more general, as these are the
only functions that are also overloaded on another single arguement that might cause confusion - the <tt>erase</tt>
by key method.  The complete resolution should simply restore the <tt>iterator</tt> overload in addition to the
<tt>const_iterator</tt> overload for all eight associative containers. 
</p>

<p>
Proposed wording supplied by Alan Talbot, and moved to Review.
</p>


<p><i>[2012, Kona]</i></p>

<p>
Moved back to Open by post-meeting issues processing group.
</p>
<p>
Pablo very unhappy about case of breaking code with ambiguous conversion between both iterator types.
</p>
<p>
Alisdair strongly in favor of proposed resolution, this change from C++11 bit Chris in real code,
and it took a while to track down the cause.
</p>
<p>
Move to open, bring in front of a larger group
</p>
<p>
Proposed wording from Jeremiah:

<tt>erase(key)</tt> shall not participate in overload resolution if <tt>iterator</tt> is
convertible to <tt>key</tt>.

Note that this means making <tt>erase(key)</tt> a template-method
</p>
<p>
Poll Chris to find out if he already fixed his code, or fixed his library
</p>
<p>
Jeremiah - allow both overloads, but <tt>enable_if</tt> the <tt>const_iterator</tt> form as
a template, requiring <tt>is_same</tt> to match only <tt>const_iterator</tt>.
</p>
<p>
Poll PJ to see if he has already applied this fix?
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: To summarize, we changed a signature and code broke. At what point do we stop and accept breakage in increasingly obscure code? 
VV: libc++ is still broken, but libstdc++ works, so they've fixed this &mdash; perhaps using this PR? [Checks] Yes, libstdc++ 
uses this solution, and has a comment pointing to LWG 2059. AM: This issue hasn't been looked at since Kona. In any case, we 
already have implementation experience now.
<p/>
AM: I'd say let's ship it. We already have implementation experience (libstdc++ and MSVS). MC: And "tentatively ready" lets me 
try to implement this and see how it works. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Editorial note: The following things are different between 23.2.4 [associative.reqmts] p.8 and
23.2.5 [unord.req] p.10. These should probably be reconciled.
</p>
<blockquote>
<ol>
<li>First uses the convention "denotes";  second uses the convention "is".</li>
<li>First redundantly says: "If no such element exists, returns a.end()." in erase table entry, second does not.</li>
</ol>
</blockquote>

<p>
23.2.4 [associative.reqmts] Associative containers
</p>
<p>
8 In Table 102, <tt>X</tt> denotes an associative container class, <tt>a</tt> denotes a value of <tt>X</tt>, <tt>a_uniq</tt>
denotes a value of <tt>X</tt> when <tt>X</tt> supports unique keys, <tt>a_eq</tt> denotes a value of <tt>X</tt> when
<tt>X</tt> supports multiple keys, <tt>u</tt> denotes an identifier, <tt>i</tt> and <tt>j</tt> satisfy input iterator
requirements and refer to elements implicitly convertible to <tt>value_type</tt>, <tt>[i,j)</tt> denotes a valid range,
<tt>p</tt> denotes a valid const iterator to <tt>a</tt>, <tt>q</tt> denotes a valid dereferenceable const iterator to <tt>a</tt>,
<ins><tt>r</tt> denotes a valid dereferenceable iterator to a,</ins> <tt>[q1, q2)</tt> denotes a valid range of const iterators
in <tt>a</tt>, <tt>il</tt> designates an object of type <tt>initializer_list&lt;value_type></tt>, <tt>t</tt> denotes a value of
<tt>X::value_type</tt>, <tt>k</tt> denotes a value of <tt>X::key_type</tt> and <tt>c</tt> denotes a value of type
<tt>X::key_compare</tt>. <tt>A</tt> denotes the storage allocator used by <tt>X</tt>, if any, or
<tt>std::allocator&lt;X::value_type></tt> otherwise, and <tt>m</tt> denotes an allocator of a type convertible to <tt>A</tt>.
</p>

<p>
23.2.4 [associative.reqmts] Associative containers Table 102
</p>
<p>
Add row:
</p>
<ins>
<table border="1">
<tr>
<td><tt>a.erase(r)</tt></td>
<td><tt>iterator</tt></td>
<td>
erases the element pointed to by <tt>r</tt>. Returns an iterator pointing to the element immediately following <tt>r</tt>
prior to the element being erased. If no such element exists, returns <tt>a.end()</tt>.
</td>
<td>amortized constant</td>
</tr>
</table>
</ins>

<p>
23.2.5 [unord.req] Unordered associative containers</p>
<p>
10 In table 103: <tt>X</tt> is an unordered associative container class, <tt>a</tt> is an object of type <tt>X</tt>,
<tt>b</tt> is a possibly const object of type <tt>X</tt>, <tt>a_uniq</tt> is an object of type <tt>X</tt> when
<tt>X</tt> supports unique keys, <tt>a_eq</tt> is an object of type <tt>X</tt> when <tt>X</tt> supports equivalent keys,
<tt>i</tt> and <tt>j</tt> are input iterators that refer to <tt>value_type</tt>, <tt>[i, j)</tt> is a valid range,
<tt>p</tt> and <tt>q2</tt> are valid const iterators to <tt>a</tt>, <tt>q</tt> and <tt>q1</tt> are valid dereferenceable
const iterators to <tt>a</tt>, <ins><tt>r</tt> is a valid dereferenceable iterator to a,</ins> <tt>[q1,q2)</tt> is a
valid range in <tt>a</tt>, <tt>il</tt> designates an object of type <tt>initializer_list&lt;value_type></tt>,
<tt>t</tt> is a value of type <tt>X::value_type</tt>, <tt>k</tt> is a value of type <tt>key_type</tt>, <tt>hf</tt> is a
possibly const value of type <tt>hasher</tt>, <tt>eq</tt> is a possibly const value of type <tt>key_equal</tt>,
<tt>n</tt> is a value of type <tt>size_type</tt>, and <tt>z</tt> is a value of type <tt>float</tt>.
</p>

<p>
23.2.5 [unord.req] Unordered associative containers Table 103
</p>
<p>
Add row:
</p>
<ins>
<table border="1">
<tr>
<td><tt>a.erase(r)</tt></td>
<td><tt>iterator</tt></td>
<td>
Erases the element pointed to by <tt>r</tt>. Returns the iterator immediately following <tt>r</tt> prior to the erasure.
</td>
<td>Average case O(1), worst case O(<tt>a.size()</tt>).</td>
</tr>
</table>
</ins>

<p>
23.4.4.1 [map.overview] Class template map overview p. 2
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.4.5.1 [multimap.overview] Class template multimap overview p. 2
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.4.6.1 [set.overview] Class template set overview p. 2
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.4.7.1 [multiset.overview] Class template multiset overview 
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.5.4.1 [unord.map.overview] Class template unordered_map overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.5.5.1 [unord.multimap.overview] Class template unordered_multimap overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
23.5.6.1 [unord.set.overview] Class template unordered_set overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>


<p>
23.5.7.1 [unord.multiset.overview] Class template unordered_multiset overview p. 3
</p>
<pre>
<ins>iterator erase(iterator position);</ins>
iterator erase(const_iterator position);
size_type erase(const key_type&amp; x);
iterator erase(const_iterator first, const_iterator last);
</pre>

<p>
C.2.13 [diff.cpp03.containers] C.2.12 Clause 23: containers library 
</p>
<p>
23.2.3, 23.2.4
</p>
<p>
Change: Signature changes: from iterator to const_iterator parameters
</p>
<p>
Rationale: Overspecification. Effects: The signatures of the following member functions changed from
taking an iterator to taking a const_iterator:
</p>
<ul>
<li>insert(iter, val) for vector, deque, list, set, multiset, map, multimap</li>
<li>insert(pos, beg, end) for vector, deque, list, forward_list</li>
<li><del>erase(iter) for set, multiset, map, multimap</del></li>
<li>erase(begin, end) for set, multiset, map, multimap</li>
<li>all forms of list::splice</li>
<li>all forms of list::merge</li>
</ul>
<p>
Valid C++ 2003 code that uses these functions may fail to compile with this International Standard.
</p>





<hr>
<h3><a name="2076"></a>2076. Bad <tt>CopyConstructible</tt> requirement in set constructors</h3>
<p><b>Section:</b> 23.4.6.2 [set.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2015-03-29</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.4.6.2 [set.cons] paragraph 4 says: 
</p>

<blockquote><p>
<i>Requires</i>: If the iterator's dereference operator returns an lvalue or a non-const rvalue, 
then <tt>Key</tt> shall be <tt>CopyConstructible</tt>.
</p></blockquote>

<p>
I'm confused why a "non-const rvalue" for the return value of the iterator
would require <tt>CopyConstructible</tt>; isn't that exactly the situation 
when you'd want to apply the move constructor?
<p/>
The corresponding requirement for <tt>multimap</tt> seems better in that regard
([multimap.cons] paragraph 3):
</p>
<blockquote><p>
Requires: If the iterator's dereference operator returns an lvalue or a const rvalue 
<tt>pair&lt;key_type, mapped_type&gt;</tt>, then both <tt>key_type</tt> and mapped_type 
shall be <tt>CopyConstructible</tt>.
</p></blockquote>
<p>
Obviously, if I have a const rvalue, I can't apply the move constructor (which will 
likely attempt modify its argument).
<p/>
Dave Abrahams:
<p/>
I think you are right.
Proposed resolution: drop "non-" from 23.4.6.2 [set.cons] paragraph 3.
</p>

<p><i>[2012, Kona]</i></p>

<p>
The wording is in this area will be affected by Pablo's paper being adopted at this meeting.
Wait for that paper to be applied before visiting this issue - deliberately leave in New
status until the next meeting.
</p>

<p><strong>Proposed resolution from Kona 2012:</strong></p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<p>
Change 23.4.6.2 [set.cons] p3 as follows:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  set(InputIterator first, InputIterator last,
    const Compare&amp; comp = Compare(), const Allocator&amp; = Allocator());
</pre><blockquote><p>
-3- Effects: Constructs an empty set using the specified comparison object and allocator, and inserts
elements from the range [<tt>first,last</tt>).
<p/>
-4- <i>Requires</i>: If the iterator's dereference operator returns an lvalue or a <del>non-</del>const rvalue, 
then <tt>Key</tt> shall be <tt>CopyConstructible</tt>.
<p/>
-5- <i>Complexity</i>: Linear in <tt>N</tt> if the range [<tt>first,last</tt>) is already sorted using 
<tt>comp</tt> and otherwise <tt>N logN</tt>, where <tt>N</tt> is <tt>last - first</tt>.
</p></blockquote></blockquote>
</blockquote>

<p><i>[2014-05-18, Daniel comments]</i></p>

<p>
According to Pablo, the current P/R correctly incorporates the changes from his paper (which was adopted in Kona)
</p>

<p><i>[2014-06-10, STL comments and suggests better wording]</i></p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> was voted into WP 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a> but was 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2283.html">"(reworded)"</a>, introducing the "non-const" damage.
<p/>
N1858 wanted to add this for map:
</p>
<blockquote><p>
<i>Requires</i>: Does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.
</p></blockquote>
<p>
And this for set:
</p>
<blockquote><p>
<i>Requires</i>: <tt>Key</tt> must be <tt>CopyConstructible</tt> only if the dereferenced <tt>InputIterator</tt> returns an lvalue 
or const rvalue.
</p></blockquote>
<p>
(And similarly for multi.)
<p/>
This was reworded to N2284 23.3.1.1 [map.cons]/3 and N2284 23.3.3.1 [set.cons]/4, and it slightly changed over the years into 
N3936 23.4.4.2 [map.cons]/3 and N3936 23.4.6.2 [set.cons]/4.
<p/>
In 2005/2007, this was the best known way to say "hey, we should try to move this stuff", as the fine-grained element requirements 
were taking shape.
<p/>
Then in 2010, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3173.pdf">N3173</a> was 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3226.html">voted</a> into WP 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3225.pdf">N3225</a>, adding the definition of 
<tt>EmplaceConstructible</tt> and modifying the container requirements tables to make the range constructors require 
<tt>EmplaceConstructible</tt>.
<p/>
After looking at this history and double-checking our implementation (where <tt>map</tt>/<tt>set</tt> range construction goes through 
emplacement, with absolutely no special-casing for <tt>map</tt>'s pairs), I am convinced that N3173 superseded N1858 here. 
(Range-<tt>insert()</tt> and the unordered containers are unaffected.)
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to the N3936.</p>

<p>
Change 23.4.6.2 [set.cons] p4 as follows:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  set(InputIterator first, InputIterator last,
    const Compare&amp; comp = Compare(), const Allocator&amp; = Allocator());
</pre><blockquote><p>
-3- Effects: Constructs an empty <tt>set</tt> using the specified comparison object and allocator, and inserts
elements from the range [<tt>first,last</tt>).
<p/>
-4- <i>Requires</i>: If the iterator's indirection operator returns an lvalue or a <del>non-</del>const rvalue, 
then <tt>Key</tt> shall be <tt>CopyInsertible</tt> into <tt>*this</tt>.
<p/>
-5- <i>Complexity</i>: Linear in <tt>N</tt> if the range [<tt>first,last</tt>) is already sorted using 
<tt>comp</tt> and otherwise <tt>N logN</tt>, where <tt>N</tt> is <tt>last - first</tt>.
</p></blockquote></blockquote>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
GR: Do requirements supersede rather than compose [container requirements and per-function requirements]? AM: Yes, they supersede.
<p/>
AM: This looks good. Ready? Agreement. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the N4296.</p>

<ol>
<li><p>
Remove 23.4.4.2 [map.cons] p3:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  map(InputIterator first, InputIterator last,
      const Compare&amp; comp = Compare(), const Allocator&amp; = Allocator());
</pre><blockquote>
<p>
<del>-3- <i>Requires</i>: If the iterator's indirection operator returns an lvalue or a <tt>const</tt> rvalue
<tt>pair&lt;key_type, mapped_type&gt;</tt>, then both <tt>key_type</tt> and <tt>mapped_type</tt> shall be 
<tt>CopyInsertible</tt> into <tt>*this</tt>.</del>
<p/>
[&hellip;]
</p></blockquote></blockquote>
</li>

<li><p>
Remove 23.4.5.2 [multimap.cons] p3:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  multimap(InputIterator first, InputIterator last,
           const Compare&amp; comp = Compare(), 
           const Allocator&amp; = Allocator());
</pre><blockquote>
<p>
<del>-3- <i>Requires</i>: If the iterator's indirection operator returns an lvalue or a <tt>const</tt> rvalue
<tt>pair&lt;key_type, mapped_type&gt;</tt>, then both <tt>key_type</tt> and <tt>mapped_type</tt> shall be 
<tt>CopyInsertible</tt> into <tt>*this</tt>.</del>
<p/>
[&hellip;]
</p>
</blockquote></blockquote>
</li>

<li><p>
Remove 23.4.6.2 [set.cons] p4:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  set(InputIterator first, InputIterator last,
      const Compare&amp; comp = Compare(), const Allocator&amp; = Allocator());
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-4- <i>Requires</i>: If the iterator's indirection operator returns an lvalue or a non-<tt>const</tt> rvalue, then 
<tt>Key</tt> shall be <tt>CopyInsertible</tt> into <tt>*this</tt>.</del>
</p></blockquote></blockquote>
</li>

<li><p>
Remove 23.4.7.2 [multiset.cons] p3:
</p> 
<blockquote><pre>
template &lt;class InputIterator&gt;
  multiset(InputIterator first, InputIterator last,
           const Compare&amp; comp = Compare(), 
           const Allocator&amp; = Allocator());
</pre><blockquote>
<p>
<del>-3- <i>Requires</i>: If the iterator's indirection operator returns an lvalue or a <tt>const</tt> rvalue, then 
<tt>Key</tt> shall be <tt>CopyInsertible</tt> into <tt>*this</tt>.</del>
<p/>
[&hellip;]
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2239"></a>2239. <tt>min/max/minmax</tt> requirements</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-01-26 <b>Last modified:</b> 2015-04-02</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.4.7 [alg.min.max] requires type <tt>T</tt> in <tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt> to be 
<tt>LessThanComparable</tt>, but I don't believe this should be required for the versions that take a <tt>Compare</tt> 
argument.
<p/>
Paragraphs 1 to 4 of 25.4 [alg.sorting] should apply anyway, although I'm not sure about <tt>Compare</tt> 
being required to induce a strict weak ordering here.
<p/>
Further, <tt>min</tt> and <tt>max</tt> also lack formal complexity guarantees.
</p>

<p><i>[2014-06-07 Daniel comments and provides wording]</i></p>


<p>
Certainly, the functions with <tt>Compare</tt> should not impose <tt>LessThanComparable</tt> requirements.
<p/>
In regard to the question whether a strict weak ordering should be required as implied by the <tt>Compare</tt>
requirements, I would like to point out that this is requirement is in fact needed, because the specification of 
the normative <i>Remarks</i> elements (e.g. "Returns the first argument when the arguments are equivalent.") do depend 
on the existence of a <em>equivalence relation</em> that can be relied on and this is also consistent with the same
strict weak ordering requirement that is indirectly imposed by the <tt>LessThanComparable</tt> requirement set for 
functions referring to <tt>operator&lt;</tt> (Let me note that the very same <tt>StrictWeakOrder</tt> language 
concept had intentionally been required for similar reasons during "concept-time" in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>).
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
JY: We have library-wide requirements that <tt>Comp</tt> induce a strict weak ordering.
<p/>
JY/MC: The un-marked-up "Complexity" (p16) is wrong. DK: I'll fix that.
<p/>
DK will update the wording for Lenexa. 
</p>

<p><i>[2015-03-30 Daniel comments]</i></p>

<p>
The Complexity element of p16 is correct, but some others involving <tt>initializer_list</tt> arguments are wrong. 
</p>

<p><i>[2015-04-02 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 25.4.7 [alg.min.max] as indicated:
</p>

<blockquote>
<pre>
template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: <ins>For the first form, type <tt>T</tt> shall be</ins><del>Type <tt>T</tt> is</del> <tt>LessThanComparable</tt> 
(Table 18).
<p/>
-2- <i>Returns</i>: The smaller value.
<p/>
-3- <i>Remarks</i>: Returns the first argument when the arguments are equivalent.
<p/>
<ins>-?- <i>Complexity</i>: Exactly one comparison.</ins>
</p>
</blockquote>

<pre>
template&lt;class T&gt;
  constexpr T min(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare&gt;
  constexpr T min(initializer_list&lt;T&gt; t, Compare comp);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: <tt>T</tt> <del>is <tt>LessThanComparable</tt> and</del><ins>shall be</ins> <tt>CopyConstructible</tt> and 
<tt>t.size() &gt; 0</tt>. <ins>For the first form, type <tt>T</tt> shall be <tt>LessThanComparable</tt>.</ins>
<p/>
-5- <i>Returns</i>: [&hellip;]
<p/>
-6- <i>Remarks</i>: [&hellip;]
<p/>
<ins>-?- <i>Complexity</i>: Exactly <tt>t.size() - 1</tt> comparisons.</ins>
</p>
</blockquote>

<pre>
template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
</pre>
<blockquote>
<p>
-7- <i>Requires</i>: <ins>For the first form, type <tt>T</tt> shall be</ins><del>Type <tt>T</tt> is</del> <tt>LessThanComparable</tt> 
(Table 18).
<p/>
-8- <i>Returns</i>: [&hellip;]
<p/>
-9- <i>Remarks</i>: [&hellip;]
<p/>
<ins>-?- <i>Complexity</i>: Exactly one comparison.</ins>
</p>
</blockquote>

<pre>
template&lt;class T&gt;
  constexpr T max(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare&gt;
  constexpr T max(initializer_list&lt;T&gt; t, Compare comp);
</pre>
<blockquote>
<p>
-10- <i>Requires</i>: <tt>T</tt> <del>is <tt>LessThanComparable</tt> and</del><ins>shall be</ins> <tt>CopyConstructible</tt> and 
<tt>t.size() &gt; 0</tt>. <ins>For the first form, type <tt>T</tt> shall be <tt>LessThanComparable</tt>.</ins>
<p/>
-11- <i>Returns</i>: [&hellip;]
<p/>
-12- <i>Remarks</i>: [&hellip;]
<p/>
<ins>-?- <i>Complexity</i>: Exactly <tt>t.size() - 1</tt> comparisons.</ins>
</p>
</blockquote>

<pre>
template&lt;class T&gt; constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre>
<blockquote>
<p>
-13- <i>Requires</i>: <ins>For the first form, t</ins><del>T</del>ype <tt>T</tt> shall be <tt>LessThanComparable</tt> 
(Table 18).
<p/>
-14- <i>Returns</i>: [&hellip;]
<p/>
-15- <i>Remarks</i>: [&hellip;]
<p/>
-16- <i>Complexity</i>: Exactly one comparison.
</p>
</blockquote>

<pre>
template&lt;class T&gt;
  constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare&gt;
  constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre>
<blockquote>
<p>
-17- <i>Requires</i>: <tt>T</tt> <del>is <tt>LessThanComparable</tt> and</del><ins>shall be</ins> <tt>CopyConstructible</tt> and 
<tt>t.size() &gt; 0</tt>. <ins>For the first form, type <tt>T</tt> shall be <tt>LessThanComparable</tt>.</ins>
<p/>
-18- <i>Returns</i>: [&hellip;]
<p/>
-19- <i>Remarks</i>: [&hellip;]
<p/>
-20- <i>Complexity</i>: At most <tt>(3/2) * t.size()</tt> applications of the corresponding predicate.
</p>
</blockquote>

</blockquote>
</li>

</ol>





<hr>
<h3><a name="2337"></a>2337. <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.8.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2015-03-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.8.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.8.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.8.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.8.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.8.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.8.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2369"></a>2369. <tt>constexpr max(initializer_list)</tt> vs <tt>max_element</tt></h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2014-02-21 <b>Last modified:</b> 2015-03-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As part of the resolution for LWG issue <a href="lwg-defects.html#2350">2350</a>, <tt>max(initializer_list)</tt> was marked as <tt>constexpr</tt>. Looking 
at two implementations of this function (libstdc++ and libc++), both implement it in terms of <tt>max_element</tt>, which is <em>not</em> 
marked as <tt>constexpr</tt>. This is inconsistent and forces some small amount of code duplication in the implementation. Unless we 
remove <tt>constexpr</tt> from this overload of <tt>max</tt>, I believe we should add <tt>constexpr</tt> to <tt>max_element</tt>.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: Can we implement this with the C++14 <tt>constexpr</tt> rules? JM: Yes. AM: Ready? [Yes]
<p/>
Accepted.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>In 25.1 [algorithms.general], header <tt>&lt;algorithm&gt;</tt> synopsis, and 25.4.7 [alg.min.max], change as 
indicated (add <tt>constexpr</tt> to every signature from the first <tt>min_element</tt> to the second <tt>minmax_element</tt>)::</p>

<blockquote>
<pre>
template&lt;class ForwardIterator&gt;
<ins>constexpr</ins> ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
template&lt;class ForwardIterator, class Compare&gt;
<ins>constexpr</ins> ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                      Compare comp);
[&hellip;]
template&lt;class ForwardIterator&gt;
<ins>constexpr</ins> ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template&lt;class ForwardIterator, class Compare&gt;
<ins>constexpr</ins> ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                      Compare comp);
[&hellip;]
template&lt;class ForwardIterator&gt;
<ins>constexpr</ins> pair&lt;ForwardIterator, ForwardIterator&gt;
minmax_element(ForwardIterator first, ForwardIterator last);
template&lt;class ForwardIterator, class Compare&gt;
<ins>constexpr</ins> pair&lt;ForwardIterator, ForwardIterator&gt;
minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2378"></a>2378. Behaviour of standard exception types</h3>
<p><b>Section:</b> 18.6.2.1 [bad.alloc], 18.6.2.2 [new.badlength], 18.7.2 [bad.cast], 18.7.3 [bad.typeid], 18.8.2 [bad.exception] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2014-03-31 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think we have an issue with the specification of some of the standard exception types. 
In particular, several of them have default constructors with remarks to the effect that 
"The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined". 
(In some cases this is contradictory to a further specification of <tt>what()</tt>, which 
is specified to return an implementation-defined NTBS.)
</p>

<p>
<strong>Previous resolution from Andy [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Edit 18.6.2.1 [bad.alloc] p3 as indicated:</p>

<blockquote>
<pre>
bad_alloc() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks</i>: <del>The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined</del><ins><tt>what()</tt> returns an implementation-defined NTBS</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.6.2.2 [new.badlength] p3 as indicated: [<i>Drafting note</i>: Added the Postcondition, since we don't 
say anything else about <tt>bad_array_new_length::what()</tt> &mdash; <i>end of note</i>]</p>

<blockquote>
<pre>
bad_array_new_length() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i><del>Remarks</del><ins>Postcondition</ins></i>: <del>The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined</del><ins><tt>what()</tt> returns an implementation-defined NTBS</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.2 [bad.cast] p3 as indicated:</p>

<blockquote>
<pre>
bad_cast() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.3 [bad.typeid] p3 as indicated:</p>

<blockquote>
<pre>
bad_typeid() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.8.2 [bad.exception] p3 as indicated:</p>

<blockquote>
<pre>
bad_exception() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2014-06-17, Rapperswil]</i></p>

<p>
Jonathan provides alternative wording.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
NJ: I don't know why we need the explict statement about <tt>what()</tt> here, since <tt>bad_array_new_length</tt> 
already derives.<br/> 
AM: yes.<br/> 
NJ: Then "what()" is missing from the synopsis.<br/> 
AM: Yes, that's an error and it needs to be added.
<p/>
Conclusion: Update the wording to add the missing entry in the synopsis. 
<p/>
AM: The issue needs another update; we need to add missing "Remarks". DK updates the paper.<br/> 
AM: Any objections to "tentatively ready"? No objections. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Edit 18.6.2.1 [bad.alloc] p3 as indicated:</p>

<blockquote>
<pre>
bad_alloc() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.6.2.1 [bad.alloc] p5 as indicated:</p>

<blockquote>
<pre>
virtual const char* what() const noexcept;
</pre>
<blockquote>
<p>
-5- <i>Returns</i>: An implementation-defined NTBS.
<p/>
<ins>-?- <i>Remarks</i>: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a <tt>wstring</tt> (21.3, 22.4.1.4).</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Edit class <tt>bad_array_new_length</tt> synopsis 18.6.2.2 [new.badlength] as indicated:</p>

<blockquote>
<pre>
namespace std {
  class bad_array_new_length : public bad_alloc {
  public:
    bad_array_new_length() noexcept;
    <ins>virtual const char* what() const noexcept;</ins>
  };
}
</pre>
</blockquote>
</li>

<li><p>Edit 18.6.2.2 [new.badlength] as indicated:</p>

<blockquote>
<pre>
bad_array_new_length() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined.</del>
</p>
</blockquote>
<pre>
<ins>virtual const char* what() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: An implementation-defined NTBS.</ins>
<p/>
<ins>-?- <i>Remarks</i>: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a <tt>wstring</tt> (21.3, 22.4.1.4).</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.2 [bad.cast] p3 as indicated:</p>

<blockquote>
<pre>
bad_cast() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.3 [bad.typeid] p3 as indicated:</p>

<blockquote>
<pre>
bad_typeid() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.8.2 [bad.exception] p3 as indicated:</p>

<blockquote>
<pre>
bad_exception() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2410"></a>2410. [fund.ts] <tt>shared_ptr&lt;array&gt;</tt>'s constructor from <tt>unique_ptr</tt> should be constrained</h3>
<p><b>Section:</b> X [mods.util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-06-16 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
The proposed resolution for LWG <a href="lwg-defects.html#2399">2399</a> doesn't apply cleanly to the Fundamentals TS, but the issue is still present.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
Unanimous consent. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4023 in regard to fundamental-ts changes.</p>

<ol>
<li><p>In fundamental-ts, change [mods.util.smartptr.shared.const] p34 as indicated:</p>

<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
-34- <i><del>Requires</del><ins>Remarks</ins></i>: <ins>This constructor shall not participate in overload resolution
unless</ins> <tt>Y*</tt> <del>shall be</del><ins>is</ins> <i>compatible with</i> <tt>T*</tt>. 
<p/>
-35- <i>Effects</i>: Equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt> when <tt>D</tt> is not a reference type, 
otherwise <tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt>.
<p/>
-36- <i>Exception safety</i>: If an exception is thrown, the constructor has no effect. 
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2415"></a>2415. Inconsistency between <tt>unique_ptr</tt> and <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2015-01-19</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt> guarantees that it will not invoke its deleter if it stores
a null pointer, which is useful for deleters that must not be called
with a null pointer e.g.
</p>
<blockquote><pre>
unique_ptr&lt;FILE, int(*)(FILE*)&gt; fptr(file, &amp;::fclose);
</pre></blockquote>
<p>
However, <tt>shared_ptr</tt> does invoke the deleter if it owns a null pointer,
which is a silent change in behaviour when transferring
ownership from <tt>unique_ptr</tt> to <tt>shared_ptr</tt>. That means the following
leads to undefined behaviour:
</p>
<blockquote><pre>
std:shared_ptr&lt;FILE&gt; fp = std::move(fptr);
</pre></blockquote>
<p>
Peter Dimov's suggested fix is to construct an empty <tt>shared_ptr</tt> from a
<tt>unique_ptr</tt> that contains a null pointer.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on eight votes in favour.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] p29 as indicated:</p>
<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: <ins>If <tt>r.get() == nullptr</tt>, equivalent to <tt>shared_ptr()</tt>. Otherwise, if <tt>D</tt> is
not a reference type, equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt>. Otherwise, equivalent to 
<tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt></ins><del>Equivalent to <tt>shared_ptr(r.release(), 
r.get_deleter())</tt> when <tt>D</tt> is not a reference type, otherwise <tt>shared_ptr(r.release(), 
ref(r.get_deleter()))</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2418"></a>2418. [fund.ts] <tt>apply</tt> does not work with member pointers</h3>
<p><b>Section:</b> X [tuple.apply] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2014-07-08 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
The definition of <tt>apply</tt> present in &sect;3.2.2 [tuple.apply] prevents this
function template to be used with pointer to members type passed as the first argument.
</p>
<blockquote>
<i>Effects:</i> 
<p/>
[&hellip;]
<p/>
<tt>return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);</tt>
</blockquote>
<p>
This makes this utility inconsistent with other standard library components and limits its usability.
<p/>
We propose to define its functionally in terms of <tt><i>INVOKE</i></tt>.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
DK: We should use the new <tt>std::invoke</tt>.<br/> 
TK: Is this a defect?<br/> 
AM: <tt>std::invoke</tt> goes into C++17, and this is a defect against a TS based on C++14. We can change this later, 
but now leave it as INVOKE.<br/> 
GR: The TS lets you have Editor's Notes, so leave a note to make that change for C++17.
<p/>
[&hellip;]
<p/>
GR: I can't see how we can assume this is part of the design. I cannot believe it was ever intended for this 
design to exclude function pointers.<br/>  
AM: I can give you the exact evolution: We had "apply" as an example explaining the usefulness of <tt>index_sequence</tt>. 
Then someone looked at it and said, "why isn't this in the Standard". NJ to VV: Why are you against useful steps? 
We are trying to converge on a consistent standard across multiple documents. The alternative is to reopen this 
in a later discussion.<br/>  
VV: All I said is that this is not defect, whether or not people like it.<br/>  
AM: So you'd be fine with the issue, but not as a DR?<br/> 
Straw poll: Who's happy to make this tentatively ready as a DR against the Fundamentals TS? 
Lots of agreement, no opposition, 3 neutrals
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">N4081</a> 
in regard to fundamental-ts changes.</p>

<ol>
<li><p>Edit &sect;3.2.2 [tuple.apply] paragraph 2:</p>

<blockquote>
<pre>
template &lt;class F, class Tuple&gt;
constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Given the exposition only function
</p>
<blockquote>
<pre>
template &lt;class F, class Tuple, size_t... I&gt;
constexpr decltype(auto) apply_impl(  // <i>exposition only</i>
    F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {
  return <ins><i>INVOKE</i>(</ins>std::forward&lt;F&gt;(f)<del>(</del><ins>, </ins>std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
}
</pre>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2437"></a>2437. <tt>iterator_traits&lt;OutIt&gt;::reference</tt> can and can't be <tt>void</tt></h3>
<p><b>Section:</b> 24.2.2 [iterator.iterators] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-10-01 <b>Last modified:</b> 2015-03-29</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.iterators">issues</a> in [iterator.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.2.2 [iterator.iterators]/2 requires an <tt>Iterator</tt>'s <tt>*r</tt> to return <tt>reference</tt>, 
i.e. <tt>iterator_traits&lt;X&gt;::reference</tt> according to 24.2.1 [iterator.requirements.general]/11.
<p/>
24.2.4 [output.iterators]/1 requires an <tt>OutputIterator</tt>'s <tt>*r = o</tt> to do its job, 
so <tt>*r</tt> clearly can't return <tt>void</tt>.
<p/>
24.4.1 [iterator.traits]/1 says: "In the case of an output iterator, the types
</p>
<blockquote><pre>
iterator_traits&lt;Iterator&gt;::difference_type
iterator_traits&lt;Iterator&gt;::value_type
iterator_traits&lt;Iterator&gt;::reference
iterator_traits&lt;Iterator&gt;::pointer
</pre></blockquote>
<p>
may be defined as <tt>void</tt>."
<p/>
This is contradictory. I suggest fixing this by moving the offending requirement down from <tt>Iterator</tt> to 
<tt>InputIterator</tt>, and making <tt>Iterator</tt> say that <tt>*r</tt> returns an unspecified type. This will 
have the following effects:
</p>
<ul>
<li><p>Output-only iterators will inherit Iterator's "<tt>*r</tt> returns unspecified" requirement, while 
24.4.1 [iterator.traits]/1 clearly permits reference/etc. to be <tt>void</tt>.</p></li>
<li><p>Input-or-stronger iterators (whether constant or mutable) are unaffected &mdash; they still have to satisfy 
"<tt>*r</tt> returns reference", they're just getting that requirement from <tt>InputIterator</tt> instead of 
<tt>Iterator</tt>.</p></li>
</ul>

<p><i>[2015-02 Cologne]</i></p>

<p>
EF: This is related to <a href="lwg-active.html#2438">2438</a>. MC: I'd like to take up 2438 right after this.
<p/>
AM: Does anyone think this is wrong?
<p/>
GR: Why do we give output iterators to have reference type void? AM: we've mandated that certain output iterators 
define it as void since 1998. GR: Oh OK, I'm satisfied.
<p/>
Accepted. And <a href="lwg-active.html#2438">2438</a> is already Ready. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>In 24.2.2 [iterator.iterators] Table 106 "Iterator requirements" change as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td>
<tt>*r</tt>
</td>
<td>
<del><tt>reference</tt></del><ins>unspecified</ins>
</td>
<td>
<tt></tt>
</td>
<td>
<i>pre</i>: <tt>r</tt> is dereferenceable.
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>
</table>
</blockquote></li>

<li><p>In 24.2.3 [input.iterators] Table 107 "Input iterator requirements" change as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>*a</tt>
</td>
<td>
<ins><tt>reference</tt>,</ins> convertible to <tt>T</tt>
</td>
<td>
<tt></tt>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>
</table>
</blockquote></li>
</ol>






<hr>
<h3><a name="2448"></a>2448. Non-normative Container destructor specification</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-10-18 <b>Last modified:</b> 2015-03-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to Table 96 &mdash; "Container requirements" the specification:
</p>
<blockquote><p>
note: the destructor is applied to every element of <tt>a</tt>; any
memory obtained is deallocated.
</p></blockquote>
<p>
The initial "note:" can be read as if that part of the specification would not be normative (This note form
differs from footnotes in tables, which have normative meaning).
<p/>
It seems that this initial part of the specification exists since C++98. But comparing with
the similar <a href="https://www.sgi.com/tech/stl/Container.html">SGI Container specification</a> there is no evidence
for that being intended to be non-normative.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
NJ: If we fix this, we should also fix it elsewhere. Oh, this is the only place?<br/> 
GR: If this is intended to be different from elsewhere, we should make sure.<br/> 
AM: <tt>valarray</tt> specifies this without the "note:".<br/> 
DK: <tt>valarray</tt> requires trivially destructible types!<br/> 
GR: That's good enough for me.<br/> 
NJ: First time <tt>valarray</tt> has been useful for something!
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4140.
</p>

<ol>
<li><p>Change 23.2.1 [container.requirements.general], Table 96 &mdash; "Container requirements", as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>(&amp;a)-&gt;~X()</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
</td>
<td>
<del>note:</del> the destructor<br/>
is applied to every<br/>
element of <tt>a</tt>; any<br/>
memory obtained is
deallocated.
</td>
<td>
linear
</td>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2454"></a>2454. Add <tt>raw_storage_iterator::base()</tt> member</h3>
<p><b>Section:</b> 20.7.10 [storage.iterator] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-04-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#storage.iterator">active issues</a> in [storage.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#storage.iterator">issues</a> in [storage.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Eric Niebler pointed out that <tt>raw_storage_iterator</tt> should give access
to the <tt>OutputIterator</tt> it wraps.
<p/>
This helps alleviate the exception-safety issue pointed out in the
discussion of LWG <a href="lwg-active.html#2127">2127</a>, as an exception can be caught and then
destructors can be run for the constructed elements in the range
<tt>[begin, raw.base())</tt>
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
NJ: Is this "const" correct [in "base()"]? DK: Yes, we always do that. NJ: And the output iterator is not qualifying in any way? 
AM/DK: That wouldn't make sense. NJ: OK.
<p/>
VV: What did LEWG say about this feature request? In other words, why is this a library issue? AM: LEWG/JY thought this wouldn't 
be a contentious issue.
<p/>
NJ: I really hope the split of LEWG and LWG will be fixed soon, since it's only wasting time. VV: So you want to spend even 
more of your time on discussions that LEWG has?
<p/>
AM: I think this specified correctly. I'm not wild about it. But no longer bothered to stand in its way.
<p/>
GR: Why do we need to repeat the type in "Returns" even though it's part of the synopsis? AM: Good point, but not worth fixing.
<p/>
NJ: Why is "<tt>base()</tt>" for <tt>reverse_iterator</tt> commented with "// explicit"? AM: I guess in 1998 that was the 
only way to say this.
<p/>
AM: So, it's tentatively ready. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4140.pdf">N4140</a>.</p>

<ol>
<li><p>Add a new function to the synopsis in 20.7.10 [storage.iterator] p1:</p>

<blockquote><pre>
namespace std {
  template &lt;class OutputIterator, class T&gt;
  class raw_storage_iterator
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; {
  public:
    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator&lt;OutputIterator,T&gt;&amp; operator*();
    raw_storage_iterator&lt;OutputIterator,T&gt;&amp; operator=(const T&amp; element);
    raw_storage_iterator&lt;OutputIterator,T&gt;&amp; operator++();
    raw_storage_iterator&lt;OutputIterator,T&gt; operator++(int);
    <ins>OutputIterator base() const;</ins>
};
}
</pre></blockquote>
</li>

<li><p>Insert the new function and a new paragraph series after p7:</p>

<blockquote><pre>
<ins>OutputIterator base() const;</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Returns</i>: An iterator of type <tt>OutputIterator</tt> that points to the
same value as <tt>*this</tt> points to.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2455"></a>2455. Allocator default construction should be allowed to throw</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-01-18</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements]/4 in the 2014-10 WP (N4140), says:
</p>
<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception. <tt>X::pointer</tt> 
and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
<p>
The words "these types" would normally apply only to the previous sentence only, i.e., only to the pointer types.  
However, an alternative reading would be that the allocator constructors themselves cannot throw. The change to 
the <tt>vector</tt> and <tt>string</tt> default constructors, making them unconditionally <tt>noexcept</tt> depends 
on this alternative reading.
<p/>
I believe that the wording in the standard is not intended to forbid throwing default constructors for allocators.  
Indeed, I believe that allocators do not require default constructors and that if they provide a default constructor 
they should be allowed to throw.
<p/>
In addition, the <tt>noexcept</tt> specifications for the <tt>string</tt> and <tt>vector</tt> default constructors 
should be changed to make them conditional.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p4 as indicated:</p>

<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these <ins>pointer</ins> types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
</li>

<li><p>Change 21.4 [basic.string] following p5, class template <tt>basic_string</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(noexcept(Allocator()))</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>
</li>

<li><p>Change 23.3.6.1 [vector.overview] following p2, class template <tt>vector</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(noexcept(Allocator()))</ins> : vector(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : vector(Allocator()) { }
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2458"></a>2458. N3778 and new library deallocation signatures</h3>
<p><b>Section:</b> 18.6 [support.dynamic], 18.6.1.1 [new.delete.single], 18.6.1.2 [new.delete.array] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-11-23 <b>Last modified:</b> 2015-03-29</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3778.html">N3778</a> 
added the following sized deallocation signatures to the library:
</p>
<blockquote><pre>
void operator delete(void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;

void operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;
void operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;
</pre></blockquote>
<p>
The former two are an essential part of the proposal. The latter two seem
spurious &mdash; they are not called when <tt>new (std::nothrow) X</tt> fails due to
<tt>X::X()</tt> throwing, because the core language rules for selecting a placement
deallocation function do not consider passing a <tt>size</tt> argument. Instead, the
above would be the matching deallocation functions for:
</p>
<blockquote><pre>
void *operator new(std::size_t size, std::size_t size_again, const std::nothrow_t&amp;) noexcept;
void *operator new[](std::size_t size, std::size_t size_again, const std::nothrow_t&amp;) noexcept;
</pre></blockquote>
<p>
... which don't exist.
<p/>
Since they're not implicitly called, the only other possible use for those
functions would be to perform an explicitly non-throwing deallocation.
But... the first two overloads are already explicitly non-throwing and are
required to be semantically identical to the second two. So there's no
point in making an explicit call to the second pair of functions either.
<p/>
It seems to me that we should remove the <tt>(void*, size_t, nothrow_t)</tt> overloads, because
the core working group decided during the Urbana 2014 meeting, that no change to the core 
language was warranted.
</p>

<p><i>[2014-11-23, Daniel suggests concrete wording changes]</i></p>


<p><i>[2015-02 Cologne]</i></p>

<p>
Nobody can call those overloads, since the nothrow allocation functions cannot throw. JY: Ship it. GR: Should we do due 
diligence and make sure we're deleting what we mean to be deleting? [Some checking, everything looks good.]
<p/>
Accepted.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4140.</p>

<ol>
<li><p>Change 18.6 [support.dynamic], header <tt>&lt;new&gt;</tt> synopsis, as indicated:</p>

<blockquote><pre>
[&hellip;]
void operator delete(void* ptr, std::size_t size) noexcept;
<del>void operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;</del>
[&hellip;]
void operator delete[](void* ptr, std::size_t size) noexcept;
<del>void operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;</del>
[&hellip;]
</pre></blockquote>

</li>

<li><p>Change 18.6.1.1 [new.delete.single], starting before p19, as indicated:</p>
<blockquote><pre>
void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;
<del>void operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;</del>
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-20- <i>Replaceable</i>: a C++ program may define a function with signature <tt>void operator delete(void*
ptr, const std::nothrow_t&amp;) noexcept</tt> that displaces the default version defined by the C++ standard
library. <del>If this function (without <tt>size</tt> parameter) is defined, the program should also define
<tt>void operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept</tt>. If
this function with <tt>size</tt> parameter is defined, the program shall also define the version without the
<tt>size</tt> parameter. [<i>Note</i>: The default behavior below may change in the future, which will require
replacing both deallocation functions when replacing the allocation function. &mdash; <i>end note</i>]</del>
<p/>
[&hellip;]
<p/>
<del>-22- <i>Requires</i>: If present, the <tt>std::size_t size</tt> argument must equal the <tt>size</tt> 
argument passed to the allocation function that returned <tt>ptr</tt>.</del>
<p/>
<del>-23- <i>Required behavior</i>: Calls to <tt>operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;)</tt> 
may be changed to calls to <tt>operator delete(void* ptr, const std::nothrow_t&amp;)</tt> without affecting
memory allocation. [<i>Note</i>: A conforming implementation is for <tt>operator delete(void* ptr, std::size_t size, 
const std::nothrow_t&amp;)</tt> to simply call <tt>operator delete(void* ptr, const std::nothrow_t&amp;)</tt>. &mdash; 
<i>end note</i>]</del>
<p/>
-24- <i>Default behavior</i>: <del><tt>operator delete(void* ptr, std::size_t size, const std::nothrow_t&amp;)</tt> 
calls <tt>operator delete(ptr, std::nothrow)</tt>, and</del> <tt>operator delete(void* ptr, const std::nothrow_t&amp;)</tt> 
calls <tt>operator delete(ptr)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 18.6.1.2 [new.delete.array], starting before p16, as indicated:</p>
<blockquote><pre>
void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;
<del>void operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept;</del>
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-17- <i>Replaceable</i>: a C++ program may define a function with signature <tt>void operator delete[](void*
ptr, const std::nothrow_t&amp;) noexcept</tt> that displaces the default version defined by the C++ standard
library. <del>If this function (without <tt>size</tt> parameter) is defined, the program should also define <tt>void
operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;) noexcept</tt>. If this
function with <tt>size</tt> parameter is defined, the program shall also define the version without the <tt>size</tt>
parameter. [<i>Note</i>: The default behavior below may change in the future, which will require replacing
both deallocation functions when replacing the allocation function. &mdash; <i>end note</i>]</del>
<p/>
[&hellip;]
<p/>
<del>-19- <i>Requires</i>: If present, the <tt>std::size_t size</tt> argument must equal the <tt>size</tt> argument 
passed to the allocation function that returned <tt>ptr</tt>.</del> 
<p/>
<del>-20- <i>Required behavior</i>: Calls to <tt>operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;)</tt> 
may be changed to calls to <tt>operator delete[](void* ptr, const std::nothrow_t&amp;)</tt> without affecting memory allocation. 
[<i>Note</i>: A conforming implementation is for <tt>operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;)</tt> 
to simply call <tt>operator delete[](void* ptr, const std::nothrow_t&amp;)</tt>. &mdash; <i>end note</i>]</del>
<p/>
-21- <i>Default behavior</i>: <del><tt>operator delete[](void* ptr, std::size_t size, const std::nothrow_t&amp;)</tt>
calls <tt>operator delete[](ptr, std::nothrow)</tt>, and</del> <tt>operator delete[](void* ptr, const std::nothrow_t&amp;)</tt> 
calls <tt>operator delete[](ptr)</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2459"></a>2459. <tt>std::polar</tt> should require a non-negative rho</h3>
<p><b>Section:</b> 26.4.7 [complex.value.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-10-22 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Different implementations give different answers for the following code:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;complex&gt;

int main ()
{
  std::cout &lt;&lt; std::polar(-1.0, -1.0) &lt;&lt; '\n';
  return 0;
}
</pre></blockquote>
<p>
One implementation prints:
</p>
<blockquote><pre>
(nan, nan)
</pre></blockquote>
<p>
Another:
</p>
<blockquote><pre>
(-0.243068, 0.243068)
</pre></blockquote>
<p>
Which is correct? Or neither?
<p/>
In <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2013-November/033591.html">this list</a>, 
Howard Hinnant wrote:
</p>
<blockquote class="note">
<p>
I've read this over several times.  I've consulted C++11, C11, and IEC 10967-3.  [snip]
<p/>
I'm finding:
</p>
<ol>
<li><p>The magnitude of a complex number <tt>== abs(c) == hypot(c.real(), c.imag())</tt> and is always non-negative 
(by all three of the above standards).</p></li>
<li><p>Therefore no complex number exists for which <tt>abs(c) &lt; 0</tt>.</p></li>
<li><p>Therefore when the first argument to <tt>std::polar</tt> (which is called <tt>rho</tt>) is negative, no complex number 
can be formed which meets the post-conidtion that <tt>abs(c) == rho</tt>.</p>
</li>
</ol>
<p>
One could argue that this is already covered in 26.4 [complex.numbers]/3, but I think it's worth making explicit.
</p>
</blockquote>

<p><i>[2015-02, Cologne]</i></p>

<p>
Discussion on whether theta should also be constrained.<br/> 
TK: infinite theta doesn't make sense, whereas infinite rho does (theta is on a compact domain, rho is on a non-compact domain).<br/>
AM: We already have a narrow contract, so I don't mind adding further requirements. Any objections to requiring that theta be finite?<br/>
Some more discussion, but general consensus. Agreement that if someone finds the restrictions problematic, they should write 
a proper paper to address how <tt>std::polar</tt> should behave. For now, we allow infinite rho (but not NaN and not negative), 
and require finite theta. 
<p/>
No objections to tentatively ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 26.4.7 [complex.value.ops] around p9 as indicated</p>

<blockquote><pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>rho</tt> shall be non-negative and non-NaN. <tt>theta</tt> shall be finite.</ins>
<p/>
-9- <i>Returns</i>: The complex value corresponding to a complex number whose magnitude is <tt>rho</tt> and whose
phase angle is <tt>theta</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2463"></a>2463. [fund.ts] Incorrect complexity for <tt>sample()</tt> algorithm</h3>
<p><b>Section:</b> X [alg.random.sample] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2014-12-17 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
According to paragraph 10.1 of the Library Fundamentals 1 draft, the complexity of the new 
<tt>std::experimental::sample</tt> template function is O(<tt>n</tt>). Note that <tt>n</tt> is actually 
a parameter of this function, corresponding to the sample size. But both common algorithms for 
sampling, the selection algorithm and the reservoir algorithm, are linear with respect to the 
population size, which is often many orders of magnitude bigger than the sample size.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
AM: I suggest we make this a DR against the Fundamentals TS.<br/> 
GR: Agreed, this is a no-brainer. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4335 in regard to fundamental-ts changes.</p>

<ol>
<li><p>Change X [alg.random.sample] p5 to read:</p>

<blockquote>
<p>
-5- <i>Complexity</i>: O(<tt><del>n</del><ins>last - first</ins></tt>). 
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2467"></a>2467. <tt>is_always_equal</tt> has slightly inconsistent default</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], 20.7.8.1 [allocator.traits.types] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2015-01-18 <b>Last modified:</b> 2015-03-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 28 &mdash; "Allocator requirements" says that <tt>X::is_always_equal</tt> has a default value 
of <tt>is_empty&lt;X&gt;</tt>, and this is consistent with the return type description:
</p>
<blockquote>
<p>
Identical to or derived from <tt>true_type</tt> or <tt>false_type</tt>
</p>
</blockquote>
<p>
<tt>is_empty&lt;X&gt;</tt> is guaranteed to be derived from either <tt>true_type</tt> or <tt>false_type</tt>.  
So far so good.
<p/>
20.7.8.1 [allocator.traits.types]/p10 says:
</p>
<blockquote>
<pre>
typedef <i>see below</i> is_always_equal;
</pre>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;::type</tt>.
</p>
</blockquote>
</blockquote>
<p>
This is subtly different than what Table 28 says is the default: <tt>is_empty&lt;Alloc&gt;::type</tt> is 
not <tt>is_empty&lt;Alloc&gt;</tt>, but is rather one of <tt>true_type</tt> or <tt>false_type</tt>.
<p/>
There are two ways to fix this:
</p>
<ol>
<li>
<p>
Change Table 28 to say: <tt>is_empty&lt;X&gt;<ins>::type</ins></tt>.
<p/>
or
</p></li>

<li><p>Change 20.7.8.1 [allocator.traits.types]/p10:</p></li>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;<del>::type</del></tt>.
</p>
</blockquote>
</ol>
<p>
Both options are correct, and I see no reason to prefer one fix over the other. But Table 28 and 
20.7.8.1 [allocator.traits.types]/p10 should be consistent with one another.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: We should accept the first bullet. GR: Why does <tt>is_empty</tt> even have a type member? AM: All type traits 
have a type member. I agree with DK's preference for the first type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4296.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as presented:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::is_always_equal</tt>
</td>
<td>
Identical to or derived<br/>
from <tt>true_type</tt> or<br/>
<tt>false_type</tt>
</td>
<td>
[&hellip;]
</td>
<td>
<tt>is_empty&lt;X&gt;<ins>::type</ins></tt>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2470"></a>2470. Allocator's <tt>destroy</tt> function should be allowed to fail to instantiate</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2015-03-22 <b>Last modified:</b> 2015-04-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is a spin-off of issue LWG <a href="lwg-active.html#2447">2447</a>: It focuses on the observation that
17.6.3.5 [allocator.requirements] p9 (based on the numbering of working draft N4296) gives 
the template member <tt>construct</tt> more relaxations than the template member <tt>destroy</tt>:
</p>
<blockquote>
<p>
An allocator may constrain the types on which it can be instantiated and the arguments for which its
<tt>construct</tt> member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to <tt>construct</tt> may fail to instantiate.
</p>
</blockquote>
<p>
Construction and destruction of a type <tt>T</tt> are usually intimately related to each other, so it
seems similarly useful to allow the <tt>destroy</tt> member to fail to instantiate for a possible sub-set
of instantiation types.
</p>

<p><i>[2015-04-01 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p9 as indicated:</p>

<blockquote><p>
-8- An allocator may constrain the types on which it can be instantiated and the arguments for which its
<tt>construct</tt> <ins>or <tt>destroy</tt></ins> member<ins>s</ins> may be called. If a type cannot be 
used with a particular allocator, the allocator class or the call to <tt>construct</tt> <ins>or <tt>destroy</tt></ins> 
may fail to instantiate.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2482"></a>2482. [c.strings] Table 73 mentions nonexistent functions</h3>
<p><b>Section:</b> 21.8 [c.strings] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B.Tam <b>Opened:</b> 2015-01-18 <b>Last modified:</b> 2015-04-02</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4296 Table 73 mentions the functions <tt>mbsrtowc</tt> and <tt>wcsrtomb</tt>, which are not defined in ISO C 
or ISO C++. Presumably they should be <tt>mbsrtowcs</tt> and <tt>wcsrtombs</tt> instead. 
</p>

<p><i>[2015-04-02 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to N4296.</p>

<ol>
<li>
<blockquote>
<table border="1" cellpadding="4" rules="groups" style="table-layout:fixed">
<caption>Table 33 &mdash; Potential <tt>mbstate_t</tt> data races</caption>
<tr>
<td>
<tt>mbrlen</tt>
</td>
<td>
<tt>mbrtowc</tt>
</td>
<td>
<tt>mbsrtowc<ins>s</ins></tt>
</td>
<td>
<tt>mbtowc</tt>
</td>
<td>
<tt>wcrtomb</tt>
</td>
</tr>

<tr>
<td>
<tt>wcsrtomb<ins>s</ins></tt>
</td>
<td>
<tt>wctomb</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>






</body>
</html>
