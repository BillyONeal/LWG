<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2016-01-13 at 19:01:36 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2015-03-29</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2192" href="#2192">2192.</a> Validity and return type of <tt>std::abs(0u)</tt> is unclear</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-10-02 <b>Last modified:</b> 2015-11-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In C++03 the following two programs are invalid:
</p>
<ol style="list-style-type:upper-alpha"><li>
<blockquote><pre>
#include &lt;cmath&gt;

int main() {
  std::abs(0u);
}
</pre></blockquote>
</li>
<li>
<blockquote><pre>
#include &lt;cstdlib&gt;

int main() {
  std::abs(0u);
}
</pre></blockquote>
</li>
</ol>
<p>
because none of the <tt>std::abs()</tt> overloads is a best match.
</p>
<p>
In C++11 the additional "sufficient overload" rule from 26.8 [c.math] p11 (see also LWG
<a href="lwg-defects.html#2086">2086</a>) can be read to be applicable to the <tt>std::abs()</tt> overloads as well, which
can lead to the following possible conclusions:
<p/>
<ol>
<li><p>The program</p>
<blockquote><pre>
#include &lt;type_traits&gt;
#include &lt;cmath&gt;

static_assert(std::is_same&lt;decltype(std::abs(0u)), double&gt;(), "Oops");

int main() {
  std::abs(0u); // Calls std::abs(double)
}
</pre></blockquote>
<p>
is required to be well-formed, because of sub-bullet 2 ("[..] or an integer type [..]") of 
26.8 [c.math] p11 (Note that the current resolution of LWG <a href="lwg-defects.html#2086">2086</a> doesn't
fix this problem).
</p>
</li>
<li><p>Any translation unit including both <tt>&lt;cmath&gt;</tt> and <tt>&lt;cstdlib&gt;</tt>
might be ill-formed because of two conflicting requirements for the return type of the overload
<tt>std::abs(int)</tt>.
</p>
</li>
</ol>
</p>

<p>
It seems to me that at least the second outcome is not intended, personally I think that both
are unfortunate: In contrast to all other floating-point functions explicitly listed in sub-clause 
26.8 [c.math], the <tt>abs</tt> overloads have a special and well-defined meaning for 
signed integers and thus have explicit overloads returning a signed integral type. I also believe that 
there is no problem accepting that <tt>std::fabs(0u)</tt> is well-defined with return type <tt>double</tt>, 
because the leading 'f' clearly signals that we have a floating point function here. But the expected 
return type of <tt>std::abs(0u)</tt> seems less than clear to me. A very reasonable answer could be that 
this has the same type as its argument type, alternatively it could be a reasonably chosen signed 
integer type, or a floating point type. It should also be noted, that the corresponding
"generic type function" rule set from C99/C1x in 7.25 p2+3 is restricted to the floating-point functions
from <tt>&lt;math.h&gt;</tt> and <tt>&lt;complex.h&gt;</tt>, so cannot be applied to the <tt>abs</tt>
functions (but to the <tt>fabs</tt> functions!).
<p/>
Selecting a signed integer return type for unsigned input values can also problematic: The directly
corresponding signed integer type would give half of the possible argument values an implementation-defined
result value. Choosing the first signed integer value that can represent all positive values would solve this
problem for <tt>unsigned int</tt>, but there would be no clear answer for the input type <tt>std::uintmax_t</tt>.
</p>
<p>
Based on this it seems to me that the C++03 state in regard to unsigned integer values was the better
situation, alerting the user that this code is ambigious at the moment (This might be change with different core-language
rules as described in N3387).
</p>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Resolution: leave as new and bring it back in Chicago. 
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
This issue also relates to LWG <a href="lwg-active.html#2294">2294</a>
<p/> 
STL: these two issues should be bundled 
<p/>
Stefanus: do what Pete says, and add overloads for unsigned to return directly 
<p/>
STL: agree Consensus that this is an issue 
<p/>
Walter: motion to move to Open 
<p/>
STL: no wording for <a href="lwg-active.html#2294">2294</a> 
<p/>
Stefanus: move to open and note the 2 issues are related and should be moved together 
<p/>
Stefanus: add and define unsigned versions of <tt>abs()</tt>
</p>

<p><i>[2014-02-03 Howard comments]</i></p>

<p>
Defining <tt>abs()</tt> for unsigned integers is a bad idea. Doing so would turn compile time errors into run time errors, 
especially in C++ where we have templates, and the types involved are not always apparent to the programmer at design time.  
For example, consider:
</p>
<blockquote><pre>
template &lt;class Int&gt;
Int
analyze(Int x, Int y)
{
  // ...
  if (std::abs(<span style="color:#C80000;font-weight:bolder">x - y</span>) &lt; threshold)
  {
    // ...
  }
  // ...
}
</pre></blockquote>
<p>
<tt>std::abs(<i>expr</i>)</tt> is often used to ask: Are these two numbers sufficiently close?  When the assumption is that 
the two numbers are signed (either signed integral, or floating point), the logic is sound. But when the same logic is 
accidentally used with an arithmetic type not capable of representing negative numbers, and especially if unsigned overflow 
will silently happen, then the logic is no longer correct:
</p>
<blockquote><pre>
auto i = analyze(20u, 21u);  // Today a compile time error
    // But with <tt>abs(unsigned)</tt> becomes a run time error
</pre></blockquote>
<p>
This is not idle speculation. Search the net for "<tt>abs unsigned</tt>" 
<a href="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=printview&amp;t=35514&amp;start=0">here</a> or 
<a href="http://fischerlaender.de/mysql/surprising-mysql-behaviour-using-unsigned-int">here</a>.
<p/>
In C++11, <tt>chrono</tt> <tt>duration</tt>s and <tt>time_point</tt>s are allowed to be based on unsigned integers. Taking the 
absolute value of the difference of two such <tt>time_point</tt>s would be easy to accidentally do (say in code templated on 
<tt>time_point</tt>s), and would certainly be a logic bug, caught at compile time unless we provide the error prone <tt>abs(unsigned)</tt>.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
GR: Do we want to make the changes to both <tt>&lt;cmath&gt;</tt> and <tt>&lt;cstdlib&gt;</tt>?<br/> 
AM: I think so; we should provide consistent overloads.<br/> 
GR: Then we're imposing restrictions on what users put in the global namespace.<br/> 
AM: I'm not so worried about that. Users already know not to use C library names.<br/>
VV: So what are we going to do about unsigned integers? AM: We will say that they are ill-formed.<br/>
AM: Does anyone volunteer to send updated wording to Daniel? GR, can you do it? GR: Sure.<br/>
GR: To clarify: we want to make unsigned types ill-formed?<br/> 
AM: With promotion rank at least <tt>unsigned int</tt>.<br/>
GR: And NL suggests to just list those types.
<p/>
Conclusion: Merge the resolution into a single issue. 
</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<blockquote class = "note">
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change 26.8 [c.math] p11 as indicated:</p>
<blockquote><p>
-11- Moreover<ins>, except for the <tt>abs</tt> functions</ins>, there shall be additional overloads sufficient to ensure:
<p/>
[&hellip;]
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey Romer provides improved wording]</i></p>

<p>
In the following I've drafted combined wording to resolve LWG <a href="lwg-active.html#2192">2192</a> and <a href="lwg-active.html#2294">2294</a>. Note that the first 
two paragraphs are taken verbatim from the P/R of LWG <a href="lwg-active.html#2294">2294</a>, but the third is newly drafted:
</p>

<p><i>[2015-05-05 Lenexa: Howard to draft updated wording]</i></p>


<p><i>[2015-09-11: Howard updated wording]</i></p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>HH: abs() for unsigned types is really dangerous. People often use abs(x - y), which would be a disaster. </p>
<p>TK: That's why you need a two-argument abs_diff(x, y), especially for unsigned types. </p>
<p>JW: Lawrence has a proposal for abs_diff in the mailing.</p>
<p>STL: As an alternative to considering promotions, I would just ban all unsigned types, even unsigned char.</p>
<p>STL: Does the PR change any implementation? Is the final paragraph just a consequence? </p><p>HH: It's a consequence. It could just be a note. </p><p>VV: Ship it as is.</p>
<p>STL: Editorial: capitalize the first letter in the Note.</p>
<p>Move to Tentatively ready.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Insert the following new paragraphs after 26.8 [c.math] p7:</p>
<blockquote>
<p>
-6- In addition to the <tt>int</tt> versions of certain math functions in <tt>&lt;cstdlib&gt;</tt>, C++ adds <tt>long</tt> 
and <tt>long long</tt> overloaded versions of these functions, with the same semantics.
<p/>
-7- The added signatures are:
</p>
<blockquote>
<pre>
long abs(long); <i>// labs()</i>
long long abs(long long); <i>// llabs()</i>
ldiv_t div(long, long); <i>// ldiv()</i>
lldiv_t div(long long, long long); <i>// lldiv()</i>
</pre>
</blockquote>
<p>
<ins>-?- To avoid ambiguities, C++ also adds the following overloads of <tt>abs()</tt> to <tt>&lt;cstdlib&gt;</tt>, 
with the semantics defined in <tt>&lt;cmath&gt;</tt>:</ins>
</p>
<blockquote>
<pre>
<ins>float abs(float);
double abs(double);
long double abs(long double);</ins>
</pre>
</blockquote>
<p>
<ins>-?- To avoid ambiguities, C++ also adds the following overloads of <tt>abs()</tt> to <tt>&lt;cmath&gt;</tt>, 
with the semantics defined in <tt>&lt;cstdlib&gt;</tt>:</ins>
</p>
<blockquote>
<pre>
<ins>int abs(int);
long abs(long);
long long abs(long long);</ins>
</pre>
</blockquote>
<p>
<ins>-?- If <tt>abs()</tt> is called with an argument of type <tt>X</tt> for which
<tt>is_unsigned&lt;X&gt;::value</tt> is <tt>true</tt> and if <tt>X</tt> cannot be converted to
<tt>int</tt> by integral promotion (4.5 [conv.prom]), the program is ill-formed.
[<i>Note</i>: arguments that can be promoted to <tt>int</tt> are permitted for
compatibility with C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.8.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2015-03-29</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.8.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.8.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.8.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.8.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.8.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.8.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2450" href="#2450">2450.</a> <tt>(greater|less|greater_equal|less_equal)&lt;void&gt;</tt> do not yield a total order for pointers</h3>
<p><b>Section:</b> 20.9.6 [comparisons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz <b>Opened:</b> 2014-10-30 <b>Last modified:</b> 2015-11-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>less&lt;void&gt;::operator(t, u)</tt> (and the same applies to the rest of <tt>void</tt> specializations for standard 
comparison function objects) returns <tt>t &lt; u</tt> even if <tt>t</tt> and <tt>u</tt> are pointers, which by 
5.9 [expr.rel]/3 is undefined except if both pointers point to the same array or object. This might be 
regarded as a specification defect since the intention of N3421 is that <tt>less&lt;&gt;</tt> can substitute for 
<tt>less&lt;T&gt;</tt> in any case where the latter is applicable. <tt>less&lt;void&gt;</tt> can be rewritten in 
the following manner to cope with pointers:
</p>
<blockquote><pre>
template&lt;&gt; struct less&lt;void&gt;
{

  typedef <i>unspecified</i> is_transparent;

  template &lt;class T, class U&gt;
  struct pointer_overload : std::is_pointer&lt;std::common_type_t&lt;T, U&gt;&gt;
  {};

  template &lt;
    class T, class U,
    typename std::enable_if&lt;!pointer_overload&lt;T, U&gt;::value&gt;::type* = nullptr
  &gt;
  auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u))
  {
    return std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u);
  } 

  template &lt;
    class T, class U,
    typename std::enable_if&lt;pointer_overload&lt;T, U>::value>::type* = nullptr
  &gt;
  auto operator()(T&amp;&amp; t, U&amp;&amp; u) const
    -&gt; decltype(std::declval&lt;std::less&lt;std::common_type_t&lt;T, U&gt;&gt;&gt;()(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u)))
  {
    std::less&lt;std::common_type_t&lt;T, U&gt;&gt; l;
    return l(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
  }

};
</pre></blockquote>

<blockquote class="note">
<p>
This wording is relative to N4140.
</p>

<ol>
<li><p>Change 20.9.6 [comparisons] p14 as indicated:</p>
<blockquote><p>
-14- For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the specializations 
for any pointer type yield a total order, even if the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, 
<tt>&gt;=</tt> do not. <ins>For template specializations <tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, 
<tt>greater_equal&lt;void&gt;</tt>, and <tt>less_equal&lt;void&gt;</tt>, the call operator with arguments whose common 
type <tt><i>CT</i></tt> is a pointer yields the same value as the corresponding comparison function object class 
specialization for <tt><i>CT</i></tt>.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-02, Cologne]</i></p>

<p>
AM: Is there any way this will be resolved elsewhere? VV: No. AM: Then we should bite the bullet and deal with it here.
<p/>
MC: These diamond operators are already ugly. Making them more ugly isn't a big problem.
<p/>
JY found some issue with types that are convertible, and will reword. 
<p/>
Jeffrey suggests improved wording.
</p>

<p><i>[2015-05, Lenexa]</i></p>

<p>
STL: when diamond functions designed, this was on purpose<br/>
STL: this does go against the original design<br/>
STL: library is smarter and can give a total order<br/>
MC: given that the original design rejected this, give back to LEWG<br/>
STL: original proposal did not talk about total order<br/>
STL: don't feel strongly about changing the design<br/>
STL: no objections to taking this issue with some wording changes if people want it<br/>
MC: not happy with wording, comparing pointers &mdash; what does that mean?<br/>
STL: needs careful attention to wording<br/>
STL: want to guarantee that <tt>nullptr</tt> participates in total ordering<br/>
STL: all hooks into composite pointer type<br/>
MC: move from new to open with better wording<br/>
STL: to check updates to issue after Lenexa 
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
MC: STL on the hook to update. He's shipping something today so not here.<br/>
MC: also add link to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4229.pdf">N4229</a><br/>
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>
STL was on the hook for wording, but STL: I don't care. The architecture on which this is an issue does not exist.<br/>
STL: We will also need to incorporate nullptr. TK: I think that's implied, since the wording is in terms of the resulting operation, not the deduced types. <br/>
STL: Seems legit. MC: I guess I'm OK with this. TK: I'm weakly in favour, so that we can get people to use transparent comparators without worrying. <br/>
STL: There's no change to implementations.<br/>
Move to Tentatively ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4296.
</p>

<ol>
<li><p>Change 20.9.6 [comparisons] p14 as indicated:</p>
<blockquote><p>
-14- For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the specializations 
for any pointer type yield a total order, even if the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, 
<tt>&gt;=</tt> do not. <ins>For template specializations <tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, 
<tt>greater_equal&lt;void&gt;</tt>, and <tt>less_equal&lt;void&gt;</tt>, if the call operator calls a built-in operator 
comparing pointers, the call operator yields a total order.</ins>
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2520" href="#2520">2520.</a> N4089 broke initializing <tt>unique_ptr&lt;T[]&gt;</tt> from a <tt>nullptr</tt></h3>
<p><b>Section:</b> 20.8.1.3.1 [unique.ptr.runtime.ctor] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-07-19 <b>Last modified:</b> 2015-11-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the wording in 20.8.1.3.1 [unique.ptr.runtime.ctor]/1,
this won't work:
</p>
<blockquote><pre>
unique_ptr&lt;int[], DeleterType&gt; x{nullptr, DeleterType{}};
</pre></blockquote>
<p>
<tt>U</tt> is not the same type as <tt>pointer</tt>, so the first bullet will not do.<br/>
<tt>U</tt> is not a pointer type, so the second bullet will not do.
<p/>
An easy fix would be to add a new bullet after the first bullet, like so:
</p>
<ul>
<li><p><tt>U</tt> is the same type as <tt>pointer</tt>, or</p></li>
<li><p><ins><tt>U</tt> is <tt>nullptr_t</tt>, or</ins></p></li>
<li><p><tt>pointer</tt> is the same type as <tt>element_type*</tt>, [&hellip;]</p></li>
</ul>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>MC: Is it the right fix? </p>
<p>GR: It'd be awefully surprising if we had an interface that accepts null pointer values but not std::nullptr_t. I think the PR is good.</p>
<p>STL: Are any of the assignments and reset affected? [No, they don't operate on explicit {pointer, deleter} pairs.]</p>
<p>VV: This is already shipping, has been implemented, has been tested and works fine.</p>
<p>Move to Tentatively ready.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Change 20.8.1.3.1 [unique.ptr.runtime.ctor] as indicated:</p>
<blockquote>
<pre>
template &lt;class U&gt; explicit unique_ptr(U p) noexcept;
template &lt;class U&gt; unique_ptr(U p, <i>see below</i> d) noexcept;
template &lt;class U&gt; unique_ptr(U p, <i>see below</i> d) noexcept;
</pre>
<blockquote>
<p>
-1- These constructors behave the same as the constructors that take a <tt>pointer</tt> parameter in the primary
template except that they shall not participate in overload resolution unless either
</p>
<ul>
<li><p><tt>U</tt> is the same type as <tt>pointer</tt>, or</p></li>
<li><p><ins><tt>U</tt> is <tt>nullptr_t</tt>, or</ins></p></li>
<li><p><tt>pointer</tt> is the same type as <tt>element_type*</tt>, <tt>U</tt> is a pointer type <tt>V*</tt>, and 
<tt>V(*)[]</tt> is convertible to <tt>element_type(*)[]</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2522" href="#2522">2522.</a> [fund.ts.v2] Contradiction in <tt>set_default_resource</tt> specification</h3>
<p><b>Section:</b> X [memory.resource.global] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-28 <b>Last modified:</b> 2015-11-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
[memory.resource.global]/p7-8 says that the effects of <tt>set_default_resource(r)</tt> are
</p>
<blockquote><p>
If <tt>r</tt> is non-null, sets the value of the default memory resource pointer to <tt>r</tt>, otherwise sets the default memory 
resource pointer to <tt>new_delete_resource()</tt>.
</p></blockquote>
<p>
and the operation has the postcondition 
</p>
<blockquote><p>
<tt>get_default_resource() == r</tt>.
</p></blockquote>
<p>
When <tt>r</tt> is null, however, the postcondition cannot be met, since the call sets the default memory resource pointer to 
<tt>new_delete_resource()</tt>, and so <tt>get_default_resource()</tt> would return the value of <tt>new_delete_resource()</tt>, which 
is obviously not null and so cannot compare equal to <tt>r</tt>.
</p>

<strong>Previous resolution from Tim Song [SUPERSEDED]:</strong>
<blockquote class = "note">
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">N4480</a>.
</p>

<ol>
<li><p>Edit [memory.resource.global]/p8 as follows:</p>
<blockquote>
<pre>
<em>-6-</em> memory_resource* set_default_resource(memory_resource* r) noexcept;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: If <tt>r</tt> is non-null, sets the value of the default memory resource pointer to <tt>r</tt>, 
otherwise sets the default memory resource pointer to <tt>new_delete_resource()</tt>. 
<p/>
-8- <i>Postconditions</i>: <tt>get_default_resource() == r</tt> <ins>if <tt>r</tt> is non-null; otherwise, 
<tt>get_default_resource() == new_delete_resource()</tt></ins>. 
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-09-15 Geoffrey Romer comments and suggests alternative wording]</i></p>

<p>
 Let's just strike X [memory.resource.global]/p8. The problem is that p8 is restating p7 incorrectly, 
 but the solution is not to restate p7 correctly, it's to stop trying to restate p7 at all.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Move to Tentatively ready</p>

<p><i>[2015-10-26]</i></p>

<p>Daniel adjusts wording to lib. fund. v2.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit [memory.resource.global]/p8 as follows:</p>
<blockquote>
<pre>
<em>-6-</em> memory_resource* set_default_resource(memory_resource* r) noexcept;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: If <tt>r</tt> is non-null, sets the value of the default memory resource pointer to <tt>r</tt>, 
otherwise sets the default memory resource pointer to <tt>new_delete_resource()</tt>. 
<p/>
<del>-8- <i>Postconditions</i>: <tt>get_default_resource() == r</tt>.</del>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2539" href="#2539">2539.</a> [fund.ts.v2] <tt>invocation_trait</tt> definition definition doesn't work for surrogate call functions</h3>
<p><b>Section:</b> 20.10.7.6 [meta.trans.other] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2015-09-25 <b>Last modified:</b> 2015-11-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
In Library Fundamentals 2 (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>) 
3.3.2p3 [meta.trans.other], the definition of invocation traits for a class object <tt>f</tt> considers when <tt>f</tt> 
is called via a function call operator that is matched by the arguments but ignores the possibility that <tt>f</tt> 
may be called via a surrogate call function (C++14 13.3.1.1.2 [over.call.object] p2), in which case, the definition 
of the invocation parameters may be either incorrect or even unsatisfiable.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>AM: Do we have this trait yet? JW: No, it cannot be implemented without compiler support.</p>
<p>Move to tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.</p>

<ol>
<li><p>In Library Fundamentals 2, change [meta.trans.other] as indicated:</p>
<blockquote>
<p>
-3- Within this section, define the <i>invocation parameters</i> of <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> as follows, 
in which <tt>T1</tt> is the possibly <i>cv</i>-qualified type of <tt>t1</tt> and <tt>U1</tt> denotes <tt>T1&amp;</tt> if 
<tt>t1</tt> is an lvalue or <tt>T1&amp;&amp;</tt> if <tt>t1</tt> is an rvalue: 
</p>
<ul>
<li><p>[&hellip;]</p></li>
<li><p>If <tt>f</tt> is a class object, the <i>invocation parameters</i> are the parameters matching <tt>t1, ..., tN</tt> 
of the best viable function (C++14 &sect;13.3.3) for the arguments <tt>t1, ..., tN</tt> among the function call operators 
<ins>and surrogate call functions</ins> of <tt>f</tt>. </p></li>
<li><p>[&hellip;]</p></li>
</ul>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2545" href="#2545">2545.</a> Simplify wording for <tt>bind</tt> without explicitly specified return type</h3>
<p><b>Section:</b> 20.9.10.3 [func.bind.bind] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2015-10-05 <b>Last modified:</b> 2016-01-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of the <tt>bind</tt> overload without return type as of 20.9.10.3 [func.bind.bind] p3, 
uses the following expression <tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., 
std::forward&lt;VN&gt;(vN), result_of_t&lt;FD <i>cv</i> &amp; (V1, V2, ..., VN)&gt;)</tt> to describe effects of 
invocation of returned function.
<p/>
According to the definition from 20.10.7.6 [meta.trans.other] <tt>result_of_t&lt;FD cv &amp; (V1, V2, ..., VN)></tt> 
is equivalent to 
<tt>decltype(INVOKE(declval&lt;FD <i>cv</i> &amp;&gt;(), declval&lt;V1&gt;(), declval&lt;V2&gt;(), ..., declval&lt;VN&gt;()))</tt>. 
When combined with the definition of <tt><i>INVOKE</i></tt> from 20.9.2 [func.require] p2, the expression 
<tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN), 
result_of_t&lt;FD <i>cv</i> &amp; (V1, V2, ...., VN)&gt;)</tt> is equivalent to <tt><i>INVOKE</i>(fd, 
std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN))</tt> implicitly converted 
to <tt>decltype(<i>INVOKE</i>(declval&lt;FD <i>cv</i> &amp;&gt;(), declval&lt;V1&gt;(), declval&lt;V2&gt;(), ..., 
declval&lt;VN&gt;()))</tt> (itself).
<p/>
It is also worth to notice that specifying the result type (<tt>R</tt>) in <tt><i>INVOKE</i>(f, args..., R)</tt> does 
not in any way affect the selected call. As a consequence the use of wording of the form
<tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN), 
result_of_t&lt;FD <i>cv</i> &amp; (V1, V2, ..., VN)&gt;)</tt> does not and cannot lead to call of different overload 
than one invoked by <tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., 
std::forward&lt;VN&gt;(vN))</tt>.
<p/>
In summary the form <tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., 
std::forward&lt;VN&gt;(vN), result_of_t&lt;FD <i>cv</i> &amp; (V1, V2, ..., VN)&gt;)</tt> is a convoluted way of expressing 
<tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN))</tt>, 
that only confuses reader.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: I most recently reimplemented std::bind from scratch, and I think this issue is correct and the solution is good.</p>
<p>Move to Tentatively ready.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li>
<p>Change 20.9.10.3 [func.bind.bind] p3 as indicated:</p>
<blockquote>
<pre>
template&lt;class F, class... BoundArgs&gt;
<i>unspecified</i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Returns</i>: A forwarding call wrapper <tt>g</tt> with a weak result type (20.9.2). The effect of 
<tt>g(u1, u2, ..., uM)</tt> shall be <tt><i>INVOKE</i>(fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), 
..., std::forward&lt;VN&gt;(vN)<del>, result_of_t&lt;FD <i>cv</i> &amp; (V1, V2, ..., VN)&gt;</del>)</tt>, where <del><tt><i>cv</i></tt>
represents the <i>cv</i>-qualifiers of <tt>g</tt> and</del> the values and types of the bound arguments <tt>v1, v2, ..., vN</tt> 
are determined as specified below. The copy constructor and move constructor of the forwarding call wrapper shall 
throw an exception if and only if the corresponding constructor of <tt>FD</tt> or of any of the types <tt>TiD</tt> 
throws an exception.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
