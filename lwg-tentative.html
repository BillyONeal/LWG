<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2017-03-12 at 23:03:26 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2017-02-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.11.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2017-02-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.11.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.11.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2692" href="#2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 17.4.2.1.4 [bitmask.types] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2017-02-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2717" href="#2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.13.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2017-02-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.13.4 [allocator.adaptor.members] p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2803" href="#2803">2803.</a> <tt>hash</tt> for arithmetic, pointer and standard library types should not throw</h3>
<p><b>Section:</b> 20.14.15 [unord.hash] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 140</b>
<p/>
Specializations of <tt>std::hash</tt> for arithmetic, pointer, 
and standard library types should not be allowed to throw. The 
constructors, assignment operators, and function call operator 
should all be marked as <tt>noexcept</tt>.
It might be reasonable to consider making this a 
binding requirement on user specializations of the 
<tt>hash</tt> template as well (in p1) but that may be big a 
change to make at this stage.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2, Nico to provide wording.</p>

<p><i>[2017-02-07, Nico comments]</i></p>

<p>Concrete wording is provided in <a href="http://wg21.link/p0599">P0599</a>.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0599R0.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2863" href="#2863">2863.</a> Undo <tt>default_order</tt> changes of maps and sets</h3>
<p><b>Section:</b> 20.14.16 [func.default.traits] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses FI 18</b></p>

<p>It was thought that using <tt>default_order</tt> as the default comparison for maps and sets was not 
abi-breaking but this is apparently not the case.</p>

<p>
Proposed change:
</p>
<p>
Revert the change to the default comparison of maps and sets.
</p>

<p><i>[2016-10 Issaquah]</i></p>

<p>STL and AM want to revert whole paper.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved reverting P0181R1.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2869" href="#2869">2869.</a> Deprecate sub-clause [locale.stdcvt]</h3>
<p><b>Section:</b> 22.5 [locale.stdcvt] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#locale.stdcvt">active issues</a> in [locale.stdcvt].</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.stdcvt">issues</a> in [locale.stdcvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB 57</b></p>

<p>The contents of <tt>&lt;codecvt&gt;</tt> are underspecified, and will take a reasonable 
amount of work to identify and correct all of the issues. There appears to be a general 
feeling that this is not the best way to address unicode transcoding in the first 
place, and this library component should be retired to Annex D, along side 
<tt>&lt;strstream&gt;</tt>, until a suitable replacement is standardized.</p>

<p>
Proposed change:
</p>
<p>
Deprecate and move the whole of clause 22.5 [locale.stdcvt] to Annex D.
</p>

<p><i>[2017-02 pre-Kona]</i></p>

<p>LEWG says Accept.</p>


<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0618R0.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2887" href="#2887">2887.</a> Revert the changes from P0156R0: variadic <tt>lock_guard</tt></h3>
<p><b>Section:</b> 99 [section.ref.here] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Finland, Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#section.ref.here">active issues</a> in [section.ref.here].</p>
<p><b>View all other</b> <a href="lwg-index.html#section.ref.here">issues</a> in [section.ref.here].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 8, GB 61</b>

<p>The class template <tt>lock_guard</tt> was made variadic. This is abi-breaking, and confusing because one-argument 
<tt>lock_guard</tt>s have a typedef <tt>mutex_type</tt> but <tt>lock_guard</tt>s with more than one argument don't. There's 
no need to try to shoehorn this functionality into one type.</p>
<p>Proposed change: Revert the changes to <tt>lock_guard</tt>, and introduce a new variadic class template 
<tt>vlock_guard</tt> that doesn't have the <tt>mutex_type</tt> typedef at all.</p>

<p><i>[2017-02-02, Marshall notes]</i></p>

<p>This was the subject of intense discussion in Issaquah, and a joint LEG/LEWG session agreed on this approach.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0156R2.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2888" href="#2888">2888.</a> Variables of library tag types need to be inline variables</h3>
<p><b>Section:</b> 20 [utilities], 30 [thread] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utilities">active issues</a> in [utilities].</p>
<p><b>View all other</b> <a href="lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 9</b>

<p>The variables of library tag types need to be inline variables. Otherwise, using them in inline functions in multiple 
translation units is an ODR violation.</p>
<p>Proposed change: Make <tt>piecewise_construct</tt>, <tt>allocator_arg</tt>, <tt>nullopt</tt>, (the <tt>in_place_tags</tt> 
after they are made regular tags), <tt>defer_lock</tt>, <tt>try_to_lock</tt> and <tt>adopt_lock</tt> inline.</p>

<p><i>[2017-02-03, Marshall notes]</i></p>

<p>See also GB 28 (LWG <a href="lwg-active.html#2889">2889</a>)</p>

<p><i>[2017-02-25, Daniel comments]</i></p>

<p>
There will be the paper p0607r0 provided for the Kona meeting that solves this issue.
</p>
<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by p0607r0.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2889" href="#2889">2889.</a> Mark <tt>constexpr</tt> global variables as <tt>inline</tt></h3>
<p><b>Section:</b> 20 [utilities], 20.19 [execpol] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utilities">active issues</a> in [utilities].</p>
<p><b>View all other</b> <a href="lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 28</b>

<p>The C++ standard library provides many <tt>constexpr</tt> global variables. These all create the risk of ODR violations 
for innocent user code. This is especially bad for the new <tt>ExecutionPolicy</tt> algorithms, since their constants are 
always passed by reference, so any use of those algorithms from an inline function results in an ODR violation.</p>
<p>This can be avoided by marking the globals as <tt>inline</tt>.</p>
<p>Proposed change: Add <tt>inline</tt> specifier to: <tt>bind</tt> placeholders <tt>_1, _2, ...</tt>, <tt>nullopt</tt>, 
<tt>piecewise_construct</tt>, <tt>allocator_arg</tt>, <tt>ignore</tt>, <tt>seq</tt>, <tt>par</tt>, <tt>par_unseq</tt> in 
<tt>&lt;execution&gt;</tt></p>

<p><i>[2017-02-03, Marshall notes]</i></p>

<p>See also FI 9 (LWG <a href="lwg-active.html#2888">2888</a>).</p>

<p><i>[2017-02-25, Daniel comments]</i></p>

<p>There will be the paper p0607r0 provided for the Kona meeting that solves this issue.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by p0607r0.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2895" href="#2895">2895.</a> Passing function types to <tt>result_of</tt> and <tt>is_callable</tt></h3>
<p><b>Section:</b> 20.15.6 [meta.rel] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 55</b>

<p>It is becoming more and more apparent that using a function type as the template argument to <tt>result_of</tt> causes 
annoying problems. That was done because C++03 didn't have variadic templates, so it allowed an arbitrary number of types 
to be smuggled into the template via a single parameter, but it's a hack and unnecessary in C++ today. 
<tt>result_of&lt;F(Args...)&gt;</tt> has absolutely nothing to do with a function type that returns <tt>F</tt>, and the 
syntactic trickery using a function type has unfortunate consequences such as top-level <i>cv</i>-qualifiers and arrays 
decaying (because those are the rules for function types).</p>
<p>It might be too late to change <tt>result_of</tt>, but we should not repeat the same mistake for <tt>std::is_callable</tt>.</p>

<p>Proposed change: Possibly get rid of the <tt>is_callable&lt;Fn(ArgTypes?...), R&gt;</tt> specialization. Change the 
primary template <tt>is_callable&lt;class, class R = void&gt; to is_callable&lt;class Fn, class.. ArgTypes?&gt;</tt> and 
define a separate template such as <tt>is_callable_r&lt;class R, class Fn, class... ArgTypes?&gt;</tt> for the version 
that checks the return type. The resulting inconsistency might need to be resolved/improved upon.
</p>

<p><i>[2017-02, pre-Kona]</i></p>

<p>See also LWG <a href="lwg-active.html#2927">2927</a>.</p>

<p><i>[2017-02-22, Daniel comments and provides concrete wording]</i></p>

<p>
The approach chosen to resolve this issue is a merger with LWG <a href="lwg-active.html#2928">2928</a>, that is the <tt>callable</tt>
traits are also renamed to <tt>invocable</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.15.2 [meta.type.synop], header <tt>&lt;type_traits&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.15.6, type relations</i>
[&hellip;]

<del>template &lt;class, class R = void&gt; struct is_callable; // not defined
template &lt;class Fn, class... ArgTypes, class R&gt;
struct is_callable&lt;Fn(ArgTypes...), R&gt;;</del>
<ins>template &lt;class Fn, class... ArgTypes&gt; struct is_invocable;
template &lt;class R, class Fn, class... ArgTypes&gt; struct is_invocable_r;</ins>

<del>template &lt;class, class R = void&gt; struct is_nothrow_callable; // not defined
template &lt;class Fn, class... ArgTypes, class R&gt;
struct is_nothrow_callable&lt;Fn(ArgTypes...), R&gt;;</del>
<ins>template &lt;class Fn, class... ArgTypes&gt; struct is_nothrow_invocable;
template &lt;class R, class Fn, class... ArgTypes&gt; struct is_nothrow_invocable_r;</ins>

[&hellip;]

<i>// 20.15.6, type relations</i>
[&hellip;]
<del>template &lt;class T, class R = void&gt; constexpr bool is_callable_v
= is_callable&lt;T, R&gt;::value;
template &lt;class T, class R = void&gt; constexpr bool is_nothrow_callable_v
= is_nothrow_callable&lt;T, R&gt;::value;</del>
<ins>template &lt;class Fn, class... ArgTypes&gt; constexpr bool is_invocable_v
= is_invocable&lt;Fn, ArgTypes...&gt;::value;
template &lt;class R, class Fn, class... ArgTypes&gt; constexpr bool is_invocable_r_v
= is_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;
template &lt;class Fn, class... ArgTypes&gt; constexpr bool is_nothrow_invocable_v
= is_nothrow_invocable&lt;Fn, ArgTypes...&gt;::value;
template &lt;class R, class Fn, class... ArgTypes&gt; constexpr bool is_nothrow_invocable_r_v
= is_nothrow_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;</ins>
[&hellip;]
</pre>
</blockquote>

</li>

<li><p>Modify 20.15.6 [meta.rel], Table 44 &mdash; "Type relationship predicates", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 44 &mdash; Type relationship predicates</caption>

<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class...<br/> 
ArgTypes<del>, class R</del>&gt;<br/> 
struct is_<ins>invocable</ins><del>callable&lt;<br/> 
Fn(ArgTypes...), R&gt;</del>;</tt>
</td>
<td>
The expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...<del>,<br/>
R</del>)</tt> is well formed when treated<br/>
as an unevaluated operand
</td>
<td>
<tt>Fn</tt><del>, <tt>R</tt>,</del> and all types in the<br/>
parameter pack <tt>ArgTypes</tt> shall<br/>
be complete types, <i>cv</i> <tt>void</tt>, or<br/>
arrays of unknown bound.
</td>
</tr>

<tr>
<td>
<ins><tt>template &lt;class R, class Fn, class...<br/> 
ArgTypes&gt;<br/> 
struct is_invocable_r;</tt></ins>
</td>
<td>
<ins>The expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...,<br/>
R)</tt> is well formed when treated<br/>
as an unevaluated operand</ins>
</td>
<td>
<ins><tt>Fn</tt>, <tt>R</tt>, and all types in the<br/>
parameter pack <tt>ArgTypes</tt> shall<br/>
be complete types, <i>cv</i> <tt>void</tt>, or<br/>
arrays of unknown bound.</ins>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class...<br/> 
ArgTypes<del>, class R</del>&gt;<br/> 
struct is_nothrow_<ins>invocable</ins><del>callable&lt;<br/> 
Fn(ArgTypes...), R&gt;</del>;</tt>
</td>
<td>
<tt>is_<ins>invocable</ins><del>callable</del>_v&lt;<br/>
<ins>Fn, ArgTypes...</ins><del>Fn(ArgTypes...), R</del>&gt;</tt> is<br/>
<tt>true</tt> and the expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...<del>,<br/>
R</del>)</tt> is known not to throw any<br/>
exceptions
</td>
<td>
<tt>Fn</tt><del>, <tt>R</tt>,</del> and all types in the<br/>
parameter pack <tt>ArgTypes</tt> shall<br/>
be complete types, <i>cv</i> <tt>void</tt>, or<br/>
arrays of unknown bound.
</td>
</tr>

<tr>
<td>
<ins><tt>template &lt;class R, class Fn, class...<br/> 
ArgTypes, class R&gt;<br/> 
struct is_nothrow_invocable_r;</tt></ins>
</td>
<td>
<ins><tt>is_invocable_r_v&lt;<br/>
R, Fn, ArgTypes...&gt;</tt> is<br/>
<tt>true</tt> and the expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...,<br/>
R)</tt> is known not to throw any<br/>
exceptions</ins>
</td>
<td>
<ins><tt>Fn</tt>, <tt>R</tt>, and all types in the<br/>
parameter pack <tt>ArgTypes</tt> shall<br/>
be complete types, <i>cv</i> <tt>void</tt>, or<br/>
arrays of unknown bound.</ins>
</td>
</tr>

</table>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-02-24, Daniel comments]</i></p>

<p>
I suggest to apply the paper d0604r0 instead, available on the Kona LWG wiki.
</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by p0604r0.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2912" href="#2912">2912.</a> Add a deduction guide for class template <tt>duration</tt></h3>
<p><b>Section:</b> 20.17.5 [time.duration] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration">issues</a> in [time.duration].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 144</b>

<p></p>
<p>Proposed change:</p>

<p>
Add to <tt>&lt;chrono&gt;</tt> synopsis:
</p>
<blockquote><pre>
template &lt;class Rep, class Period&gt;
duration(const Rep &amp;) -&gt; duration&lt;Rep&gt;;
</pre></blockquote>

<p><i>[2017-02-21; via email]</i></p>

<p>This should be addressed by <a href="http://wg21.link/p0433r2">P0433R2</a>.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0433R2.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;chrono&gt;</tt>:</p>
<blockquote><pre>
<ins>template &lt;class Rep, class Period&gt; duration(const Rep &amp;) -&gt; duration&lt;Rep&gt;;</ins>
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2913" href="#2913">2913.</a> Containers need deduction guides</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 147</b>

<p>One of the motivating features behind deduction guides was constructing containers from a pair of iterators, yet the standard 
library does not provide any such deduction guides. They should be provided in header synopsis for each container in clause 23. 
It is expected that the default arguments from the called constructors will provide the context to deduce any remaining class template arguments, such as the Allocator type, and default comparators/hashers for (unordered) associative containers. At this stage, we 
do not recommend adding additional guides to deduce a (rebound) allocator, comparator etc. due to the likely large number of such 
guides. It is noted that the requirements on <tt>iterator_traits</tt> to be an empty type will produce a SFINAE condition to 
allow correct deduction for vector in the case of the Do-The-Right-Thing clause, resolving ambiguity between two integers, and 
two iterators.
</p>

<p>Proposed change: For each container in clause 23, add to the header synopsis a deduction guide of the form</p>
<blockquote><pre>
template &lt;class Iterator&gt;
<i>container</i>(Iterator, Iterator) -&gt; <i>container</i>&lt;typename iterator_traits&lt;Iterator&gt;::value_type&gt;;
</pre></blockquote>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0433R2.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2914" href="#2914">2914.</a> <tt>std::array</tt> does not support class-template deduction from initializers</h3>
<p><b>Section:</b> 23.3.2 [array.syn] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 148</b>

<p><tt>std::array</tt> does not support class-template deduction from initializers without a deduction guide.</p>

<p>Proposed change:</p>
<p>
Add to <tt>&lt;array&gt;</tt> synopsis:
</p>
<blockquote><pre>
template &lt;class TYPES&gt;
array(TYPES&amp;&amp;...) -&gt; array&lt;common_type_t&lt;TYPES...&gt;, sizeof...(TYPES)&gt;;
</pre></blockquote>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0433R2.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;array&gt;</tt>:</p>
<blockquote><pre><ins>
template &lt;class TYPES&gt;
array(TYPES&amp;&amp;...) -&gt; array&lt;common_type_t&lt;TYPES...&gt;, sizeof...(TYPES)&gt;;</ins>
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2915" href="#2915">2915.</a> The three container adapters should each have a deduction guide</h3>
<p><b>Section:</b> 23.6 [container.adaptors] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 150</b>

<p>The three container adapters should each have a deduction guide allowing the deduction of the value type <tt>T</tt> 
from the supplied container, potentially constrained to avoid confusion with deduction from a copy/move constructor.</p>
<p>Proposed change: For each container adapter, add a deduction guide of the form</p>
<blockquote><pre>
template &lt;class Container&gt;
<i>adapter</i>(const Container&amp;) -&gt; <i>adapter</i>&lt;typename Container::value_type, Container&gt;;
</pre></blockquote>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0433R2.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>









<hr>
<h3><a name="2917" href="#2917">2917.</a> Parallel algorithms cannot easily work with <tt>InputIterator</tt>s</h3>
<p><b>Section:</b> 25 [algorithms], 26.8 [numeric.ops] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 156</b>

<p>Parallel algorithms cannot easily work with <tt>InputIterator</tt>s, as any attempt to partition the work is going to 
invalidate iterators used by other sub-tasks. While this may work for the sequential execution policy, the goal of that 
policy is to transparently switch between serial and parallel execution of code without changing semantics, so there 
should not be a special case extension for this policy. There is a corresponding concern for writing through 
<tt>OutputIterator</tt>s. Note that the input iterator problem could be mitigated, to some extent, by serially copying/moving 
data out of the input range and into temporary storage with a more favourable iterator category, and then the work of the 
algorithm can be parallelized. If this is the design intent, a note to confirm that in the standard would avoid future 
issues filed in this area. However, the requirement of an algorithm that must copy/move values into intermediate storage 
may not be the same as those acting immediately on a dereferenced input iterator, and further issues would be likely. 
It is not clear that anything can be done to improve the serial nature of writing to a simple output iterator though.</p>
<p>Proposed change: All algorithms in the <tt>&lt;algorithm&gt;</tt> and <tt>&lt;numeric&gt;</tt> headers that take an 
execution policy and an <tt>InputIterator</tt> type should update that iterator to a <tt>ForwardIterator</tt>, and similarly 
all such overloads taking an <tt>OutputIterator</tt> should update that iterator to a <tt>ForwardIterator</tt>.</p>
<p>(Conversely, if the design intent is confirmed to support input and output iterators, add a note to state that clearly and avoid confusion and more issues by future generations of library implementers.)</p>

<p><i>[2017-02-13, Alisdair comments]</i></p>

<p>
The pre-Kona mailing has two competing papers that provide wording to address #2917,
sequential constraints on parallel algorithms. They should probably be cross-refrenced
by the issue:
</p>
<ol>
<li><p><a href="http://wg21.link/p0467r1">P0467R1</a>: Iterator Concerns for Parallel Algorithms</p></li>
<li><p><a href="http://wg21.link/p0574r0">P0574R0</a>: Algorithm Complexity Constraints and Parallel Overloads</p></li>
</ol>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0467R2.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>










<hr>
<h3><a name="2918" href="#2918">2918.</a> Possible need for extra storage in <tt>inner_product</tt></h3>
<p><b>Section:</b> 26.8.5 [inner.product] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 161</b>

<p>There is a surprising sequential operation applying <tt>BinaryOp1</tt> in <tt>inner_product</tt> that may, for example, 
require additional storage for the parallel algorithms to enable effective distribution of work, and is likely to be a 
performance bottleneck. <tt><i>GENERALIZED_SUM</i></tt> is probably intended here for the parallel version of the algorithm, 
with the corresponding strengthening on constraints on <tt>BinaryOp1</tt> to allow arbitrary order of evaluation.</p>
<p>Proposed change: For the overloads taking an execution policy, copy the current specification, but replace algorithm in 
<i>Effects</i> with</p>
<blockquote><pre>
<i>GENERALIZED_SUM</i>(plus&lt;&gt;(), init, multiplies&lt;&gt;(*i1, *i2), ...)
<i>GENERALIZED_SUM</i>(binary_op1, init, binary_op2(*i1, *i2), ...)
</pre></blockquote>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0623R0.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2919" href="#2919">2919.</a> The specification for <tt>adjacent_difference</tt> has baked-in sequential semantics</h3>
<p><b>Section:</b> 26.8.11 [adjacent.difference] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 162</b>

<p>The specification for <tt>adjacent_difference</tt> has baked-in sequential semantics, in order to support reading/writing 
through input/output iterators. There should a second specification more amenable to parallelization for the overloads taking 
an execution policy.</p>
<p>Proposed change: Provide a specification for the overloads taking an execution policy this is more clearly suitable for 
parallel execution. (i.e., one that does not refer to an accumulated state.)</p>

<p><i>[2017-02-25, Alisdair comments]</i></p>

<p>
Anthony Williams's paper on parallel algorithm complexity, <a href="http://wg21.link/p0574r0">p0574r0</a>,
includes wording that would resolve LWG issue 2919, and I suggest we defer initial triage to handling that paper.
</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0467R2.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2920" href="#2920">2920.</a> Add a deduction guide for creating a <tt>shared_future</tt> from a <tt>future</tt> rvalue</h3>
<p><b>Section:</b> 30.6.8 [futures.shared_future] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.shared_future">active issues</a> in [futures.shared_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 164</b>

<p>Add a deduction guide for creating a shared future from a future rvalue.</p>

<p>Proposed change:</p>
<p>Add to the <tt>&lt;future&gt;</tt> synopsis:</p>
<blockquote><pre>
template &lt;class R&gt;
shared_future(future&lt;R&gt;&amp;&amp;) -&gt; shared_future&lt;R&gt;;
</pre></blockquote>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0433R2.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;future&gt;</tt>:</p>
<blockquote><pre><ins>
template &lt;class R&gt;
shared_future(future&lt;R&gt;&amp;&amp;) -&gt; shared_future&lt;R&gt;;
</ins></pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2924" href="#2924">2924.</a> An <tt>ExecutionPolicy</tt> overload for <tt>inner_product()</tt> seems impractical</h3>
<p><b>Section:</b> 26.8 [numeric.ops] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.ops">active issues</a> in [numeric.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops">issues</a> in [numeric.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 184</b>

<p>An <tt>ExecutionPolicy</tt> overload for <tt>inner_product()</tt> is specified in the synopsis of <tt>&lt;numeric&gt;</tt>. 
Such an overload seems impractical. <tt>inner_product()</tt> is ordered and cannot be parallelized; this was the motivation for the introduction of <tt>transform_reduce()</tt>.</p>

<p>Proposed change: Delete the <tt>ExecutionPolicy</tt> overload for <tt>inner_product()</tt>.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0623R0.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2925" href="#2925">2925.</a> Template argument deduction is not used in the standard library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 7</b>

<p><a href="http://wg21.link/p0091r3">P0091R3</a> "Template argument deduction for class templates (Rev. 6)" was adopted 
for the core language, but the Standard Library makes no explicit use of this new feature, even though the promise of 
such use provided strong motivation for the feature.</p>

<p>Proposed change: Analyze the Standard Library's constructors to determine which classes would profit from explicit 
deduction guides. Formulate the appropriate guides for those classes and insert them in their respective types.</p>

<p><i>[2017-02-03, Marshall notes]</i></p>

<p><a href="http://wg21.link/p0433">P0433</a> is an attempt to do exactly this.</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by P0433R2.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2926" href="#2926">2926.</a> <tt><i>INVOKE</i>(f, t1, t2,... t<i>N</i>)</tt> and <tt><i>INVOKE</i>(f, t1, t2,... t<i>N</i>, R)</tt> are too similar</h3>
<p><b>Section:</b> 20.14.3 [func.require] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>Discussion:</b></p>
<b>Addresses US 84</b>

<p>The distinction between <tt><i>INVOKE</i>(f, t1, t2,... tN)</tt> and <tt><i>INVOKE</i>(f, t1, t2,... tN, R)</tt> is too subtle. 
If the last argument is an expression, it represents <tt>tN</tt>, if it's a type, then it represents <tt>R</tt>. Very clumsy.</p>

<p>Proposed change: Rename <tt><i>INVOKE</i>(f, t1, t2,... tN, R)</tt> to <tt><i>INVOKE_R</i>(R, f, t1, t2,... tN)</tt> and 
adjust all uses of this form. (Approximately 10 occurrences of invoke would need to change.)</p>


<p><i>[2017-02-24, Daniel comments]</i></p>

<p>
I suggest to apply the paper d0604r0, available on the Kona LWG wiki, implements this suggestions.
</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by p0604r0.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2927" href="#2927">2927.</a> Encoding a functor and argument types as a function signature for <tt>is_callable</tt> and <tt>result_of</tt> is fragile</h3>
<p><b>Section:</b> 20.15.2 [meta.type.synop], 20.15.6 [meta.rel] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 85</b>

<p>The trick of encoding a functor and argument types as a function signature for <tt>is_callable</tt> and 
<tt>result_of</tt> loses <i>cv</i> information on argument types, fails for non-decayed function types, and is confusing. E.g.,</p>
<blockquote><pre>
typedef int MyClass::*mp; result_of_t&lt;mp(const MyClass)&gt;;
// should be const, but isn&rsquo;t
typedef int F(double); is_callable&lt;F(float)&gt;; // ill-formed
</pre></blockquote>

<p>Minimal change: </p>
<p>Replace <tt>is_callable&lt;Fn(ArgTypes...)&gt;</tt> with
<tt>is_callable&lt;Fn, ArgTypes...&gt;</tt>
and replace <tt>is_callable&lt;Fn(ArgTypes...), R&gt;</tt> with <tt>is_callable_r&lt;R, Fn, ArgTypes...&gt;</tt>.
Do the same for <tt>is_nothrow_callable</tt>.</p>

<p>Preferred change: </p>
<p>All of the above, plus <tt>deprecate result_of&lt;Fn(ArgTypes...)&gt;</tt> and replace it with 
<tt>result_of_invoke&lt;Fn, ArgTypes...&gt;</tt></p>

<p>See also LWG <a href="lwg-active.html#2895">2895</a>.</p>

<p><i>[2017-02-22, Daniel comments]</i></p>

<p>
LWG <a href="lwg-active.html#2895">2895</a> provides now wording for this issue and for LWG <a href="lwg-active.html#2928">2928</a> as well.
</p>

<p><i>[2017-02-24, Daniel comments]</i></p>

<p>
I suggest to apply the paper d0604r0 instead, available on the Kona LWG wiki.
</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by p0604r0.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2928" href="#2928">2928.</a> <tt>is_callable</tt> is not a good name</h3>
<p><b>Section:</b> 20.15.2 [meta.type.synop], 20.15.6 [meta.rel] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 86</b>

<p><tt>is_callable</tt> is not a good name because it implies <tt>F(A...)</tt> instead of <tt><i>INVOKE</i>(F, A...)</tt></p>

<p>
Proposed change: Rename <tt>is_callable</tt> to <tt>is_invocable</tt> and rename <tt>is_nothrow_callable</tt> to 
<tt>is_nothrow_invocable</tt>.
</p>

<p><i>[2017-02-22, Daniel comments and provides concrete wording]</i></p>

<p>
I'm strongly in favour for this change to possibly allow for a future "pure" <tt>is_callable</tt> trait that solely 
describes function call-like expressions.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.15.2 [meta.type.synop], header <tt>&lt;type_traits&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.15.6, type relations</i>
[&hellip;]

template &lt;class, class R = void&gt; struct is_<ins>invocable</ins><del>callable</del>; // not defined
template &lt;class Fn, class... ArgTypes, class R&gt;
struct is_<ins>invocable</ins><del>callable</del>&lt;Fn(ArgTypes...), R&gt;;

template &lt;class, class R = void&gt; struct is_nothrow_<ins>invocable</ins><del>callable</del>; // not defined
template &lt;class Fn, class... ArgTypes, class R&gt;
struct is_nothrow_<ins>invocable</ins><del>callable</del>&lt;Fn(ArgTypes...), R&gt;;

[&hellip;]

<i>// 20.15.6, type relations</i>
[&hellip;]
template &lt;class T, class R = void&gt; constexpr bool is_<ins>invocable</ins><del>callable</del>_v
= is_<ins>invocable</ins><del>callable</del>&lt;T, R&gt;::value;
template &lt;class T, class R = void&gt; constexpr bool is_nothrow_<ins>invocable</ins><del>callable</del>_v
= is_nothrow_<ins>invocable</ins><del>callable</del>&lt;T, R&gt;::value;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.15.6 [meta.rel], Table 44 &mdash; "Type relationship predicates", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 44 &mdash; Type relationship predicates</caption>

<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class...<br/> 
ArgTypes, class R&gt;<br/> 
struct is_<ins>invocable</ins><del>callable</del>&lt;<br/> 
Fn(ArgTypes...), R&gt;;</tt>
</td>
<td>
[&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class...<br/> 
ArgTypes, class R&gt;<br/> 
struct is_nothrow_<ins>invocable</ins><del>callable</del>&lt;<br/> 
Fn(ArgTypes...), R&gt;;</tt>
</td>
<td>
<tt>is_<ins>invocable</ins><del>callable</del>_v&lt;<br/>
Fn(ArgTypes...), R&gt;</tt> is<br/>
<tt>true</tt> [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-02-24, Daniel comments]</i></p>

<p>
I suggest to apply the paper d0604r0 instead, available on the Kona LWG wiki.
</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Resolved by p0604r0.</p>


<p><b>Proposed resolution:</b></p>






</body>
</html>
