<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-03-28 at 17:03:37 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2378"></a>2378. Behaviour of standard exception types</h3>
<p><b>Section:</b> 18.6.2.1 [bad.alloc], 18.6.2.2 [new.badlength], 18.7.2 [bad.cast], 18.7.3 [bad.typeid], 18.8.2 [bad.exception] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2014-03-31 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think we have an issue with the specification of some of the standard exception types. 
In particular, several of them have default constructors with remarks to the effect that 
"The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined". 
(In some cases this is contradictory to a further specification of <tt>what()</tt>, which 
is specified to return an implementation-defined NTBS.)
</p>

<p>
<strong>Previous resolution from Andy [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Edit 18.6.2.1 [bad.alloc] p3 as indicated:</p>

<blockquote>
<pre>
bad_alloc() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks</i>: <del>The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined</del><ins><tt>what()</tt> returns an implementation-defined NTBS</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.6.2.2 [new.badlength] p3 as indicated: [<i>Drafting note</i>: Added the Postcondition, since we don't 
say anything else about <tt>bad_array_new_length::what()</tt> &mdash; <i>end of note</i>]</p>

<blockquote>
<pre>
bad_array_new_length() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i><del>Remarks</del><ins>Postcondition</ins></i>: <del>The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined</del><ins><tt>what()</tt> returns an implementation-defined NTBS</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.2 [bad.cast] p3 as indicated:</p>

<blockquote>
<pre>
bad_cast() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.3 [bad.typeid] p3 as indicated:</p>

<blockquote>
<pre>
bad_typeid() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.8.2 [bad.exception] p3 as indicated:</p>

<blockquote>
<pre>
bad_exception() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2014-06-17, Rapperswil]</i></p>

<p>
Jonathan provides alternative wording.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
NJ: I don't know why we need the explict statement about <tt>what()</tt> here, since <tt>bad_array_new_length</tt> 
already derives.<br/> 
AM: yes.<br/> 
NJ: Then "what()" is missing from the synopsis.<br/> 
AM: Yes, that's an error and it needs to be added.
<p/>
Conclusion: Update the wording to add the missing entry in the synopsis. 
<p/>
AM: The issue needs another update; we need to add missing "Remarks". DK updates the paper.<br/> 
AM: Any objections to "tentatively ready"? No objections. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Edit 18.6.2.1 [bad.alloc] p3 as indicated:</p>

<blockquote>
<pre>
bad_alloc() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.6.2.1 [bad.alloc] p5 as indicated:</p>

<blockquote>
<pre>
virtual const char* what() const noexcept;
</pre>
<blockquote>
<p>
-5- <i>Returns</i>: An implementation-defined NTBS.
<p/>
<ins>-?- <i>Remarks</i>: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a <tt>wstring</tt> (21.3, 22.4.1.4).</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Edit class <tt>bad_array_new_length</tt> synopsis 18.6.2.2 [new.badlength] as indicated:</p>

<blockquote>
<pre>
namespace std {
  class bad_array_new_length : public bad_alloc {
  public:
    bad_array_new_length() noexcept;
    <ins>virtual const char* what() const noexcept;</ins>
  };
}
</pre>
</blockquote>
</li>

<li><p>Edit 18.6.2.2 [new.badlength] as indicated:</p>

<blockquote>
<pre>
bad_array_new_length() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is 
  implementation-defined.</del>
</p>
</blockquote>
<pre>
<ins>virtual const char* what() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: An implementation-defined NTBS.</ins>
<p/>
<ins>-?- <i>Remarks</i>: The message may be a null-terminated multibyte string (17.5.2.1.4.2), suitable for conversion
and display as a <tt>wstring</tt> (21.3, 22.4.1.4).</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.2 [bad.cast] p3 as indicated:</p>

<blockquote>
<pre>
bad_cast() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.7.3 [bad.typeid] p3 as indicated:</p>

<blockquote>
<pre>
bad_typeid() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 18.8.2 [bad.exception] p3 as indicated:</p>

<blockquote>
<pre>
bad_exception() noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
<del>-3- <i>Remarks</i>: The result of calling <tt>what()</tt> on the newly constructed object is implementation-defined.</del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2410"></a>2410. [fund.ts] <tt>shared_ptr&lt;array&gt;</tt>'s constructor from <tt>unique_ptr</tt> should be constrained</h3>
<p><b>Section:</b> X [mods.util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-06-16 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
The proposed resolution for LWG <a href="lwg-defects.html#2399">2399</a> doesn't apply cleanly to the Fundamentals TS, but the issue is still present.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
Unanimous consent. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4023 in regard to fundamental-ts changes.</p>

<ol>
<li><p>In fundamental-ts, change [mods.util.smartptr.shared.const] p34 as indicated:</p>

<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
-34- <i><del>Requires</del><ins>Remarks</ins></i>: <ins>This constructor shall not participate in overload resolution
unless</ins> <tt>Y*</tt> <del>shall be</del><ins>is</ins> <i>compatible with</i> <tt>T*</tt>. 
<p/>
-35- <i>Effects</i>: Equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt> when <tt>D</tt> is not a reference type, 
otherwise <tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt>.
<p/>
-36- <i>Exception safety</i>: If an exception is thrown, the constructor has no effect. 
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2415"></a>2415. Inconsistency between <tt>unique_ptr</tt> and <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2015-01-19</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt> guarantees that it will not invoke its deleter if it stores
a null pointer, which is useful for deleters that must not be called
with a null pointer e.g.
</p>
<blockquote><pre>
unique_ptr&lt;FILE, int(*)(FILE*)&gt; fptr(file, &amp;::fclose);
</pre></blockquote>
<p>
However, <tt>shared_ptr</tt> does invoke the deleter if it owns a null pointer,
which is a silent change in behaviour when transferring
ownership from <tt>unique_ptr</tt> to <tt>shared_ptr</tt>. That means the following
leads to undefined behaviour:
</p>
<blockquote><pre>
std:shared_ptr&lt;FILE&gt; fp = std::move(fptr);
</pre></blockquote>
<p>
Peter Dimov's suggested fix is to construct an empty <tt>shared_ptr</tt> from a
<tt>unique_ptr</tt> that contains a null pointer.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on eight votes in favour.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] p29 as indicated:</p>
<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: <ins>If <tt>r.get() == nullptr</tt>, equivalent to <tt>shared_ptr()</tt>. Otherwise, if <tt>D</tt> is
not a reference type, equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt>. Otherwise, equivalent to 
<tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt></ins><del>Equivalent to <tt>shared_ptr(r.release(), 
r.get_deleter())</tt> when <tt>D</tt> is not a reference type, otherwise <tt>shared_ptr(r.release(), 
ref(r.get_deleter()))</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2418"></a>2418. [fund.ts] <tt>apply</tt> does not work with member pointers</h3>
<p><b>Section:</b> X [tuple.apply] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2014-07-08 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
The definition of <tt>apply</tt> present in &sect;3.2.2 [tuple.apply] prevents this
function template to be used with pointer to members type passed as the first argument.
</p>
<blockquote>
<i>Effects:</i> 
<p/>
[&hellip;]
<p/>
<tt>return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);</tt>
</blockquote>
<p>
This makes this utility inconsistent with other standard library components and limits its usability.
<p/>
We propose to define its functionally in terms of <tt><i>INVOKE</i></tt>.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
DK: We should use the new <tt>std::invoke</tt>.<br/> 
TK: Is this a defect?<br/> 
AM: <tt>std::invoke</tt> goes into C++17, and this is a defect against a TS based on C++14. We can change this later, 
but now leave it as INVOKE.<br/> 
GR: The TS lets you have Editor's Notes, so leave a note to make that change for C++17.
<p/>
[&hellip;]
<p/>
GR: I can't see how we can assume this is part of the design. I cannot believe it was ever intended for this 
design to exclude function pointers.<br/>  
AM: I can give you the exact evolution: We had "apply" as an example explaining the usefulness of <tt>index_sequence</tt>. 
Then someone looked at it and said, "why isn't this in the Standard". NJ to VV: Why are you against useful steps? 
We are trying to converge on a consistent standard across multiple documents. The alternative is to reopen this 
in a later discussion.<br/>  
VV: All I said is that this is not defect, whether or not people like it.<br/>  
AM: So you'd be fine with the issue, but not as a DR?<br/> 
Straw poll: Who's happy to make this tentatively ready as a DR against the Fundamentals TS? 
Lots of agreement, no opposition, 3 neutrals
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4081.html">N4081</a> 
in regard to fundamental-ts changes.</p>

<ol>
<li><p>Edit &sect;3.2.2 [tuple.apply] paragraph 2:</p>

<blockquote>
<pre>
template &lt;class F, class Tuple&gt;
constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Given the exposition only function
</p>
<blockquote>
<pre>
template &lt;class F, class Tuple, size_t... I&gt;
constexpr decltype(auto) apply_impl(  // <i>exposition only</i>
    F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {
  return <ins><i>INVOKE</i>(</ins>std::forward&lt;F&gt;(f)<del>(</del><ins>, </ins>std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
}
</pre>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2448"></a>2448. Non-normative Container destructor specification</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-10-18 <b>Last modified:</b> 2015-03-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to Table 96 &mdash; "Container requirements" the specification:
</p>
<blockquote><p>
note: the destructor is applied to every element of <tt>a</tt>; any
memory obtained is deallocated.
</p></blockquote>
<p>
The initial "note:" can be read as if that part of the specification would not be normative (This note form
differs from footnotes in tables, which have normative meaning).
<p/>
It seems that this initial part of the specification exists since C++98. But comparing with
the similar <a href="https://www.sgi.com/tech/stl/Container.html">SGI Container specification</a> there is no evidence
for that being intended to be non-normative.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
NJ: If we fix this, we should also fix it elsewhere. Oh, this is the only place?<br/> 
GR: If this is intended to be different from elsewhere, we should make sure.<br/> 
AM: <tt>valarray</tt> specifies this without the "note:".<br/> 
DK: <tt>valarray</tt> requires trivially destructible types!<br/> 
GR: That's good enough for me.<br/> 
NJ: First time <tt>valarray</tt> has been useful for something!
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4140.
</p>

<ol>
<li><p>Change 23.2.1 [container.requirements.general], Table 96 &mdash; "Container requirements", as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>(&amp;a)-&gt;~X()</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
</td>
<td>
<del>note:</del> the destructor<br/>
is applied to every<br/>
element of <tt>a</tt>; any<br/>
memory obtained is
deallocated.
</td>
<td>
linear
</td>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2455"></a>2455. Allocator default construction should be allowed to throw</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-01-18</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements]/4 in the 2014-10 WP (N4140), says:
</p>
<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception. <tt>X::pointer</tt> 
and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
<p>
The words "these types" would normally apply only to the previous sentence only, i.e., only to the pointer types.  
However, an alternative reading would be that the allocator constructors themselves cannot throw. The change to 
the <tt>vector</tt> and <tt>string</tt> default constructors, making them unconditionally <tt>noexcept</tt> depends 
on this alternative reading.
<p/>
I believe that the wording in the standard is not intended to forbid throwing default constructors for allocators.  
Indeed, I believe that allocators do not require default constructors and that if they provide a default constructor 
they should be allowed to throw.
<p/>
In addition, the <tt>noexcept</tt> specifications for the <tt>string</tt> and <tt>vector</tt> default constructors 
should be changed to make them conditional.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p4 as indicated:</p>

<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these <ins>pointer</ins> types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
</li>

<li><p>Change 21.4 [basic.string] following p5, class template <tt>basic_string</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(noexcept(Allocator()))</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>
</li>

<li><p>Change 23.3.6.1 [vector.overview] following p2, class template <tt>vector</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(noexcept(Allocator()))</ins> : vector(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : vector(Allocator()) { }
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2459"></a>2459. <tt>std::polar</tt> should require a non-negative rho</h3>
<p><b>Section:</b> 26.4.7 [complex.value.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-10-22 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Different implementations give different answers for the following code:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;complex&gt;

int main ()
{
  std::cout &lt;&lt; std::polar(-1.0, -1.0) &lt;&lt; '\n';
  return 0;
}
</pre></blockquote>
<p>
One implementation prints:
</p>
<blockquote><pre>
(nan, nan)
</pre></blockquote>
<p>
Another:
</p>
<blockquote><pre>
(-0.243068, 0.243068)
</pre></blockquote>
<p>
Which is correct? Or neither?
<p/>
In <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2013-November/033591.html">this list</a>, 
Howard Hinnant wrote:
</p>
<blockquote class="note">
<p>
I've read this over several times.  I've consulted C++11, C11, and IEC 10967-3.  [snip]
<p/>
I'm finding:
</p>
<ol>
<li><p>The magnitude of a complex number <tt>== abs(c) == hypot(c.real(), c.imag())</tt> and is always non-negative 
(by all three of the above standards).</p></li>
<li><p>Therefore no complex number exists for which <tt>abs(c) &lt; 0</tt>.</p></li>
<li><p>Therefore when the first argument to <tt>std::polar</tt> (which is called <tt>rho</tt>) is negative, no complex number 
can be formed which meets the post-conidtion that <tt>abs(c) == rho</tt>.</p>
</li>
</ol>
<p>
One could argue that this is already covered in 26.4 [complex.numbers]/3, but I think it's worth making explicit.
</p>
</blockquote>

<p><i>[2015-02, Cologne]</i></p>

<p>
Discussion on whether theta should also be constrained.<br/> 
TK: infinite theta doesn't make sense, whereas infinite rho does (theta is on a compact domain, rho is on a non-compact domain).<br/>
AM: We already have a narrow contract, so I don't mind adding further requirements. Any objections to requiring that theta be finite?<br/>
Some more discussion, but general consensus. Agreement that if someone finds the restrictions problematic, they should write 
a proper paper to address how <tt>std::polar</tt> should behave. For now, we allow infinite rho (but not NaN and not negative), 
and require finite theta. 
<p/>
No objections to tentatively ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 26.4.7 [complex.value.ops] around p9 as indicated</p>

<blockquote><pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = 0);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>rho</tt> shall be non-negative and non-NaN. <tt>theta</tt> shall be finite.</ins>
<p/>
-9- <i>Returns</i>: The complex value corresponding to a complex number whose magnitude is <tt>rho</tt> and whose
phase angle is <tt>theta</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2463"></a>2463. [fund.ts] Incorrect complexity for <tt>sample()</tt> algorithm</h3>
<p><b>Section:</b> X [alg.random.sample] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2014-12-17 <b>Last modified:</b> 2015-03-22</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>
<p>
According to paragraph 10.1 of the Library Fundamentals 1 draft, the complexity of the new 
<tt>std::experimental::sample</tt> template function is O(<tt>n</tt>). Note that <tt>n</tt> is actually 
a parameter of this function, corresponding to the sample size. But both common algorithms for 
sampling, the selection algorithm and the reservoir algorithm, are linear with respect to the 
population size, which is often many orders of magnitude bigger than the sample size.
</p>

<p><i>[2015-02, Cologne]</i></p>

<p>
AM: I suggest we make this a DR against the Fundamentals TS.<br/> 
GR: Agreed, this is a no-brainer. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4335 in regard to fundamental-ts changes.</p>

<ol>
<li><p>Change X [alg.random.sample] p5 to read:</p>

<blockquote>
<p>
-5- <i>Complexity</i>: O(<tt><del>n</del><ins>last - first</ins></tt>). 
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2467"></a>2467. <tt>is_always_equal</tt> has slightly inconsistent default</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], 20.7.8.1 [allocator.traits.types] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2015-01-18 <b>Last modified:</b> 2015-03-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 28 &mdash; "Allocator requirements" says that <tt>X::is_always_equal</tt> has a default value 
of <tt>is_empty&lt;X&gt;</tt>, and this is consistent with the return type description:
</p>
<blockquote>
<p>
Identical to or derived from <tt>true_type</tt> or <tt>false_type</tt>
</p>
</blockquote>
<p>
<tt>is_empty&lt;X&gt;</tt> is guaranteed to be derived from either <tt>true_type</tt> or <tt>false_type</tt>.  
So far so good.
<p/>
20.7.8.1 [allocator.traits.types]/p10 says:
</p>
<blockquote>
<pre>
typedef <i>see below</i> is_always_equal;
</pre>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;::type</tt>.
</p>
</blockquote>
</blockquote>
<p>
This is subtly different than what Table 28 says is the default: <tt>is_empty&lt;Alloc&gt;::type</tt> is 
not <tt>is_empty&lt;Alloc&gt;</tt>, but is rather one of <tt>true_type</tt> or <tt>false_type</tt>.
<p/>
There are two ways to fix this:
</p>
<ol>
<li>
<p>
Change Table 28 to say: <tt>is_empty&lt;X&gt;<ins>::type</ins></tt>.
<p/>
or
</p></li>

<li><p>Change 20.7.8.1 [allocator.traits.types]/p10:</p></li>
<blockquote>
<p>
<i>Type</i>: <tt>Alloc::is_always_equal</tt> if the qualified-id <tt>Alloc::is_always_equal</tt> is valid and denotes a
type (14.8.2); otherwise <tt>is_empty&lt;Alloc&gt;<del>::type</del></tt>.
</p>
</blockquote>
</ol>
<p>
Both options are correct, and I see no reason to prefer one fix over the other. But Table 28 and 
20.7.8.1 [allocator.traits.types]/p10 should be consistent with one another.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: We should accept the first bullet. GR: Why does <tt>is_empty</tt> even have a type member? AM: All type traits 
have a type member. I agree with DK's preference for the first type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4296.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as presented:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::is_always_equal</tt>
</td>
<td>
Identical to or derived<br/>
from <tt>true_type</tt> or<br/>
<tt>false_type</tt>
</td>
<td>
[&hellip;]
</td>
<td>
<tt>is_empty&lt;X&gt;<ins>::type</ins></tt>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





</body>
</html>
