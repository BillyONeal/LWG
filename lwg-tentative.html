<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-01-19 at 20:01:34 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2415"></a>2415. Inconsistency between <tt>unique_ptr</tt> and <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2015-01-19</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt> guarantees that it will not invoke its deleter if it stores
a null pointer, which is useful for deleters that must not be called
with a null pointer e.g.
</p>
<blockquote><pre>
unique_ptr&lt;FILE, int(*)(FILE*)&gt; fptr(file, &amp;::fclose);
</pre></blockquote>
<p>
However, <tt>shared_ptr</tt> does invoke the deleter if it owns a null pointer,
which is a silent change in behaviour when transferring
ownership from <tt>unique_ptr</tt> to <tt>shared_ptr</tt>. That means the following
leads to undefined behaviour:
</p>
<blockquote><pre>
std:shared_ptr&lt;FILE&gt; fp = std::move(fptr);
</pre></blockquote>
<p>
Peter Dimov's suggested fix is to construct an empty <tt>shared_ptr</tt> from a
<tt>unique_ptr</tt> that contains a null pointer.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on eight votes in favour.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] p29 as indicated:</p>
<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: <ins>If <tt>r.get() == nullptr</tt>, equivalent to <tt>shared_ptr()</tt>. Otherwise, if <tt>D</tt> is
not a reference type, equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt>. Otherwise, equivalent to 
<tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt></ins><del>Equivalent to <tt>shared_ptr(r.release(), 
r.get_deleter())</tt> when <tt>D</tt> is not a reference type, otherwise <tt>shared_ptr(r.release(), 
ref(r.get_deleter()))</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2455"></a>2455. Allocator default construction should be allowed to throw</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-01-18</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements]/4 in the 2014-10 WP (N4140), says:
</p>
<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception. <tt>X::pointer</tt> 
and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
<p>
The words "these types" would normally apply only to the previous sentence only, i.e., only to the pointer types.  
However, an alternative reading would be that the allocator constructors themselves cannot throw. The change to 
the <tt>vector</tt> and <tt>string</tt> default constructors, making them unconditionally <tt>noexcept</tt> depends 
on this alternative reading.
<p/>
I believe that the wording in the standard is not intended to forbid throwing default constructors for allocators.  
Indeed, I believe that allocators do not require default constructors and that if they provide a default constructor 
they should be allowed to throw.
<p/>
In addition, the <tt>noexcept</tt> specifications for the <tt>string</tt> and <tt>vector</tt> default constructors 
should be changed to make them conditional.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p4 as indicated:</p>

<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these <ins>pointer</ins> types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
</li>

<li><p>Change 21.4 [basic.string] following p5, class template <tt>basic_string</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(noexcept(Allocator()))</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>
</li>

<li><p>Change 23.3.6.1 [vector.overview] following p2, class template <tt>vector</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(noexcept(Allocator()))</ins> : vector(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : vector(Allocator()) { }
</pre>
</blockquote>
</li>

</ol>





</body>
</html>
