<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2014-03-25 at 18:03:14 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2217"></a>2217. <tt>operator==(sub_match, string)</tt> slices on embedded <tt>'\0'</tt>s</h3>
<p><b>Section:</b> 28.9.2 [re.submatch.op] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-11-26 <b>Last modified:</b> 2014-03-03</p>
<p><b>View all other</b> <a href="lwg-index.html#re.submatch.op">issues</a> in [re.submatch.op].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre></blockquote>
<p>
is specified as:
</p>
<blockquote><p>
<i>Returns</i>: <tt>rhs.compare(lhs.c_str()) == 0</tt>.
</p></blockquote>
<p>
This is odd because <tt>sub_match::compare(basic_string)</tt> is defined to
honor embedded <tt>'\0'</tt> characters. This could allow a <tt>sub_match</tt> to <tt>==</tt> or
<tt>!=</tt> a <tt>std::string</tt> unexpectedly.
</p>

<p><i>[Daniel:]</i></p>

<p>
This wording change was done intentionally as of LWG <a href="lwg-defects.html#1181">1181</a>, but the here mentioned slicing
effect was not considered at that time. It seems best to use another overload of compare to fix this problem:
</p>
<blockquote><p>
<i>Returns</i>: <tt>rhs.str().compare(0, rhs.length(), lhs.data(), lhs.size()) == 0</tt>.
</p></blockquote>
<p>
or
</p>
<blockquote><p>
<i>Returns</i>: <tt>rhs.compare(sub_match&lt;BiIter&gt;::string_type(lhs.data(), lhs.size())) == 0</tt>.
</p></blockquote>

<p><i>[2013-10-17: Daniel provides concrete wording]</i></p>


<p>
The original wording was suggested to reduce the need to allocate memory during comparisons. The specification would be
very much easier, if <tt>sub_match</tt> would provide an additional <tt>compare</tt> overload of the form:
</p>
<blockquote><pre>
int compare(const value_type* s, size_t n) const;
</pre></blockquote>
<p>
But given the fact that currently <em>all</em> of <tt>basic_string</tt>'s <tt>compare</tt> overloads are defined in terms
of temporary string constructions, the following proposed wording does follow the same string-construction route as 
<tt>basic_string</tt> does (where needed to fix the embedded zeros issue) and to hope that existing implementations
ignore to interpret this semantics in the literal sense.
<p/>
I decided to use the second replacement form
</p>
<blockquote><pre>
<i>Returns</i>: <tt>rhs.compare(sub_match&lt;BiIter&gt;::string_type(lhs.data(), lhs.size())) == 0</tt>.
</pre></blockquote>
<p>
because it already reflects the existing style used in 28.9.2 [re.submatch.op] p31.
</p>


<p><i>[2014-02-15 post-Issuaquah session : move to Tentatively Ready]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 28.9.2 [re.submatch.op] as indicated:</p>

<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><blockquote>
<p>
-7- <i>Returns:</i> <tt>rhs.compare(<del>lhs.c_str()</del><ins>typename sub_match&lt;BiIter&gt;::string_type(lhs.data(), lhs.size())</ins>) == 0</tt>.
</p>
</blockquote></blockquote>
<p>
[&hellip;]
</p>
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(
    const basic_string&lt;
      typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
    const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><blockquote>
<p>
-9- <i>Returns:</i> <tt>rhs.compare(<del>lhs.c_str()</del><ins>typename sub_match&lt;BiIter&gt;::string_type(lhs.data(), lhs.size())</ins>) &gt; 0</tt>.
</p>
</blockquote></blockquote>
<p>
[&hellip;]
</p>
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                  const basic_string&lt;
                    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA>&amp; rhs);
</pre><blockquote>
<p>
-13- <i>Returns:</i> <tt>lhs.compare(<del>rhs.c_str()</del><ins>typename sub_match&lt;BiIter&gt;::string_type(rhs.data(), rhs.size())</ins>) == 0</tt>.
</p>
</blockquote></blockquote>
<p>
[&hellip;]
</p>
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
  bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                 const basic_string&lt;
                   typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA>&amp; rhs);
</pre><blockquote>
<p>
-15- <i>Returns:</i> <tt>lhs.compare(<del>rhs.c_str()</del><ins>typename sub_match&lt;BiIter&gt;::string_type(rhs.data(), rhs.size())</ins>) &lt; 0</tt>.
</p>
</blockquote></blockquote>

<blockquote><pre>
</pre><blockquote>
<p>
</p>
</blockquote></blockquote>

<blockquote><pre>
</pre><blockquote>
<p>
</p>
</blockquote></blockquote>

<blockquote><pre>
</pre><blockquote>
<p>
</p>
</blockquote></blockquote>

<blockquote><pre>
</pre><blockquote>
<p>
</p>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2266"></a>2266. <tt>vector</tt> and <tt>deque</tt> have incorrect <tt>insert</tt> requirements</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ahmed Charles <b>Opened:</b> 2013-05-17 <b>Last modified:</b> 2014-03-03</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to Table 100 in n3485 23.2.3 [sequence.reqmts]/4 the notes for the expression <tt>a.insert(p,i,j)</tt>
say:
</p>

<blockquote><p>
<i>Requires:</i> <tt>T</tt> shall be <tt>EmplaceConstructible</tt>
into <tt>X</tt> from <tt>*i</tt>. For <tt>vector</tt>, if the iterator
does not meet the forward iterator requirements (24.2.5), <tt>T</tt> shall also be
<tt>MoveInsertable</tt> into <tt>X</tt> and <tt>MoveAssignable</tt>.
<p/>
Each iterator in the range <tt>[i,j)</tt> shall be dereferenced exactly once.
<p/>
<i>pre:</i> <tt>i</tt> and <tt>j</tt> are not iterators into <tt>a</tt>.
<p/>
Inserts copies of elements in <tt>[i, j)</tt> before <tt>p</tt>
</p></blockquote>

<p>
There are two problems with that wording: First, the special constraints for <tt>vector</tt>, that are expressed to be valid for
forward iterators only, are necessary for all iterator categories. Second, the same special constraints are needed for <tt>deque</tt>, too. 
</p>

<p><i>[2013-10-05, Stephan T. Lavavej comments and provides alternative wording]</i></p>

<p>
In Chicago, we determined that the original proposed resolution was correct, except that it needed additional requirements.  
When <tt>vector</tt> <tt>insert(p, i, j)</tt> is called with input-only iterators, it can't know how many elements will be inserted, 
which is obviously problematic for insertion anywhere other than at the end. Therefore, implementations typically append elements 
(geometrically reallocating), followed by <tt>rotate()</tt>. Given forward+ iterators, some implementations append and 
<tt>rotate()</tt> when they determine that there is sufficient capacity. Additionally, <tt>deque</tt> <tt>insert(p, i, j)</tt> is 
typically implemented with prepending/appending, with a possible call to <tt>reverse()</tt>, followed by a call to <tt>rotate()</tt>.  
Note that <tt>rotate()</tt>'s requirements are strictly stronger than <tt>reverse()</tt>'s.
<p/>
Therefore, when patching Table 100, we need to add <tt>rotate()</tt>'s requirements. Note that this does not physically affect code 
(implementations were already calling <tt>rotate()</tt> here), and even in Standardese terms it is barely noticeable &mdash; if an 
element is <tt>MoveInsertable</tt> and <tt>MoveAssignable</tt> then it is almost certainly <tt>MoveConstructible</tt> and swappable.  
However, this patch is necessary to be strictly correct.
</p>

<p>
Previous resolution from Ahmed Charles:
</p>
<blockquote class="note">
<ol>
<li><p>Change Table 100 as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 100 &mdash; Sequence container requirements (in addition to container) (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.insert(p,i,j)</tt>
</td>
<td>
<tt>iterator</tt>
</td>
<td>
<i>Requires:</i> <tt>T</tt> shall be <tt>EmplaceConstructible</tt>
into <tt>X</tt> from <tt>*i</tt>. For <tt>vector</tt> <ins>and <tt>deque</tt></ins>, <del>if the iterator
does not meet the forward iterator requirements (24.2.5),</del> <tt>T</tt> shall also be
<tt>MoveInsertable</tt> into <tt>X</tt> and <tt>MoveAssignable</tt>.<br/>
Each iterator in the range <tt>[i,j)</tt> shall be dereferenced exactly once.<br/>
<i>pre:</i> <tt>i</tt> and <tt>j</tt> are not iterators into <tt>a</tt>.<br/>
Inserts copies of elements in <tt>[i, j)</tt> before <tt>p</tt>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2014-02-15 post-Issuaquah session : move to Tentatively Ready]</i></p>

<p>
Pablo: We might have gone too far with the fine-grained requirements. Typically these things come in groups.
</p>
<p>
Alisdair: I think the concepts folks assumed we would take their guidance.
</p>
<p>
Move to Tenetatively Ready.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change Table 100 as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 100 &mdash; Sequence container requirements (in addition to container) (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.insert(p,i,j)</tt>
</td>
<td>
<tt>iterator</tt>
</td>
<td>
<i>Requires:</i> <tt>T</tt> shall be <tt>EmplaceConstructible</tt> into <tt>X</tt><br/> 
from <tt>*i</tt>. For <tt>vector</tt> <ins>and <tt>deque</tt></ins>, <del>if the iterator</del><br/>
<del>does not meet the forward iterator requirements (24.2.5),</del> <tt>T</tt> shall also be<br/>
<tt>MoveInsertable</tt> into <tt>X</tt><ins>, <tt>MoveConstructible</tt>,</ins><br/> 
<del>and</del> <tt>MoveAssignable</tt><ins>, and swappable (17.6.3.2 [swappable.requirements])</ins>.<br/>
Each iterator in the range <tt>[i,j)</tt> shall be dereferenced exactly once.<br/>
<i>pre:</i> <tt>i</tt> and <tt>j</tt> are not iterators into <tt>a</tt>.<br/>
Inserts copies of elements in <tt>[i, j)</tt> before <tt>p</tt>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2302"></a>2302. Passing null pointer to placement new</h3>
<p><b>Section:</b> 18.6.1.3 [new.delete.placement] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2013-09-12 <b>Last modified:</b> 2014-03-03</p>
<p><b>View other</b> <a href="lwg-index-open.html#new.delete.placement">active issues</a> in [new.delete.placement].</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>Discussion:</b></p>
<p>
Based on <a href="http://stackoverflow.com/questions/17571103/passing-null-pointer-to-placement-new">this discussion</a> 
and as discussed in <a href="http://accu.org/cgi-bin/wg21/message?wg=core&amp;msg=23998">c++std-core-23998</a> and
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=34442">c++std-lib-34442</a>, calling placement new currently forces the 
compiler to check if the pointer is null before initializing the object (a non-negligible cost). It seems many people were not 
aware of this and they consider it a user error to pass a null pointer to it.
<p/>
Proposed resolution: for <tt>operator new</tt> and <tt>operator new[]</tt>, add:
</p>
<blockquote><p>
<i>Requires:</i> <tt>ptr</tt> shall not be a null pointer.
</p></blockquote>

<p><i>[2014-02-15 post-Issuaquah session : move to Tentatively NAD]</i></p>

<p>
AJM to supply the rationale...
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 18.6.1.3 [new.delete.placement] as indicated:</p>

<blockquote>
<pre>
void* operator new(std::size_t size, void* ptr) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <tt>ptr</tt> shall not be a null pointer.</ins>
<p/>
-2- <i>Returns:</i> <tt>ptr</tt>.
<p/>
-3- <i>Remarks:</i> Intentionally performs no other action.
<p/>
-4- [<i>Example:</i> This can be useful for constructing an object at a known address:
</p><blockquote><pre>
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
</pre></blockquote>
<p>
&mdash; <i>end example</i>]
</p>
</blockquote>
</blockquote>
<blockquote>
<pre>
void* operator new[](std::size_t size, void* ptr) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <tt>ptr</tt> shall not be a null pointer.</ins>
<p/>
-5- <i>Returns:</i> <tt>ptr</tt>.
<p/>
-6- <i>Remarks:</i> Intentionally performs no other action.
</p>
</blockquote>
</blockquote>
</li>

</ol>





</body>
</html>
