<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p><p>Revised 2015-01-29 at 15:01:58 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2111"></a>2111. Which <tt>unexpected</tt>&#47;<tt>terminate</tt> handler is called from the exception handling runtime?</h3>
<p><b>Section:</b> 18.8.3.4 [terminate], D.11.4 [unexpected] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-12-06 <b>Last modified:</b> 2015-01-29</p>
<p><b>View all other</b> <a href="lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Prior to N3242, modified by N3189, we said this about <tt>unexpected()</tt>:
</p>

<blockquote><p>
<i>Effects</i>: Calls the <tt>unexpected_handler</tt> function in effect immediately after evaluating the throw-expression 
(D.13.1), if called by the implementation, or calls the current <tt>unexpected_handler</tt>, if called by the program.
</p></blockquote>

<p>
and this about <tt>terminate()</tt>:
</p>

<blockquote><p>
<i>Effects</i>: Calls the <tt>terminate_handler</tt> function in effect immediately after evaluating the throw-expression (18.8.3.1), 
if called by the implementation, or calls the current <tt>terminate_handler</tt> function, if called by the program.
</p></blockquote>

<p>
But now in both places we say:
</p>

<blockquote><p>
Calls the current <tt>unexpected_handler</tt> function.
</p></blockquote>

<p>
and:
</p>

<blockquote><p>
Calls the current <tt>terminate</tt> function.
</p></blockquote>

<p>
The difference is that in C++98&#47;03 if a destructor reset a handler during stack unwinding, that new handler was 
not called if the unwinding later led to <tt>unexpected()</tt> or <tt>terminate()</tt> being called.  But these new 
words say that this new handler <em>is</em> called. This is an ABI-breaking change in the way exceptions are handled.  
Was this change intentional?
<p/>
N3189 was mainly about introducing exception safety and getters for the handlers. I don't recall the issue of 
<em>which</em> handler gets called being part of the discussion.
<p/>
I propose that we revert to the C++98&#47;03 behavior in this regard, lest ABI's such as the Itanium ABI are invalidated.  
A mechanical way to do this is to revert bullets 9 and 12 of N3189.
</p>

<p><i>[2011-12-09: Daniel comments]</i></p>


<p>
There was no such semantic change intended. It was an unfortunate side effect when trying to better separate different
responsibilities in the previous wording.
<p/>
A related issue is <a href="lwg-active.html#2088">2088</a>.
</p>

<p><i>[2012-01-30: Howard comments]</i></p>


<p>
The C++98&#47;03 wording is somewhat ambiguous:
</p>
<blockquote><p>
Calls the terminate_handler function in effect immediately after evaluating the throw-expression...
</p></blockquote>
<p>
There are potentially two throw-expressions being referred to here, and it is not clear if this sentence is referring to just the first or both:
</p>
<ol>
<li><tt>throw <i>assignment-expression</i>;</tt></li>
<li><tt>throw;</tt></li>
</ol>
<p>
There is ample evidence in current implementations that it is understood that <i>only</i> 
1. was meant. But clearly both 1 and 2 could have been meant. We need a clarification. Does an execution 
of a rethrow (throw;) update which handlers can potentially be called?
</p>
<ol>
<li value="2"><tt>throw;</tt> // update handlers to get_xxx()?</li>
</ol>
<p>
My opinion: Go with existing practice, and clarify what that practice is, if surveys find that everyone 
does the same thing. Gcc 4.2 and Apple do 1. only, and do not reset the handlers to the current handlers 
on throw;.
<p/>
If current practice is not unanimously one way or the other, I have no strong opinion. I have not found 
a motivating use case for the use of any particular handler. Most applications set the handlers once at 
the beginning of the program and then do not change them, and so will not be impacted by whatever decision 
is made here.
</p>

<p><i>[2014-02-15 Issaquah: Move to Review]</i></p>


<p>
STL: Original change in N3242 came from trying to make set/get exception handler thread safe.
The issue requests we revert to 98/03, which Howard notes was already ambiguous.
</p>

<p>
Alisdair: Issue author thinks we made this change in C++11 without taking into account Itanium ABI,
which cannot implement the new semantic (without breaking compatibility).
</p>

<p>
Alisdair: original change in N3242 was trying to solve the problem of which handler is called when
the handler is changing in another thread, but this turns out to be an issue in even the
single-threaded case.
</p>

<p>
Pablo: despite wanting to make it thread safe, you are still changing a global
</p>

<p>
STL and Marshall confirm that there is real implementation divergance on the question, so
we cannot pick just one behavior if we want to avoid breaking exisitng practice.
</p>

<p>
Alisdair: not sure who to talk to across all library vendors to fix, need more information
for progress (IBM and Sun)
</p>

<p>
STL: Howard did identify a problem with the wording as well: <tt>throw;</tt> is a throw expression,
but we typically want to re-activate the in-flight exception, not throw a new copy.
</p>

<p>
Pablo: wondering why all of this wording is here (N3189)? It looks like we were trying to handle another thread
changing handler between a <tt>throw</tt> and <tt>terminate</tt> in current thread.
</p>

<p>
Alisdair: Anything working with exception handling should have used only thread-local resources, but that ship has sailed.
We must account for the same exception object being re-thrown in multiple threads simultaneously, with no happens-before
relationships.
</p>

<p>
Room: Why on earth would we care about exactly which way the program dies when the terminate calls are racing?!
</p>

<p>
Pablo: Reasonable to set the handler once (in <tt>main</tt>) and never change it.
</p>

<p>
Pablo: If willing to put lots of work into this, you could say at point of a <tt>throw</tt> these handlers become
thread local but that is overkill.  We want destructors to be able to change these handlers (if only for backwards
compatibility).
</p>

<p>
Alisdair: the <i>&quot;do it right&quot;</i> is to do something per thread, but that is more work than vendors will want to do.
Want to say setting handler while running multiple threads is unspecified.
</p>

<p>
Pablo: possible all we need to do is say it is always the current handler
</p>

<p>
STL: That prevents an implementation or single threaded program from calling a new handler after a <tt>throw</tt>,
probably should say if <tt>terminate</tt> is called <i>by the implementation</i> (during EH), any handler that was
current can be called.  Leaves it up in the air as to when the handler is captured, supporting the diverging
existing practices.
</p>

<p>
Jeffrey: use <i>happens before</i> terminology to avoid introducing races
</p>

<p>
STL: Give this to concurrency?
</p>

<p>
Jeffrey: It is in clause 18, generally LWG and not SG1 territory.
</p>

<p>
Alisdair: Concerned about introducing <i>happens before</i> into fundamental exception handling since it would affect
single threaded performance as well.  Want to give to concurrency or LEWG/EWG, we are into language design here.
</p>

<p>
Jeffrey: suspect LEWG won't have a strong opinion.  I don't want it to be ours!!!
</p>

<p>
Pablo: Might be a case for core>
</p>

<p>
Alisdair: Would be happier if at least one core person were in the discussion.
</p>

<p>
STL: No sympathy for code that tries to guard the terminate handler.
</p>

<p>
Alisdair: We are back to set it once, globally.  Want to be clear that if <tt>set_terminate</tt> is called just once,
when EH is not active, and never changed again, then the user should get the handler from that specific call.
</p>

<p>
AlisdairM: "unspecified which handler is called if an exception is active when <tt>set_terminate</tt> is called."
This supports existing behaviors, and guarantees which handler is called in non-conentious situations.  Implicit
assumption that a funtion becomes a handler only after a successful call to <tt>set_handler</tt>, so we are not
leaving a door open to the implementation inventing entirely new handlers of its own.
</p>

<p>
<i>Consensus.</i>
</p>

<p>
Poll to confirm status as P1: new consensus is P3
</p>

<p>
<i>Action:</i> Alisdair provides new wording.  Drop from P1 to P3, and move to Review.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Amend 18.8.3.4 [terminate] as indicated:
</p>

<tt>[[noreturn]] void terminate() noexcept;</tt>
<blockquote><p>
<i>Remarks:</i> Called by the implementation when exception handling must be abandoned for any of several reasons (15.5.1)
<del>, in effect immediately after throwing the exception</del>. May also be called directly by the program.
</p></blockquote>

<blockquote><p>
<i>Effects:</i> <ins>Calls a <tt>terminate_handler</tt> function. It is unspecified which <tt>terminate_handler</tt> function will
be called if an exception is active during a call to <tt>set_terminate</tt>. Otherwise c</ins><del>C</del>alls the current
<tt>terminate_handler</tt> function. [<i>Note:</i> A default <tt>terminate_handler</tt> is always considered a callable handler in
this context. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Amend D.11.4 [unexpected] as indicated:
</p>

<tt>[[noreturn]] void unexpected();</tt>
<blockquote><p>
Remarks: Called by the implementation when a function exits via an exception not allowed by its <i>exception-specification</i>
(15.5.2)<del>, in effect after evaluating the throw-expression (D.11.1)</del>. May also be called directly by the program.
</p></blockquote>

<blockquote><p>
<i>Effects:</i> <ins>Calls an <tt>unexpected_handler</tt> function. It is unspecified which <tt>unexpected_handler</tt>
function will be called if an exception is active during a call to <tt>set_unexpected</tt>. Otherwise c</ins><del>C</del>alls the current 
<tt>unexpected_handler</tt> function. [<i>Note:</i> A default <tt>unexpected_handler</tt> is always considered a callable handler in 
this context. &mdash; <i>end note</i>] 
</p></blockquote>






<hr>
<h3><a name="2380"></a>2380. May <tt>&lt;cstdlib&gt;</tt> provide <tt>long ::abs(long)</tt> and <tt>long long ::abs(long long)</tt>?</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-03-31 <b>Last modified:</b> 2015-01-29</p>
<p><b>View all other</b> <a href="lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.5 [depr.c.headers] p3 says:
</p>
<blockquote><p>
[<i>Example</i>: The header <tt>&lt;cstdlib&gt;</tt> assuredly provides its declarations and definitions within the namespace
<tt>std</tt>. It may also provide these names within the global namespace. The header <tt>&lt;stdlib.h&gt;</tt> assuredly
provides the same declarations and definitions within the global namespace, much as in the C Standard. It
may also provide these names within the namespace <tt>std</tt>. &mdash; <i>end example</i>]
</p></blockquote>
<p>
This suggests that <tt>&lt;cstdlib&gt;</tt> may provide <tt>::abs(long)</tt> and <tt>::abs(long long)</tt>. But this seems like 
it might contradict the normative wording of 17.6.1.2 [headers] p4:
</p>
<blockquote><p>
Except as noted in Clauses 18 through 30 and Annex D, the contents of each header <tt>c<em>name</em></tt> shall be the same
as that of the corresponding header <tt><em>name</em>.h</tt>, as specified in the C standard library (1.2) or the C Unicode
TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for
names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace <tt>std</tt>. It is
unspecified whether these names are first declared within the global namespace scope and are then injected
into namespace <tt>std</tt> by explicit using-declarations (7.3.3).
</p></blockquote>
<p>
Note that this allows <tt>&lt;cstdlib&gt;</tt> to provide <tt>::abs(int)</tt>, but does not obviously allow <tt>::abs(long)</tt> 
nor <tt>::abs(long long)</tt>, since they are not part of the header <tt>stdlib.h</tt> as specified in the C standard library.
<p/>
26.8 [c.math] p7 adds signatures <tt>std::abs(long)</tt> and <tt>std::abs(long long)</tt>, but not in a way that seems 
to allow <tt>::abs(long)</tt> and <tt>::abs(long long)</tt> to be provided.
<p/>
I think the right approach here would be to allow <tt>&lt;cstdlib&gt;</tt> to either provide no <tt>::abs</tt> declaration, or 
to provide all three declarations from namespace <tt>std</tt>, but it should not be permitted to provide only <tt>int abs(int)</tt>. 
Suggestion:
<p/>
Change in 17.6.1.2 [headers] p4:
</p>
<blockquote><p>
[&hellip;]. It is unspecified whether these names <ins>(including any overloads added in Clauses 18 through 30 and Annex D)</ins> 
are first declared within the global namespace scope and are then injected into namespace <tt>std</tt> by explicit using-declarations 
(7.3.3).
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Modify 17.6.1.2 [headers] p4 as indicated:</p>

<blockquote><p>
Except as noted in Clauses 18 through 30 and Annex D, the contents of each header <tt>c<em>name</em></tt> shall be the same
as that of the corresponding header <tt><em>name</em>.h</tt>, as specified in the C standard library (1.2) or the C Unicode
TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for
names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace <tt>std</tt>. It is
unspecified whether these names <ins>(including any overloads added in Clauses 18 through 30 and Annex D)</ins> are first 
declared within the global namespace scope and are then injected into namespace <tt>std</tt> by explicit using-declarations (7.3.3).
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2415"></a>2415. Inconsistency between <tt>unique_ptr</tt> and <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.8.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2015-01-29</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_ptr</tt> guarantees that it will not invoke its deleter if it stores
a null pointer, which is useful for deleters that must not be called
with a null pointer e.g.
</p>
<blockquote><pre>
unique_ptr&lt;FILE, int(*)(FILE*)&gt; fptr(file, &amp;::fclose);
</pre></blockquote>
<p>
However, <tt>shared_ptr</tt> does invoke the deleter if it owns a null pointer,
which is a silent change in behaviour when transferring
ownership from <tt>unique_ptr</tt> to <tt>shared_ptr</tt>. That means the following
leads to undefined behaviour:
</p>
<blockquote><pre>
std:shared_ptr&lt;FILE&gt; fp = std::move(fptr);
</pre></blockquote>
<p>
Peter Dimov's suggested fix is to construct an empty <tt>shared_ptr</tt> from a
<tt>unique_ptr</tt> that contains a null pointer.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on eight votes in favour.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 20.8.2.2.1 [util.smartptr.shared.const] p29 as indicated:</p>
<blockquote>
<pre>
template &lt;class Y, class D&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-29- <i>Effects</i>: <ins>If <tt>r.get() == nullptr</tt>, equivalent to <tt>shared_ptr()</tt>. Otherwise, if <tt>D</tt> is
not a reference type, equivalent to <tt>shared_ptr(r.release(), r.get_deleter())</tt>. Otherwise, equivalent to 
<tt>shared_ptr(r.release(), ref(r.get_deleter()))</tt></ins><del>Equivalent to <tt>shared_ptr(r.release(), 
r.get_deleter())</tt> when <tt>D</tt> is not a reference type, otherwise <tt>shared_ptr(r.release(), 
ref(r.get_deleter()))</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2420"></a>2420. <tt>function&lt;void(ArgTypes...)&gt;</tt> does not discard the return value of the target object</h3>
<p><b>Section:</b> 20.9.11.2 [func.wrap.func] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n Berg&eacute; <b>Opened:</b> 2014-07-12 <b>Last modified:</b> 2015-01-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>function&lt;void(ArgTypes...)&gt;</tt> should discard the return value of the target object. This behavior was 
in the original proposal, and it was removed (accidentally?) by the resolution of LWG <a href="lwg-defects.html#870">870</a>.
</p>

<p><i>[2014-10-05 Daniel comments]</i></p>

<p>
This side-effect was indeed not intended by <a href="lwg-defects.html#870">870</a>.
</p>


<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Edit 20.9.11.2 [func.wrap.func] paragraph 2:</p>

<blockquote>
<p>
A callable object <tt>f</tt> of type <tt>F</tt> is <i>Callable</i> for argument types <tt>ArgTypes</tt> and return type 
<tt>R</tt> if the expression <tt><i>INVOKE</i>(f, declval&lt;ArgTypes&gt;()...<del>, R</del>)</tt>, considered as an unevaluated 
operand (Clause 5), is well formed (20.9.2 [func.require])<ins> and, if <tt>R</tt> is not <tt>void</tt>, implicitly 
convertible to <tt>R</tt></ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2455"></a>2455. Allocator default construction should be allowed to throw</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2015-01-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements]/4 in the 2014-10 WP (N4140), says:
</p>
<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these types shall exit via an exception. <tt>X::pointer</tt> 
and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
<p>
The words "these types" would normally apply only to the previous sentence only, i.e., only to the pointer types.  
However, an alternative reading would be that the allocator constructors themselves cannot throw. The change to 
the <tt>vector</tt> and <tt>string</tt> default constructors, making them unconditionally <tt>noexcept</tt> depends 
on this alternative reading.
<p/>
I believe that the wording in the standard is not intended to forbid throwing default constructors for allocators.  
Indeed, I believe that allocators do not require default constructors and that if they provide a default constructor 
they should be allowed to throw.
<p/>
In addition, the <tt>noexcept</tt> specifications for the <tt>string</tt> and <tt>vector</tt> default constructors 
should be changed to make them conditional.
</p>

<p><i>[2015-01-18 Library reflector vote]</i></p>

<p>
The issue has been identified as Tentatively Ready based on six votes in favour.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements] p4 as indicated:</p>

<blockquote><p>
An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these <ins>pointer</ins> types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access iterator (24.2).
</p></blockquote>
</li>

<li><p>Change 21.4 [basic.string] following p5, class template <tt>basic_string</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(noexcept(Allocator()))</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 21.4.2, construct/copy/destroy:</i>
basic_string() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : basic_string(Allocator()) { }
</pre>
</blockquote>
</li>

<li><p>Change 23.3.6.1 [vector.overview] following p2, class template <tt>vector</tt> synopsis, as indicated: 
(This change assumes that N4258 has been applied, as voted on in Urbana on 2014-11-08)</p>

<blockquote>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(noexcept(Allocator()))</ins> : vector(Allocator()) { }
</pre>
</blockquote>

<blockquote class="note">
<p>
An alternative formulation of the above would be:
</p>
<pre>
<i>// 23.3.6.2, construct/copy/destroy:</i>
vector() noexcept<ins>(is_nothrow_default_constructible&lt;Allocator&gt;{})</ins> : vector(Allocator()) { }
</pre>
</blockquote>
</li>

</ol>





</body>
</html>
