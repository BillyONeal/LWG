<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2016-06-19 at 21:06:01 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2179" href="#2179">2179.</a> <tt>enable_shared_from_this</tt> and construction from raw pointers</h3>
<p><b>Section:</b> 20.10.2.5 [util.smartptr.enab], 20.10.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-16 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
On reflector message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32927">c++std-lib-32927</a>, 
Matt Austern asked whether the following example should be well-defined or not
</p>
<blockquote><pre>
struct X : public enable_shared_from_this&lt;X&gt; { };
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
pointing out that 20.10.2.2.1 [util.smartptr.shared.const] does not seem to allow it, since
<tt>xp1</tt> and <tt>xp2</tt> aren't allowed to share ownership, because each of them is required to have 
<tt>use_count() == 1</tt>. Despite this wording it might be reasonable (and technical possible)
to implement that request.
<p/>
On the other hand, there is the non-normative note in 20.10.2.5 [util.smartptr.enab] p11 (already part of TR1):
</p>
<blockquote><p>
The <tt>shared_ptr</tt> constructors that <span style="color:#C80000;font-weight:bold">create unique pointers</span> 
can detect the presence of an <tt>enable_shared_from_this</tt> base and assign the newly created <tt>shared_ptr</tt> 
to its <tt>__weak_this member</tt>.
</p></blockquote>
<p>
Now according to the specification in 20.10.2.2.1 [util.smartptr.shared.const] p3-7:
</p>
<blockquote><pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre></blockquote>
<p>
the notion of <em>creating unique pointers</em> can be read to be included by this note, because the post-condition
of this constructor is <tt>unique() == true</tt>. Evidence for this interpretation seems to be weak, though.
<p/>
Howard Hinnant presented the counter argument, that actually the following is an "anti-idiom" and it seems questionable 
to teach it to be well-defined in any case:
</p>
<blockquote><pre>
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
He also pointed out that the current post-conditions of the affected <tt>shared_ptr</tt> constructor
would need to be reworded.
<p/>
It needs to be decided, which direction to follow. If this idiom seems too much broken to be supported,
the note could be improved. If it should be supported, the constructors in
20.10.2.2.1 [util.smartptr.shared.const] need a careful analysis to ensure that post-conditions
are correct.
<p/>
Several library implementations currently do not support this example, instead they typically
cause a crash. Matt points out that there are currently no explicit requirements imposed on
<tt>shared_ptr</tt> objects to prevent them from owning the same underlying object without sharing the 
ownership. It might be useful to add such a requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
More discussion is needed to pick a direction to guide a proposed resolution.
</p>

<p><i>[2013-05-09 Jonathan comments]</i></p>

<p>
The note says the newly created <tt>shared_ptr</tt> is assigned to the <tt>weak_ptr</tt> member. It doesn't 
say before doing that the <tt>shared_ptr</tt> should check if the <tt>weak_ptr</tt> is non-empty and possibly 
share ownership with some other pre-existing <tt>shared_ptr</tt>.
</p>

<p><i>[2015-08-26 Daniel comments]</i></p>

<p>
LWG issue <a href="lwg-active.html#2529">2529</a> is independent but related to this issue.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2208" href="#2208">2208.</a> <tt>std::reverse_iterator</tt> should be a literal type</h3>
<p><b>Section:</b> 24.5.1 [reverse.iterators] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in [reverse.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
<tt>std::reverse_iterator::reverse_iterator(Iterator)</tt> should be constexpr
so that other constexpr functions can return <tt>reverse_iterator</tt>s. Of the
other methods, the other constructors, <tt>base()</tt>, <tt>operator+</tt>, <tt>operator-</tt>,
<tt>operator[]</tt>, and the non-member operators can probably also be
<tt>constexpr</tt>.
<p/>
<tt>operator*</tt> cannot be constexpr because it involves an assignment to a
member variable. Discussion starting with c++std-lib-33282 indicated
that it would be useful to make reverse_iterator a literal type
despite this restriction on its use at compile time.
</p>



<p><b>Proposed resolution:</b></p>
This issue was Resolved by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0">P0031R0</a>
adopted at Jacksonville, 2016.





<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.10.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.10.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.10.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.10.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.10.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.10.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.10.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.10.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2391" href="#2391">2391.</a> <tt>basic_string</tt> is missing non-<tt>const</tt> <tt>data()</tt></h3>
<p><b>Section:</b> 21.3.1 [basic.string] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Michael Bradshaw <b>Opened:</b> 2014-05-27 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Regarding 21.3.1 [basic.string], <tt>std::basic_string&lt;charT&gt;::data()</tt> returns a <tt>const charT*</tt> 
21.3.1.7.1 [string.accessors]. While this method is convenient, it doesn't quite match <tt>std::array&lt;T&gt;::data()</tt> 
23.3.7.5 [array.data] or <tt>std::vector&lt;T&gt;::data()</tt> 23.3.11.4 [vector.data], both of which provide two 
versions (that return <tt>T*</tt> or <tt>const T*</tt>). An additional <tt>data()</tt> method can be added to 
<tt>std::basic_string</tt> that returns a <tt>charT*</tt> so it can be used in similar situations that <tt>std::array</tt> and 
<tt>std::vector</tt> can be used. Without a non-<tt>const</tt> <tt>data()</tt> method, <tt>std::basic_string</tt> has to be treated 
specially in code that is otherwise oblivious to the container type being used.
<p/>
Adding a <tt>charT*</tt> return type to <tt>data()</tt> would be equivalent to doing <tt>&amp;str[0]</tt> or <tt>&amp;str.front()</tt>.
<p/>
Small discussion on the issue can be found <a href="http://stackoverflow.com/questions/7518732/why-are-stdvectordata-and-stdstringdata-different">here</a>
and in the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/ll9HuEML6zo/discussion">std-discussion thread</a>  
(which didn't get too much attention).
<p/>
This requires a small change to <tt>std::basic_string</tt>'s definition in 21.3.1 [basic.string] to add the method to 
<tt>std::basic_string</tt>, and another small change in 21.3.1.7.1 [string.accessors] to define the new method.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Back to LEWG.
</p>

<p><i>[2016-05-22]</i></p>

<p>
Marshall says: this issue has been resolved by P0272R1.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change class template <tt>basic_string</tt> synopsis, 21.3.1 [basic.string], as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
  class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    <i>// 21.4.7, string operations:</i>
    const charT* c_str() const noexcept;
    const charT* data() const noexcept;
    <ins>charT* data() noexcept;</ins>
    allocator_type get_allocator() const noexcept;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Add the following sequence of paragraphs following 21.3.1.7.1 [string.accessors] p3, as indicated:</p>
<blockquote>
<pre>
<ins>charT* data() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: A pointer <tt>p</tt> such that <tt>p + i == &amp;operator[](i)</tt> for each <tt>i</tt> in <tt>[0,size()]</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Constant time.</ins>
<p/>
<ins>-?- <i>Requires</i>: The program shall not alter the value stored at <tt>p + size()</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2509" href="#2509">2509.</a> [fund.ts.v2] <tt>any_cast</tt> doesn't work with rvalue reference targets and cannot move with a value target</h3>
<p><b>Section:</b> 6.4 [fund.ts.v2::any.nonmembers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-06-13 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html">Library Fundamentals v1</a>, 
[any.nonmembers]/5 says:
</p>
<blockquote><p>
For the first form, <tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the second and third forms, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.
</p></blockquote>
<ol>
<li><p>This means that</p>
<blockquote><pre>
any_cast&lt;Foo&amp;&amp;&gt;(<i>whatever_kind_of_any_lvalue_or_rvalue</i>);
</pre></blockquote>
<p>
is always ill-formed.  That's unfortunate, because forwarding such a cast
result of an <tt>any</tt> is actually useful, and such uses do not want to copy/move
the underlying value just yet.
</p>
</li>

<li><p>Another problem is that that same specification prevents an implementation
from moving to the target when</p>
<blockquote><pre>
ValueType any_cast(any&amp;&amp; operand);
</pre></blockquote>
<p>
is used. The difference is observable, so an implementation can't perform
an optimization under the as-if rule. We are pessimizing every <tt>CopyConstructible</tt>
<em>and</em> <tt>MoveConstructible</tt> type because we are not using the move when
we can. This unfortunately includes types such as the library containers,
and we do not want such a pessimization!
</p>
</li>
</ol>

<p><i>[2015-07, Telecom]</i></p>

<p>Jonathan to provide wording</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Eric offered to help JW with wording</p>
<p>Move to Open</p>

<p><i>[2016-01-30, Ville comments and provides wording]</i></p>

<p>
Drafting note: the first two changes add support for types that have
explicitly deleted move constructors. Should we choose not to support
such types at all, the third change is all we need. For the second change,
there are still potential cases where <i>Requires</i> is fulfilled but <i>Effects</i>
is ill-formed, if a suitably concocted type is thrown into the mix.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>.
</p>

<ol>
<li><p>In 6.3.1 [any.cons] p11+p12, edit as follows:</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-10- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-11- <i>Requires</i>: <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements<ins>, except for the requirements 
for <tt>MoveConstructible</tt></ins>. If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.
<p/>
-12- <i>Effects</i>: <ins>If <tt>is_constructible_v&lt;T, ValueType&amp;&amp;&gt;</tt> is true, c</ins><del>C</del>onstructs 
an object of type <tt>any</tt> that contains an object of type <tt>T</tt> direct-initialized with 
<tt>std::forward&lt;ValueType&gt;(value)</tt>. <ins>Otherwise, constructs an object of type <tt>any</tt> that contains an object of 
type <tt>T</tt> direct-initialized with <tt>value</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 6.4 [any.nonmembers] p5, edit as follows:</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or <tt>is_copy_constructible_v&lt;ValueType&gt;</tt> 
is <tt>true</tt>. Otherwise the program is ill-formed. 
<p/>
-5- <i>Returns</i>: For the first form, <tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the second <del>and third</del> form<del>s</del>, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>. 
<ins>For the third form, if <tt>is_move_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt> and
<tt>is_lvalue_reference_v&lt;ValueType&gt;</tt> is <tt>false</tt>, 
<tt>std::move(*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand))</tt>, otherwise,
<tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2529" href="#2529">2529.</a> Assigning to <tt>enable_shared_from_this::__weak_this</tt> twice</h3>
<p><b>Section:</b> 20.10.2.5 [util.smartptr.enab] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-08-26 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear what should happen if a pointer to an object with an
<tt>enable_shared_from_this</tt> base is passed to two different <tt>shared_ptr</tt>
constructors.
</p>
<blockquote><pre>
#include &lt;memory&gt;

using namespace std;

int main()
{
  struct X : public enable_shared_from_this&lt;X&gt; { };
  auto xraw = new X;
  shared_ptr&lt;X&gt; xp1(xraw);  // #1
  {
    shared_ptr&lt;X&gt; xp2(xraw, [](void*) { });  // #2
  }
  xraw-&gt;shared_from_this();  // #3
}
</pre></blockquote>
<p>
This is similar to LWG <a href="lwg-active.html#2179">2179</a>, but involves no undefined behaviour due
to the no-op deleter, and the question is not whether the second
<tt>shared_ptr</tt> should share ownership with the first, but which <tt>shared_ptr</tt>
shares ownership with the <tt>enable_shared_from_this::__weak_this</tt> member.
<p/>
With all three of the major <tt>std::shared_ptr</tt> implementations the <tt>xp2</tt>
constructor modifies the <tt>__weak_this</tt> member so the last line of the
program throws <tt>bad_weak_ptr</tt>, even though all the requirements on the 
<tt>shared_from_this()</tt> function are met (20.10.2.5 [util.smartptr.enab])/7:
</p>
<blockquote><p>
<i>Requires</i>: <tt>enable_shared_from_this&lt;T&gt;</tt> shall be an accessible base class
of <tt>T</tt>. <tt>*this</tt> shall be a subobject of an object <tt>t</tt> of type <tt>T</tt>. There shall
be at least one <tt>shared_ptr</tt> instance <tt>p</tt> that owns <tt>&amp;t</tt>.
</p></blockquote>
<p>
Boost doesn't update <tt>__weak_this</tt>, leaving it sharing with <tt>xp1</tt>, so the
program doesn't throw. That change was made to <tt>boost::enable_shared_from_this</tt> because 
someone reported exactly this issue as a bug, see <a href="https://svn.boost.org/trac/boost/ticket/2584">Boost issue 2584</a>.
<p/>
On the reflector Peter Dimov explained that there are real-world use
cases that rely on the Boost behaviour, and none which rely on the
behaviour of the current <tt>std::shared_ptr</tt> implementations. We should
specify the behaviour of <tt>enable_shared_from_this</tt> more precisely, and
resolve this issue one way or another.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2596" href="#2596">2596.</a> <tt>vector::data()</tt> should use <tt>addressof</tt></h3>
<p><b>Section:</b> 23.3.11.4 [vector.data] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-02-29 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.data">issues</a> in [vector.data].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 23.3.11.4 [vector.data], we have:
</p>
<blockquote>
<p>
<i>Returns</i>: A pointer such that <tt>[data(),data() + size())</tt> is a valid range. For a non-empty vector, 
<tt>data() == &amp;front()</tt>.
</p>
</blockquote>
<p>
This should be:
</p>
<blockquote>
<p>
<i>Returns</i>: A pointer such that <tt>[data(),data() + size())</tt> is a valid range. For a non-empty vector, 
<tt>data() == addressof(front())</tt>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 23.3.11.4 [vector.data] p1 as indicated:</p>

<blockquote>
<pre>
T* data() noexcept;
const T* data() const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: A pointer such that <tt>[data(), data() + size())</tt> is a valid range. For a non-empty vector,
<tt>data() == <ins>addressof(</ins><del>&amp;</del>front()<ins>)</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2674" href="#2674">2674.</a> Bidirectional iterator requirement on <code>path::iterator</code>
is very expensive</h3>
<p><b>Section:</b> 27.10.8.5 [path.itr] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-09-15 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.10.8.5 [path.itr] requires <tt>path::iterator</tt> to be a BidirectionalIterator, which also implies
the ForwardIterator requirement in [forward.iterators] p6 for the following assertion
to pass:
</p>
<blockquote>
<pre>
path p("/");
auto it1 = p.begin();
auto it2 = p.begin();
assert( &amp;*it1 == &amp;*it2 );
</pre>
</blockquote>
<p>This prevents iterators containing a <code>path</code>, or constructing one on the fly when
dereferenced, the object they point to must exist outside the iterators and potentially
outlive them. The only practical way to meet the requirement is for <code>p</code> to hold
a container of child <code>path</code> objects so the iterators can refer to those
children. This makes a <code>path</code> object much larger than would naïvely be
expected.</p>
<p>The Boost and MSVC implementations of Filesystem fail to meet this requirement. The
GCC implementation meets it, but it makes <code>sizeof(path) == 64</code> (for 64-bit) or
<code>sizeof(path) == 40</code> for 32-bit, and makes many path operations
more expensive.</p>

<p><i>[21 Nov 2015 Beman comments:]</i></p>

<p>
The ForwardIterator requirement in
[forward.iterators] "If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and only if 
<tt>*a</tt> and <tt>*b</tt> are bound to the same object." will be removed by N4560, Working Draft, C++ Extensions for
Ranges. I see no point in requiring something for the File System TS that is expensive,
has never to my knowledge been requested by users, and is going to go away soon anyhow.
The wording I propose below removes the requirement.
</p>

<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li>
<p>Change 27.10.8.5 [path.itr] paragraph 2:</p>
<blockquote>
<p>A <code>path::iterator</code> is a constant iterator satisfying all the requirements of a bidirectional iterator 
(C++14 §24.1.4 Bidirectional iterators) <ins>except that there is no requirement
that two equal iterators be bound to the same object</ins>. Its <code>value_type</code> is <code>path</code>.</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2683" href="#2683">2683.</a> <code>filesystem::copy()</code> says "no effects"</h3>
<p><b>Section:</b> 27.10.15.3 [fs.op.copy] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-04-19 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.op.copy">active issues</a> in [fs.op.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy">issues</a> in [fs.op.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.10.15.3 [fs.op.copy]/8 the final bullet says "Otherwise, no effects" which
implies there is no call to <code>ec.clear()</code> if nothing happens, nor any
error condition, is that right?
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.10.15.3 [fs.op.copy]/8 as indicated:</p>
<blockquote><del>Otherwise no effects.</del> <ins>For the signature with argument <code>ec</code>, <code>ec.clear()</code>.</ins> 
</blockquote>





<hr>
<h3><a name="2684" href="#2684">2684.</a> priority_queue lacking comparator typedef</h3>
<p><b>Section:</b> 23.6.5 [priority.queue] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-05-02 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#priority.queue">issues</a> in [priority.queue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>The containers that take a comparison functor (<tt>set</tt>, <tt>multiset</tt>,
<tt>map</tt>, and <tt>multimap</tt>) have a typedef for the comparison functor.  
<tt>priority_queue</tt> does not.
</p>


<p><b>Proposed resolution:</b></p>
<p>Augment [priority.queue] as indicated:</p>

<p>
<pre>
 typedef Container container_type;
 <ins>typedef Compare value_compare;</ins>
</pre>
</p>





<hr>
<h3><a name="2685" href="#2685">2685.</a> <tt>shared_ptr</tt> deleters must not not throw on move construction</h3>
<p><b>Section:</b> 20.10.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-05-03 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 20.10.2.2.1 [util.smartptr.shared.const] p8 the <tt>shared_ptr</tt> constructors taking
a deleter say:</p>

<blockquote><p>The copy constructor and destructor of <tt>D</tt> shall not throw exceptions.</p></blockquote>

<p>It's been pointed out that this doesn't forbid throwing moves, which
makes it difficult to avoid a leak here:</p>

<p><pre>
struct D {
  D() = default;
  D(const D&) noexcept = default;
  D(D&&) { throw 1; }
  void operator()(int* p) const { delete p; }
};

shared_ptr&lt;int&gt; p{new int, D{}};
</pre></p>

<p>"The copy constructor" should be changed to reflect that the chosen
constructor might not be a copy constructor, and that copies made
using any constructor must not throw.</p>

<p>N.B. the same wording is used for the allocator argument, but that's
redundant because the <tt>Allocator</tt> requirements already forbid exceptions
when copying or moving.
</p>


<p><b>Proposed resolution:</b></p>
<p>
[Drafting note: the relevant expressions we're concerned about are
enumerated in the <tt>CopyConstructible</tt> and <tt>MoveConstructible</tt>
requirements, so I see no need to repeat them by saying something
clunky like "Initialization of an object of type <tt>D</tt> from an expression
of type (possibly const) <tt>D</tt> shall not throw exceptions", we can just
refer to them. An alternative would be to define
<tt>NothrowCopyConstructible</tt>, which includes <tt>CopyConstructible</tt> but
requires that construction and destruction do not throw.]
</p>

<p>
Change 20.10.2.2.1 [util.smartptr.shared.const] p8:
</p>

<blockquote>
<p>
<tt>D</tt> shall be <tt>CopyConstructible</tt> <ins>and such construction shall not
throw exceptions.</ins> The <del>copy constructor and</del> destructor
of <tt>D</tt> shall not throw exceptions.
</p>
</blockquote>






<hr>
<h3><a name="2688" href="#2688">2688.</a> <tt>clamp</tt> misses preconditions and has extraneous condition on result</h3>
<p><b>Section:</b> 25.5.8 [alg.clamp] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Martin Moene <b>Opened:</b> 2016-03-23 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Jacksonville (2016), <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0025r0.html">P0025R0</a> was 
voted in instead of the intended <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0025r1.html">P0025R1</a>. 
This report contains the necessary mending along with two other improvements.
<p/>
This report:
</p>
<ul>
<li><p>adds the precondition that misses from P0025R0 but is in P0025R1,</p></li>
<li><p>corrects the returns: specification that contains an extraneous condition,</p></li>
<li><p>replaces the now superfluous remark with a note on usage of clamp with <tt>float</tt> or <tt>double</tt>.</p></li>
</ul>
<p>
Thanks to Carlo Assink and David Gaarenstroom for making us aware of the extraneous condition in the returns: 
specification and for suggesting the fix and to Jeffrey Yasskin for suggesting to add a note like p3.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Reworded p3 slightly.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li><p>Edit 25.5.8 [alg.clamp] as indicated:</p>

<blockquote><pre>
template&lt;class T&gt;
  constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: <ins>The value of <tt>lo</tt> shall be no greater than <tt>hi</tt>.</ins> For the first form, 
type <tt>T</tt> shall be <tt>LessThanComparable</tt> (Table 18).
<p/>
-2- <i>Returns</i>: <ins><tt>lo</tt> if <tt>v</tt> is less than <tt>lo</tt>, <tt>hi</tt> if <tt>hi</tt> is less than 
<tt>v</tt>, otherwise <tt>v</tt></ins><del>The larger value of <tt>v</tt> and <tt>lo</tt> if <tt>v</tt> is smaller than 
<tt>hi</tt>, otherwise the smaller value of <tt>v</tt> and <tt>hi</tt></del>.
<p/>
-3- <i><ins>Note</ins><del>Remarks</del></i>: <ins>If NaN is avoided, <tt>T</tt> can be <tt>float</tt> or 
<tt>double</tt></ins><del>Returns the first argument when it is equivalent to one of the boundary arguments</del>.
<p/>
-4- <i>Complexity</i>: At most two comparisons.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<ol>
<li><p>Edit 25.5.8 [alg.clamp] as indicated:</p>

<blockquote><pre>
template&lt;class T&gt;
  constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: <ins>The value of <tt>lo</tt> shall be no greater than <tt>hi</tt>.</ins> For the first form, 
type <tt>T</tt> shall be <tt>LessThanComparable</tt> (Table 18).
<p/>
-2- <i>Returns</i>: <ins><tt>lo</tt> if <tt>v</tt> is less than <tt>lo</tt>, <tt>hi</tt> if <tt>hi</tt> is less than 
<tt>v</tt>, otherwise <tt>v</tt></ins><del>The larger value of <tt>v</tt> and <tt>lo</tt> if <tt>v</tt> is smaller than 
<tt>hi</tt>, otherwise the smaller value of <tt>v</tt> and <tt>hi</tt></del>.
<p/>
-3- <i><ins>Note</ins><del>Remarks</del></i>: <ins>If NaN is avoided, <tt>T</tt> can be a floating point type</ins>
<del>Returns the first argument when it is equivalent to one of the boundary arguments</del>.
<p/>
-4- <i>Complexity</i>: At most two comparisons.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2689" href="#2689">2689.</a> Parallel versions of <tt>std::copy</tt> and <tt>std::move</tt> shouldn't be in order</h3>
<p><b>Section:</b> 25.4.1 [alg.copy], 25.4.2 [alg.move] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-03-23 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.2.5 [algorithms.parallel.overloads]/2 says that "Unless otherwise specified, the semantics of 
<tt>ExecutionPolicy</tt> algorithm overloads are identical to their overloads without."
<p/>
There's no "otherwise specified" for the <tt>ExecutionPolicy</tt> overloads for <tt>std::copy</tt> and <tt>std::move</tt>, 
so the requirement that they "start[] from first and proceed[] to last" in the original algorithm's description would 
seem to apply, which defeats the whole point of adding a parallel overload.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Marshall noted that all three versions of copy have subtly different wording, and suggested that they should not.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Insert the following paragraphs after 25.4.1 [alg.copy]/4:</p>

<blockquote><pre>
<ins>template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator&gt;
  OutputIterator copy(ExecutionPolicy&amp;&amp; policy, InputIterator first, InputIterator last,
                      OutputIterator result);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The ranges <tt>[first, last)</tt> and <tt>[result, result + (last - first))</tt> shall not 
overlap.</ins>
<p/>
<ins>-?- <i>Effects</i>: Copies elements in the range <tt>[first, last)</tt> into the range <tt>[result, result + (last -
first))</tt>. For each non-negative integer <tt>n &lt; (last - first)</tt>, performs <tt>*(result + n) = *(first + n)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>result + (last - first)</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Exactly <tt>last - first</tt> assignments.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Insert the following paragraphs after 25.4.2 [alg.move]/4:</p>

<blockquote><pre>
<ins>template&lt;class ExecutionPolicy, class InputIterator, class OutputIterator&gt;
  OutputIterator move(ExecutionPolicy&amp;&amp; policy, InputIterator first, InputIterator last,
                      OutputIterator result);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The ranges <tt>[first, last)</tt> and <tt>[result, result + (last - first))</tt> shall not 
overlap.</ins>
<p/>
<ins>-?- <i>Effects</i>: Moves elements in the range <tt>[first, last)</tt> into the range <tt>[result, result + (last -
first))</tt>. For each non-negative integer <tt>n &lt; (last - first)</tt>, performs 
<tt>*(result + n) = std::move(*(first + n))</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>result + (last - first)</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Exactly <tt>last - first</tt> assignments.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2692" href="#2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2698" href="#2698">2698.</a> Effect of <tt>assign()</tt> on iterators/pointers/references</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-04-25 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The sequence container requirements table says nothing about the effect of <tt>assign()</tt> on iterators, 
pointers or references into the container. Before LWG <a href="lwg-defects.html#2209">2209</a> (and LWG <a href="lwg-defects.html#320">320</a> for <tt>std::list</tt>), 
<tt>assign()</tt> was specified as "erase everything then <tt>insert</tt>", which implies wholesale invalidation from the 
"erase everything" part. With that gone, the blanket "no invalidation" wording in 
23.2.1 [container.requirements.general]/12 would seem to apply, which makes absolutely no sense.
<p/>
The proposed wording below simply spells out the invalidation rule implied by the previous "erase everything" wording.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to <a href="lwg-active.html#2256">2256</a>
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>In 23.2.3 [sequence.reqmts], edit Table 107 (Sequence container requirements) as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(i, j)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt> and assignable from 
<tt>*i</tt>.<br/>For <tt>vector</tt>, if the iterator does not meet the forward iterator requirements (24.2.5),<br/> 
<tt>T</tt> shall also be <tt>MoveInsertable</tt> into <tt>X</tt>.<br/> Each iterator in the range <tt>[i, j)</tt> shall be 
dereferenced exactly once. <br/>pre: <tt>i</tt>, <tt>j</tt> are not iterators into <tt>a</tt>.<br/> Replaces elements 
in <tt>a</tt> with a copy of <tt>[i, j)</tt>.<ins><br/>Invalidates all references, pointers and iterators referring to the 
elements of <tt>a</tt>.<br/>For <tt>vector</tt> and <tt>deque</tt>, also invalidates the past-the-end iterator.</ins>
</td>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
pre: <tt>t</tt> is not a reference into <tt>a</tt>.<br/> Replaces elements in <tt>a</tt> with <tt>n</tt> 
copies of <tt>t</tt>.<ins><br/>Invalidates all references, pointers and iterators referring to the elements of 
<tt>a</tt>.<br/>
For <tt>vector</tt> and <tt>deque</tt>, also invalidates the past-the-end iterator.</ins>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2706" href="#2706">2706.</a> Error reporting for <tt>recursive_directory_iterator::pop()</tt> is under-specified</h3>
<p><b>Section:</b> 27.10.14 [class.rec.dir.itr] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-09 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike <tt>increment</tt>, <tt>pop()</tt> does not specify how it reports errors nor does it provide a 
<tt>std::error_code</tt> overload. However implementing <tt>pop()</tt> all but requires performing an increment, 
so it should handle errors in the same way.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 27.10.14 [class.rec.dir.itr], class <tt>recursive_directory_iterator</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::filesystem {
  class recursive_directory_iterator {
  public:
    [&hellip;]
    void pop();
    <ins>void pop(error_code&amp; ec);</ins>
    void disable_recursion_pending();
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Change 27.10.14.1 [rec.dir.itr.members] as indicated:</p>

<blockquote>
<pre>
void pop();
<ins>void pop(error_code&amp; ec);</ins>
</pre>
<blockquote>
<p>
-30- <i>Requires</i>: <tt>*this != recursive_directory_iterator()</tt>.
<p/>
-31- <i>Effects</i>: If <tt>depth() == 0</tt>, set <tt>*this</tt> to <tt>recursive_directory_iterator()</tt>. Otherwise, 
cease iteration of the directory currently being iterated over, and continue iteration over the parent directory.
<p/>
<ins>-?- <i>Throws</i>: As specified in Error reporting (27.5.6.5 [error.reporting]).</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2707" href="#2707">2707.</a> <tt>path</tt> construction and assignment should have "<tt>string_type&amp;&amp;</tt>" overloads</h3>
<p><b>Section:</b> 27.10.8 [class.path] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-09 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#class.path">active issues</a> in [class.path].</p>
<p><b>View all other</b> <a href="lwg-index.html#class.path">issues</a> in [class.path].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently construction of a <tt>path</tt> from the native <tt>string_type</tt> always performs a copy, even when 
that string is passed as a rvalue. This is a large pessimization as paths are commonly constructed from temporary strings.
<p/>
One pattern I frequently see is:
</p>
<blockquote><pre>
path foo(path const&amp; p) {
  auto s = p.native();
  mutateString(s);
  return s;
}
</pre></blockquote>
<p>
Implementations should be allowed to move from <tt>s</tt> and avoid an unnecessary allocation.
I believe <tt>string_type&amp;&amp;</tt> constructor and assignment operator overloads should be added to support this.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 27.10.8 [class.path], class <tt>path</tt> synopsis, as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: Making the <tt>string_type&amp;&amp;</tt> constructors and assignment operators <tt>noexcept</tt> 
would over-constrain implementations which may need to perform construct additional state]
</p>
</blockquote>

<blockquote>
<pre>
namespace std::filesystem {
  class path {
  public:
    [&hellip;]
    <i>// 27.10.8.4.1, constructors and destructor</i>
    path() noexcept;
    path(const path&amp; p);
    path(path&amp;&amp; p) noexcept;
    <ins>path(string_type&amp;&amp; source);</ins>
    template &lt;class Source&gt;
    path(const Source&amp; source);
    [&hellip;]
    
    <i>// 27.10.8.4.2, assignments</i>
    path&amp; operator=(const path&amp; p);
    path&amp; operator=(path&amp;&amp; p) noexcept;
    <ins>path&amp; operator=(string_type&amp;&amp; source);
    path&amp; assign(string_type&amp;&amp; source);</ins>
    template &lt;class Source&gt;
    path&amp; operator=(const Source&amp; source);
    template &lt;class Source&gt;
    path&amp; assign(const Source&amp; source)
    template &lt;class InputIterator&gt;
    path&amp; assign(InputIterator first, InputIterator last);    
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add a new paragraph following 27.10.8.4.1 [path.construct]/3:</p>

<blockquote>
<pre>
<ins>path(string_type&amp;&amp; source);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Constructs an object of class <tt>path</tt> with <tt>pathname</tt> having the original value of 
<tt>source</tt>. <tt>source</tt> is left in a valid but unspecified state.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Add a new paragraph following 27.10.8.4.2 [path.assign]/4:</p>

<blockquote>
<pre>
<ins>path&amp; operator=(string_type&amp;&amp; source);
path&amp; assign(string_type&amp;&amp; source);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Modifies <tt>pathname</tt> to have the original value of <tt>source</tt>. <tt>source</tt> 
is left in a valid but unspecified state.</ins>
<p/>
<ins>-?- <i>Returns</i>:<tt>*this</tt></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2710" href="#2710">2710.</a> "<i>Effects:</i> Equivalent to ..." doesn't count "<i>Synchronization:</i>" as determined semantics</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-05-08 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From N4582 17.5.1.4 [structure.specifications] p3 and p4
</p>
<blockquote>
<p>
-3- Descriptions of function semantics contain the following elements (as appropriate):
</p>
<ul>
<li><i>Requires</i>: the preconditions for calling the function</li>
<li><i>Effects</i>: the actions performed by the function</li>
<li><i>Synchronization</i>: the synchronization operations (1.10) applicable to the function</li>
<li><i>Postconditions</i>: the observable results established by the function</li>
<li><i>Returns</i>: a description of the value(s) returned by the function</li>
<li><i>Throws</i>: any exceptions thrown by the function, and the conditions that would cause the exception</li>
<li><i>Complexity</i>: the time and/or space complexity of the function</li>
<li><i>Remarks</i>: additional semantic constraints on the function</li>
<li><i>Error conditions</i>: the error conditions for error codes reported by the function.</li>
<li><i>Notes</i>: non-normative comments about the function</li>
</ul>
<p>
-4- Whenever the <i>Effects:</i> element specifies that the semantics of some function <tt>F</tt> are 
<em>Equivalent to</em> some code sequence, then the various elements are interpreted as follows. If 
<tt>F</tt>'s semantics specifies a <i>Requires:</i> element, then that requirement is logically imposed prior 
to the <em>equivalent-to</em> semantics. Next, the semantics of the code sequence are determined by the 
<i>Requires:</i>, <i>Effects:</i>, <i>Postconditions:</i>, <i>Returns:</i>, <i>Throws:</i>, <i>Complexity:</i>,
<i>Remarks:</i>, <i>Error conditions:</i>, and <i>Notes:</i> specified for the function invocations contained 
in the code sequence. The value returned from <tt>F</tt> is specified by <tt>F</tt>'s <i>Returns:</i> element, 
or if <tt>F</tt> has no <i>Returns:</i> element, a non-<tt>void</tt> return from <tt>F</tt> is specified by the 
<i>Returns:</i> elements in the code sequence. If <tt>F</tt>'s semantics contains a <i>Throws:</i>,
<i>Postconditions:</i>, or <i>Complexity:</i> element, then that supersedes any occurrences of that element in the code
sequence.
</p>
</blockquote>
<p>
The third sentence of p4 says "the semantics of the code sequence are determined
by ..." and lists all elements in p3 except "<i>Synchronization:</i>".
<p/>
I think it was just an oversight because p4 was added by library issue
<a href="lwg-defects.html#997">997</a>, and its proposed resolution was drafted at the time (2009) before
"<i>Synchronization:</i>" was added into p3 for C++11.
<p/>
However, I'm not definitely sure that it is really intended and safe to
just supply "<i>Synchronization:</i>" in the list. (Could a library designer
rely on this in writing new specifications, or could someone rely on
this in writing user codes, after some years after C++11?)
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 17.5.1.4 [structure.specifications] as indicated:</p>

<blockquote>
<p>
-4- Whenever the <i>Effects:</i> element specifies that the semantics of some function <tt>F</tt> are 
<em>Equivalent to</em> some code sequence, then the various elements are interpreted as follows. If 
<tt>F</tt>'s semantics specifies a <i>Requires:</i> element, then that requirement is logically imposed prior 
to the <em>equivalent-to</em> semantics. Next, the semantics of the code sequence are determined by the 
<i>Requires:</i>, <i>Effects:</i><ins>, <i>Synchronization:</i></ins>, <i>Postconditions:</i>, <i>Returns:</i>, 
<i>Throws:</i>, <i>Complexity:</i>,
<i>Remarks:</i>, <i>Error conditions:</i>, and <i>Notes:</i> specified for the function invocations contained 
in the code sequence. The value returned from <tt>F</tt> is specified by <tt>F</tt>'s <i>Returns:</i> element, 
or if <tt>F</tt> has no <i>Returns:</i> element, a non-<tt>void</tt> return from <tt>F</tt> is specified by the 
<i>Returns:</i> elements in the code sequence. If <tt>F</tt>'s semantics contains a <i>Throws:</i>,
<i>Postconditions:</i>, or <i>Complexity:</i> element, then that supersedes any occurrences of that element in the code
sequence.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2717" href="#2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.16.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.16.4 [allocator.adaptor.members] p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





</body>
</html>
